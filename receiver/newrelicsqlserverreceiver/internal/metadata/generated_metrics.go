// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/filter"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

var MetricsInfo = metricsInfo{
	SqlserverActivequeryCPUTime: metricInfo{
		Name: "sqlserver.activequery.cpu_time",
	},
	SqlserverActivequeryElapsedTime: metricInfo{
		Name: "sqlserver.activequery.elapsed_time",
	},
	SqlserverActivequeryGrantedMemory: metricInfo{
		Name: "sqlserver.activequery.granted_memory",
	},
	SqlserverActivequeryLogicalReads: metricInfo{
		Name: "sqlserver.activequery.logical_reads",
	},
	SqlserverActivequeryReads: metricInfo{
		Name: "sqlserver.activequery.reads",
	},
	SqlserverActivequeryRowCount: metricInfo{
		Name: "sqlserver.activequery.row_count",
	},
	SqlserverActivequeryWaitTime: metricInfo{
		Name: "sqlserver.activequery.wait_time",
	},
	SqlserverActivequeryWrites: metricInfo{
		Name: "sqlserver.activequery.writes",
	},
	SqlserverDatabaseBufferpoolSize: metricInfo{
		Name: "sqlserver.database.bufferpool.size",
	},
	SqlserverDatabaseDiskMaxSize: metricInfo{
		Name: "sqlserver.database.disk.max_size",
	},
	SqlserverDatabaseIoStallTime: metricInfo{
		Name: "sqlserver.database.io.stall_time",
	},
	SqlserverDatabaseLogTransactionGrowth: metricInfo{
		Name: "sqlserver.database.log.transaction_growth",
	},
	SqlserverDatabasePagefileAvailable: metricInfo{
		Name: "sqlserver.database.pagefile.available",
	},
	SqlserverDatabasePagefileTotal: metricInfo{
		Name: "sqlserver.database.pagefile.total",
	},
	SqlserverDatabasePrincipalsCount: metricInfo{
		Name: "sqlserver.database.principals.count",
	},
	SqlserverDatabaseRoleMembersUnique: metricInfo{
		Name: "sqlserver.database.role.members.unique",
	},
	SqlserverDatabaseRoleMembershipsActive: metricInfo{
		Name: "sqlserver.database.role.memberships.active",
	},
	SqlserverDatabaseRoleMembershipsTotal: metricInfo{
		Name: "sqlserver.database.role.memberships.total",
	},
	SqlserverDatabaseRoleNestingLevel: metricInfo{
		Name: "sqlserver.database.role.nesting_level",
	},
	SqlserverDatabaseRolePermissionsInherited: metricInfo{
		Name: "sqlserver.database.role.permissions.inherited",
	},
	SqlserverFailoverClusterFailureConditionLevel: metricInfo{
		Name: "sqlserver.failover_cluster.failure_condition_level",
	},
	SqlserverFailoverClusterHealthCheckTimeout: metricInfo{
		Name: "sqlserver.failover_cluster.health_check_timeout",
	},
	SqlserverFailoverClusterReplicaRole: metricInfo{
		Name: "sqlserver.failover_cluster.replica_role",
	},
	SqlserverFailoverClusterSynchronizationHealth: metricInfo{
		Name: "sqlserver.failover_cluster.synchronization_health",
	},
	SqlserverInstanceActiveConnections: metricInfo{
		Name: "sqlserver.instance.active_connections",
	},
	SqlserverInstanceBufferPoolHitPercent: metricInfo{
		Name: "sqlserver.instance.buffer_pool.hit_percent",
	},
	SqlserverInstanceBufferPoolSize: metricInfo{
		Name: "sqlserver.instance.buffer_pool.size",
	},
	SqlserverInstanceDiskMetrics: metricInfo{
		Name: "sqlserver.instance.disk_metrics",
	},
	SqlserverInstanceMemoryAvailable: metricInfo{
		Name: "sqlserver.instance.memory.available",
	},
	SqlserverInstanceMemoryTotal: metricInfo{
		Name: "sqlserver.instance.memory.total",
	},
	SqlserverInstanceMemoryUtilization: metricInfo{
		Name: "sqlserver.instance.memory.utilization",
	},
	SqlserverInstanceProcessCounts: metricInfo{
		Name: "sqlserver.instance.process_counts",
	},
	SqlserverInstanceRunnableTasks: metricInfo{
		Name: "sqlserver.instance.runnable_tasks",
	},
	SqlserverLockModeBulkUpdate: metricInfo{
		Name: "sqlserver.lock.mode.bulk_update",
	},
	SqlserverLockModeExclusive: metricInfo{
		Name: "sqlserver.lock.mode.exclusive",
	},
	SqlserverLockModeIntent: metricInfo{
		Name: "sqlserver.lock.mode.intent",
	},
	SqlserverLockModeSchema: metricInfo{
		Name: "sqlserver.lock.mode.schema",
	},
	SqlserverLockModeShared: metricInfo{
		Name: "sqlserver.lock.mode.shared",
	},
	SqlserverLockModeSharedIntentExclusive: metricInfo{
		Name: "sqlserver.lock.mode.shared_intent_exclusive",
	},
	SqlserverLockModeTotal: metricInfo{
		Name: "sqlserver.lock.mode.total",
	},
	SqlserverLockModeUpdate: metricInfo{
		Name: "sqlserver.lock.mode.update",
	},
	SqlserverLockResourceAllocationUnit: metricInfo{
		Name: "sqlserver.lock.resource.allocation_unit",
	},
	SqlserverLockResourceApplication: metricInfo{
		Name: "sqlserver.lock.resource.application",
	},
	SqlserverLockResourceDatabase: metricInfo{
		Name: "sqlserver.lock.resource.database",
	},
	SqlserverLockResourceExtent: metricInfo{
		Name: "sqlserver.lock.resource.extent",
	},
	SqlserverLockResourceFile: metricInfo{
		Name: "sqlserver.lock.resource.file",
	},
	SqlserverLockResourceHobt: metricInfo{
		Name: "sqlserver.lock.resource.hobt",
	},
	SqlserverLockResourceKey: metricInfo{
		Name: "sqlserver.lock.resource.key",
	},
	SqlserverLockResourceMetadata: metricInfo{
		Name: "sqlserver.lock.resource.metadata",
	},
	SqlserverLockResourcePage: metricInfo{
		Name: "sqlserver.lock.resource.page",
	},
	SqlserverLockResourceRow: metricInfo{
		Name: "sqlserver.lock.resource.row",
	},
	SqlserverLockResourceTable: metricInfo{
		Name: "sqlserver.lock.resource.table",
	},
	SqlserverLockResourceTotal: metricInfo{
		Name: "sqlserver.lock.resource.total",
	},
	SqlserverLockedObject: metricInfo{
		Name: "sqlserver.locked_object",
	},
	SqlserverPlanElapsedTimeAvg: metricInfo{
		Name: "sqlserver.plan.elapsed_time.avg",
	},
	SqlserverPlanElapsedTimeTotal: metricInfo{
		Name: "sqlserver.plan.elapsed_time.total",
	},
	SqlserverPlanExecutionCount: metricInfo{
		Name: "sqlserver.plan.execution_count",
	},
	SqlserverPlanLogicalReads: metricInfo{
		Name: "sqlserver.plan.logical_reads",
	},
	SqlserverPlanLogicalWrites: metricInfo{
		Name: "sqlserver.plan.logical_writes",
	},
	SqlserverPlanWorkerTime: metricInfo{
		Name: "sqlserver.plan.worker_time",
	},
	SqlserverSecurityPrincipalsCount: metricInfo{
		Name: "sqlserver.security.principals.count",
	},
	SqlserverSecurityRoleMembersCount: metricInfo{
		Name: "sqlserver.security.role_members.count",
	},
	SqlserverSlowqueryCPUTime: metricInfo{
		Name: "sqlserver.slowquery.cpu_time",
	},
	SqlserverSlowqueryDegreeOfParallelism: metricInfo{
		Name: "sqlserver.slowquery.degree_of_parallelism",
	},
	SqlserverSlowqueryDiskReads: metricInfo{
		Name: "sqlserver.slowquery.disk_reads",
	},
	SqlserverSlowqueryDiskWrites: metricInfo{
		Name: "sqlserver.slowquery.disk_writes",
	},
	SqlserverSlowqueryElapsedTimeHistorical: metricInfo{
		Name: "sqlserver.slowquery.elapsed_time.historical",
	},
	SqlserverSlowqueryElapsedTimeInterval: metricInfo{
		Name: "sqlserver.slowquery.elapsed_time.interval",
	},
	SqlserverSlowqueryExecutionCountHistorical: metricInfo{
		Name: "sqlserver.slowquery.execution_count.historical",
	},
	SqlserverSlowqueryExecutionCountInterval: metricInfo{
		Name: "sqlserver.slowquery.execution_count.interval",
	},
	SqlserverSlowqueryMemoryGrant: metricInfo{
		Name: "sqlserver.slowquery.memory_grant",
	},
	SqlserverSlowqueryRowsProcessed: metricInfo{
		Name: "sqlserver.slowquery.rows_processed",
	},
	SqlserverSlowqueryTempdbSpills: metricInfo{
		Name: "sqlserver.slowquery.tempdb_spills",
	},
	SqlserverTempdbAllocationWaits: metricInfo{
		Name: "sqlserver.tempdb.allocation_waits",
	},
	SqlserverTempdbCurrentWaiters: metricInfo{
		Name: "sqlserver.tempdb.current_waiters",
	},
	SqlserverTempdbDataFileCount: metricInfo{
		Name: "sqlserver.tempdb.data_file_count",
	},
	SqlserverTempdbPagelatchWaits: metricInfo{
		Name: "sqlserver.tempdb.pagelatch_waits",
	},
	SqlserverTempdbTotalSize: metricInfo{
		Name: "sqlserver.tempdb.total_size",
	},
	SqlserverThreadpoolCurrentTasks: metricInfo{
		Name: "sqlserver.threadpool.current_tasks",
	},
	SqlserverThreadpoolMaxWorkers: metricInfo{
		Name: "sqlserver.threadpool.max_workers",
	},
	SqlserverThreadpoolRunnableTasks: metricInfo{
		Name: "sqlserver.threadpool.runnable_tasks",
	},
	SqlserverThreadpoolRunningWorkers: metricInfo{
		Name: "sqlserver.threadpool.running_workers",
	},
	SqlserverThreadpoolUtilization: metricInfo{
		Name: "sqlserver.threadpool.utilization",
	},
	SqlserverThreadpoolWaitingTasks: metricInfo{
		Name: "sqlserver.threadpool.waiting_tasks",
	},
	SqlserverThreadpoolWorkQueueCount: metricInfo{
		Name: "sqlserver.threadpool.work_queue_count",
	},
	SqlserverUserConnectionsAuthenticationFailed: metricInfo{
		Name: "sqlserver.user_connections.authentication.failed",
	},
	SqlserverUserConnectionsAuthenticationLoginsPerSec: metricInfo{
		Name: "sqlserver.user_connections.authentication.logins_per_sec",
	},
	SqlserverUserConnectionsAuthenticationLogoutsPerSec: metricInfo{
		Name: "sqlserver.user_connections.authentication.logouts_per_sec",
	},
	SqlserverUserConnectionsByStatus: metricInfo{
		Name: "sqlserver.user_connections.by_status",
	},
	SqlserverUserConnectionsTotal: metricInfo{
		Name: "sqlserver.user_connections.total",
	},
	SqlserverUserConnectionsUtilizationActiveRatio: metricInfo{
		Name: "sqlserver.user_connections.utilization.active_ratio",
	},
	SqlserverUserConnectionsUtilizationEfficiency: metricInfo{
		Name: "sqlserver.user_connections.utilization.efficiency",
	},
	SqlserverWaitStatsLatchWaitTime: metricInfo{
		Name: "sqlserver.wait_stats.latch.wait_time",
	},
	SqlserverWaitStatsLatchWaitingTasksCount: metricInfo{
		Name: "sqlserver.wait_stats.latch.waiting_tasks_count",
	},
	SqlserverWaitStatsWaitTime: metricInfo{
		Name: "sqlserver.wait_stats.wait_time",
	},
	SqlserverWaitStatsWaitingTasksCount: metricInfo{
		Name: "sqlserver.wait_stats.waiting_tasks_count",
	},
}

type metricsInfo struct {
	SqlserverActivequeryCPUTime                         metricInfo
	SqlserverActivequeryElapsedTime                     metricInfo
	SqlserverActivequeryGrantedMemory                   metricInfo
	SqlserverActivequeryLogicalReads                    metricInfo
	SqlserverActivequeryReads                           metricInfo
	SqlserverActivequeryRowCount                        metricInfo
	SqlserverActivequeryWaitTime                        metricInfo
	SqlserverActivequeryWrites                          metricInfo
	SqlserverDatabaseBufferpoolSize                     metricInfo
	SqlserverDatabaseDiskMaxSize                        metricInfo
	SqlserverDatabaseIoStallTime                        metricInfo
	SqlserverDatabaseLogTransactionGrowth               metricInfo
	SqlserverDatabasePagefileAvailable                  metricInfo
	SqlserverDatabasePagefileTotal                      metricInfo
	SqlserverDatabasePrincipalsCount                    metricInfo
	SqlserverDatabaseRoleMembersUnique                  metricInfo
	SqlserverDatabaseRoleMembershipsActive              metricInfo
	SqlserverDatabaseRoleMembershipsTotal               metricInfo
	SqlserverDatabaseRoleNestingLevel                   metricInfo
	SqlserverDatabaseRolePermissionsInherited           metricInfo
	SqlserverFailoverClusterFailureConditionLevel       metricInfo
	SqlserverFailoverClusterHealthCheckTimeout          metricInfo
	SqlserverFailoverClusterReplicaRole                 metricInfo
	SqlserverFailoverClusterSynchronizationHealth       metricInfo
	SqlserverInstanceActiveConnections                  metricInfo
	SqlserverInstanceBufferPoolHitPercent               metricInfo
	SqlserverInstanceBufferPoolSize                     metricInfo
	SqlserverInstanceDiskMetrics                        metricInfo
	SqlserverInstanceMemoryAvailable                    metricInfo
	SqlserverInstanceMemoryTotal                        metricInfo
	SqlserverInstanceMemoryUtilization                  metricInfo
	SqlserverInstanceProcessCounts                      metricInfo
	SqlserverInstanceRunnableTasks                      metricInfo
	SqlserverLockModeBulkUpdate                         metricInfo
	SqlserverLockModeExclusive                          metricInfo
	SqlserverLockModeIntent                             metricInfo
	SqlserverLockModeSchema                             metricInfo
	SqlserverLockModeShared                             metricInfo
	SqlserverLockModeSharedIntentExclusive              metricInfo
	SqlserverLockModeTotal                              metricInfo
	SqlserverLockModeUpdate                             metricInfo
	SqlserverLockResourceAllocationUnit                 metricInfo
	SqlserverLockResourceApplication                    metricInfo
	SqlserverLockResourceDatabase                       metricInfo
	SqlserverLockResourceExtent                         metricInfo
	SqlserverLockResourceFile                           metricInfo
	SqlserverLockResourceHobt                           metricInfo
	SqlserverLockResourceKey                            metricInfo
	SqlserverLockResourceMetadata                       metricInfo
	SqlserverLockResourcePage                           metricInfo
	SqlserverLockResourceRow                            metricInfo
	SqlserverLockResourceTable                          metricInfo
	SqlserverLockResourceTotal                          metricInfo
	SqlserverLockedObject                               metricInfo
	SqlserverPlanElapsedTimeAvg                         metricInfo
	SqlserverPlanElapsedTimeTotal                       metricInfo
	SqlserverPlanExecutionCount                         metricInfo
	SqlserverPlanLogicalReads                           metricInfo
	SqlserverPlanLogicalWrites                          metricInfo
	SqlserverPlanWorkerTime                             metricInfo
	SqlserverSecurityPrincipalsCount                    metricInfo
	SqlserverSecurityRoleMembersCount                   metricInfo
	SqlserverSlowqueryCPUTime                           metricInfo
	SqlserverSlowqueryDegreeOfParallelism               metricInfo
	SqlserverSlowqueryDiskReads                         metricInfo
	SqlserverSlowqueryDiskWrites                        metricInfo
	SqlserverSlowqueryElapsedTimeHistorical             metricInfo
	SqlserverSlowqueryElapsedTimeInterval               metricInfo
	SqlserverSlowqueryExecutionCountHistorical          metricInfo
	SqlserverSlowqueryExecutionCountInterval            metricInfo
	SqlserverSlowqueryMemoryGrant                       metricInfo
	SqlserverSlowqueryRowsProcessed                     metricInfo
	SqlserverSlowqueryTempdbSpills                      metricInfo
	SqlserverTempdbAllocationWaits                      metricInfo
	SqlserverTempdbCurrentWaiters                       metricInfo
	SqlserverTempdbDataFileCount                        metricInfo
	SqlserverTempdbPagelatchWaits                       metricInfo
	SqlserverTempdbTotalSize                            metricInfo
	SqlserverThreadpoolCurrentTasks                     metricInfo
	SqlserverThreadpoolMaxWorkers                       metricInfo
	SqlserverThreadpoolRunnableTasks                    metricInfo
	SqlserverThreadpoolRunningWorkers                   metricInfo
	SqlserverThreadpoolUtilization                      metricInfo
	SqlserverThreadpoolWaitingTasks                     metricInfo
	SqlserverThreadpoolWorkQueueCount                   metricInfo
	SqlserverUserConnectionsAuthenticationFailed        metricInfo
	SqlserverUserConnectionsAuthenticationLoginsPerSec  metricInfo
	SqlserverUserConnectionsAuthenticationLogoutsPerSec metricInfo
	SqlserverUserConnectionsByStatus                    metricInfo
	SqlserverUserConnectionsTotal                       metricInfo
	SqlserverUserConnectionsUtilizationActiveRatio      metricInfo
	SqlserverUserConnectionsUtilizationEfficiency       metricInfo
	SqlserverWaitStatsLatchWaitTime                     metricInfo
	SqlserverWaitStatsLatchWaitingTasksCount            metricInfo
	SqlserverWaitStatsWaitTime                          metricInfo
	SqlserverWaitStatsWaitingTasksCount                 metricInfo
}

type metricInfo struct {
	Name string
}

type metricSqlserverActivequeryCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.cpu_time metric with initial data.
func (m *metricSqlserverActivequeryCPUTime) init() {
	m.data.SetName("sqlserver.activequery.cpu_time")
	m.data.SetDescription("CPU time consumed by active query")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverActivequeryCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryCPUTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryCPUTime(cfg MetricConfig) metricSqlserverActivequeryCPUTime {
	m := metricSqlserverActivequeryCPUTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryElapsedTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.elapsed_time metric with initial data.
func (m *metricSqlserverActivequeryElapsedTime) init() {
	m.data.SetName("sqlserver.activequery.elapsed_time")
	m.data.SetDescription("Total elapsed time for active query")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverActivequeryElapsedTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryElapsedTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryElapsedTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryElapsedTime(cfg MetricConfig) metricSqlserverActivequeryElapsedTime {
	m := metricSqlserverActivequeryElapsedTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryGrantedMemory struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.granted_memory metric with initial data.
func (m *metricSqlserverActivequeryGrantedMemory) init() {
	m.data.SetName("sqlserver.activequery.granted_memory")
	m.data.SetDescription("Granted query memory in pages")
	m.data.SetUnit("{pages}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverActivequeryGrantedMemory) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryGrantedMemory) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryGrantedMemory) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryGrantedMemory(cfg MetricConfig) metricSqlserverActivequeryGrantedMemory {
	m := metricSqlserverActivequeryGrantedMemory{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryLogicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.logical_reads metric with initial data.
func (m *metricSqlserverActivequeryLogicalReads) init() {
	m.data.SetName("sqlserver.activequery.logical_reads")
	m.data.SetDescription("Logical reads by active query")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverActivequeryLogicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryLogicalReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryLogicalReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryLogicalReads(cfg MetricConfig) metricSqlserverActivequeryLogicalReads {
	m := metricSqlserverActivequeryLogicalReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.reads metric with initial data.
func (m *metricSqlserverActivequeryReads) init() {
	m.data.SetName("sqlserver.activequery.reads")
	m.data.SetDescription("Physical reads by active query")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverActivequeryReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryReads(cfg MetricConfig) metricSqlserverActivequeryReads {
	m := metricSqlserverActivequeryReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryRowCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.row_count metric with initial data.
func (m *metricSqlserverActivequeryRowCount) init() {
	m.data.SetName("sqlserver.activequery.row_count")
	m.data.SetDescription("Rows returned by active query")
	m.data.SetUnit("{rows}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverActivequeryRowCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryRowCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryRowCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryRowCount(cfg MetricConfig) metricSqlserverActivequeryRowCount {
	m := metricSqlserverActivequeryRowCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryWaitTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.wait_time metric with initial data.
func (m *metricSqlserverActivequeryWaitTime) init() {
	m.data.SetName("sqlserver.activequery.wait_time")
	m.data.SetDescription("Current wait time for active query")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverActivequeryWaitTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryWaitTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryWaitTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryWaitTime(cfg MetricConfig) metricSqlserverActivequeryWaitTime {
	m := metricSqlserverActivequeryWaitTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryWrites struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.writes metric with initial data.
func (m *metricSqlserverActivequeryWrites) init() {
	m.data.SetName("sqlserver.activequery.writes")
	m.data.SetDescription("Writes by active query")
	m.data.SetUnit("{writes}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverActivequeryWrites) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryWrites) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryWrites) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryWrites(cfg MetricConfig) metricSqlserverActivequeryWrites {
	m := metricSqlserverActivequeryWrites{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseBufferpoolSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.bufferpool.size metric with initial data.
func (m *metricSqlserverDatabaseBufferpoolSize) init() {
	m.data.SetName("sqlserver.database.bufferpool.size")
	m.data.SetDescription("Size of buffer pool allocated per database")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseBufferpoolSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, dbNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("db_name", dbNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseBufferpoolSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseBufferpoolSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseBufferpoolSize(cfg MetricConfig) metricSqlserverDatabaseBufferpoolSize {
	m := metricSqlserverDatabaseBufferpoolSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseDiskMaxSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.disk.max_size metric with initial data.
func (m *metricSqlserverDatabaseDiskMaxSize) init() {
	m.data.SetName("sqlserver.database.disk.max_size")
	m.data.SetDescription("Maximum disk size for database (Azure SQL Database)")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverDatabaseDiskMaxSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseDiskMaxSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseDiskMaxSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseDiskMaxSize(cfg MetricConfig) metricSqlserverDatabaseDiskMaxSize {
	m := metricSqlserverDatabaseDiskMaxSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseIoStallTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.io.stall_time metric with initial data.
func (m *metricSqlserverDatabaseIoStallTime) init() {
	m.data.SetName("sqlserver.database.io.stall_time")
	m.data.SetDescription("I/O stall time in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverDatabaseIoStallTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseIoStallTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseIoStallTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseIoStallTime(cfg MetricConfig) metricSqlserverDatabaseIoStallTime {
	m := metricSqlserverDatabaseIoStallTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseLogTransactionGrowth struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.log.transaction_growth metric with initial data.
func (m *metricSqlserverDatabaseLogTransactionGrowth) init() {
	m.data.SetName("sqlserver.database.log.transaction_growth")
	m.data.SetDescription("Transaction log growth count")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverDatabaseLogTransactionGrowth) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseLogTransactionGrowth) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseLogTransactionGrowth) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseLogTransactionGrowth(cfg MetricConfig) metricSqlserverDatabaseLogTransactionGrowth {
	m := metricSqlserverDatabaseLogTransactionGrowth{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePagefileAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.pagefile.available metric with initial data.
func (m *metricSqlserverDatabasePagefileAvailable) init() {
	m.data.SetName("sqlserver.database.pagefile.available")
	m.data.SetDescription("Available page file space")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverDatabasePagefileAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePagefileAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePagefileAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePagefileAvailable(cfg MetricConfig) metricSqlserverDatabasePagefileAvailable {
	m := metricSqlserverDatabasePagefileAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePagefileTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.pagefile.total metric with initial data.
func (m *metricSqlserverDatabasePagefileTotal) init() {
	m.data.SetName("sqlserver.database.pagefile.total")
	m.data.SetDescription("Total page file space")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverDatabasePagefileTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePagefileTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePagefileTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePagefileTotal(cfg MetricConfig) metricSqlserverDatabasePagefileTotal {
	m := metricSqlserverDatabasePagefileTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.count metric with initial data.
func (m *metricSqlserverDatabasePrincipalsCount) init() {
	m.data.SetName("sqlserver.database.principals.count")
	m.data.SetDescription("Number of database principals")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverDatabasePrincipalsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsCount(cfg MetricConfig) metricSqlserverDatabasePrincipalsCount {
	m := metricSqlserverDatabasePrincipalsCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembersUnique struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.members.unique metric with initial data.
func (m *metricSqlserverDatabaseRoleMembersUnique) init() {
	m.data.SetName("sqlserver.database.role.members.unique")
	m.data.SetDescription("Unique role members")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverDatabaseRoleMembersUnique) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembersUnique) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembersUnique) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembersUnique(cfg MetricConfig) metricSqlserverDatabaseRoleMembersUnique {
	m := metricSqlserverDatabaseRoleMembersUnique{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembershipsActive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.memberships.active metric with initial data.
func (m *metricSqlserverDatabaseRoleMembershipsActive) init() {
	m.data.SetName("sqlserver.database.role.memberships.active")
	m.data.SetDescription("Active role memberships")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverDatabaseRoleMembershipsActive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembershipsActive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembershipsActive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembershipsActive(cfg MetricConfig) metricSqlserverDatabaseRoleMembershipsActive {
	m := metricSqlserverDatabaseRoleMembershipsActive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembershipsTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.memberships.total metric with initial data.
func (m *metricSqlserverDatabaseRoleMembershipsTotal) init() {
	m.data.SetName("sqlserver.database.role.memberships.total")
	m.data.SetDescription("Total role memberships")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverDatabaseRoleMembershipsTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembershipsTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembershipsTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembershipsTotal(cfg MetricConfig) metricSqlserverDatabaseRoleMembershipsTotal {
	m := metricSqlserverDatabaseRoleMembershipsTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleNestingLevel struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.nesting_level metric with initial data.
func (m *metricSqlserverDatabaseRoleNestingLevel) init() {
	m.data.SetName("sqlserver.database.role.nesting_level")
	m.data.SetDescription("Role nesting depth")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverDatabaseRoleNestingLevel) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleNestingLevel) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleNestingLevel) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleNestingLevel(cfg MetricConfig) metricSqlserverDatabaseRoleNestingLevel {
	m := metricSqlserverDatabaseRoleNestingLevel{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRolePermissionsInherited struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.permissions.inherited metric with initial data.
func (m *metricSqlserverDatabaseRolePermissionsInherited) init() {
	m.data.SetName("sqlserver.database.role.permissions.inherited")
	m.data.SetDescription("Inherited permissions count")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverDatabaseRolePermissionsInherited) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRolePermissionsInherited) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRolePermissionsInherited) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRolePermissionsInherited(cfg MetricConfig) metricSqlserverDatabaseRolePermissionsInherited {
	m := metricSqlserverDatabaseRolePermissionsInherited{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterFailureConditionLevel struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.failure_condition_level metric with initial data.
func (m *metricSqlserverFailoverClusterFailureConditionLevel) init() {
	m.data.SetName("sqlserver.failover_cluster.failure_condition_level")
	m.data.SetDescription("AG failure condition level setting")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverFailoverClusterFailureConditionLevel) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterFailureConditionLevel) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterFailureConditionLevel) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterFailureConditionLevel(cfg MetricConfig) metricSqlserverFailoverClusterFailureConditionLevel {
	m := metricSqlserverFailoverClusterFailureConditionLevel{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterHealthCheckTimeout struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.health_check_timeout metric with initial data.
func (m *metricSqlserverFailoverClusterHealthCheckTimeout) init() {
	m.data.SetName("sqlserver.failover_cluster.health_check_timeout")
	m.data.SetDescription("AG health check timeout")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverFailoverClusterHealthCheckTimeout) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterHealthCheckTimeout) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterHealthCheckTimeout) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterHealthCheckTimeout(cfg MetricConfig) metricSqlserverFailoverClusterHealthCheckTimeout {
	m := metricSqlserverFailoverClusterHealthCheckTimeout{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterReplicaRole struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.replica_role metric with initial data.
func (m *metricSqlserverFailoverClusterReplicaRole) init() {
	m.data.SetName("sqlserver.failover_cluster.replica_role")
	m.data.SetDescription("Availability Group replica role indicator")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterReplicaRole) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, replicaIDAttributeValue string, roleAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("replica_id", replicaIDAttributeValue)
	dp.Attributes().PutStr("role", roleAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterReplicaRole) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterReplicaRole) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterReplicaRole(cfg MetricConfig) metricSqlserverFailoverClusterReplicaRole {
	m := metricSqlserverFailoverClusterReplicaRole{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterSynchronizationHealth struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.synchronization_health metric with initial data.
func (m *metricSqlserverFailoverClusterSynchronizationHealth) init() {
	m.data.SetName("sqlserver.failover_cluster.synchronization_health")
	m.data.SetDescription("AG synchronization health status")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterSynchronizationHealth) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, replicaIDAttributeValue string, synchronizationHealthAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("replica_id", replicaIDAttributeValue)
	dp.Attributes().PutStr("synchronization_health", synchronizationHealthAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterSynchronizationHealth) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterSynchronizationHealth) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterSynchronizationHealth(cfg MetricConfig) metricSqlserverFailoverClusterSynchronizationHealth {
	m := metricSqlserverFailoverClusterSynchronizationHealth{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceActiveConnections struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.active_connections metric with initial data.
func (m *metricSqlserverInstanceActiveConnections) init() {
	m.data.SetName("sqlserver.instance.active_connections")
	m.data.SetDescription("Number of active connections")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceActiveConnections) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceActiveConnections) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceActiveConnections) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceActiveConnections(cfg MetricConfig) metricSqlserverInstanceActiveConnections {
	m := metricSqlserverInstanceActiveConnections{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceBufferPoolHitPercent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.buffer_pool.hit_percent metric with initial data.
func (m *metricSqlserverInstanceBufferPoolHitPercent) init() {
	m.data.SetName("sqlserver.instance.buffer_pool.hit_percent")
	m.data.SetDescription("Buffer pool cache hit ratio percentage")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceBufferPoolHitPercent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceBufferPoolHitPercent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceBufferPoolHitPercent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceBufferPoolHitPercent(cfg MetricConfig) metricSqlserverInstanceBufferPoolHitPercent {
	m := metricSqlserverInstanceBufferPoolHitPercent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceBufferPoolSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.buffer_pool.size metric with initial data.
func (m *metricSqlserverInstanceBufferPoolSize) init() {
	m.data.SetName("sqlserver.instance.buffer_pool.size")
	m.data.SetDescription("Buffer pool size in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceBufferPoolSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceBufferPoolSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceBufferPoolSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceBufferPoolSize(cfg MetricConfig) metricSqlserverInstanceBufferPoolSize {
	m := metricSqlserverInstanceBufferPoolSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceDiskMetrics struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.disk_metrics metric with initial data.
func (m *metricSqlserverInstanceDiskMetrics) init() {
	m.data.SetName("sqlserver.instance.disk_metrics")
	m.data.SetDescription("Instance-level disk I/O metrics")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceDiskMetrics) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceDiskMetrics) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceDiskMetrics) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceDiskMetrics(cfg MetricConfig) metricSqlserverInstanceDiskMetrics {
	m := metricSqlserverInstanceDiskMetrics{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.memory.available metric with initial data.
func (m *metricSqlserverInstanceMemoryAvailable) init() {
	m.data.SetName("sqlserver.instance.memory.available")
	m.data.SetDescription("Available physical memory")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceMemoryAvailable(cfg MetricConfig) metricSqlserverInstanceMemoryAvailable {
	m := metricSqlserverInstanceMemoryAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceMemoryTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.memory.total metric with initial data.
func (m *metricSqlserverInstanceMemoryTotal) init() {
	m.data.SetName("sqlserver.instance.memory.total")
	m.data.SetDescription("Total physical memory available to SQL Server")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceMemoryTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceMemoryTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceMemoryTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceMemoryTotal(cfg MetricConfig) metricSqlserverInstanceMemoryTotal {
	m := metricSqlserverInstanceMemoryTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceMemoryUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.memory.utilization metric with initial data.
func (m *metricSqlserverInstanceMemoryUtilization) init() {
	m.data.SetName("sqlserver.instance.memory.utilization")
	m.data.SetDescription("Memory utilization percentage")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceMemoryUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceMemoryUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceMemoryUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceMemoryUtilization(cfg MetricConfig) metricSqlserverInstanceMemoryUtilization {
	m := metricSqlserverInstanceMemoryUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceProcessCounts struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.process_counts metric with initial data.
func (m *metricSqlserverInstanceProcessCounts) init() {
	m.data.SetName("sqlserver.instance.process_counts")
	m.data.SetDescription("Number of processes/connections")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceProcessCounts) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceProcessCounts) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceProcessCounts) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceProcessCounts(cfg MetricConfig) metricSqlserverInstanceProcessCounts {
	m := metricSqlserverInstanceProcessCounts{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceRunnableTasks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.runnable_tasks metric with initial data.
func (m *metricSqlserverInstanceRunnableTasks) init() {
	m.data.SetName("sqlserver.instance.runnable_tasks")
	m.data.SetDescription("Number of runnable tasks waiting for CPU")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceRunnableTasks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceRunnableTasks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceRunnableTasks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceRunnableTasks(cfg MetricConfig) metricSqlserverInstanceRunnableTasks {
	m := metricSqlserverInstanceRunnableTasks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeBulkUpdate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.bulk_update metric with initial data.
func (m *metricSqlserverLockModeBulkUpdate) init() {
	m.data.SetName("sqlserver.lock.mode.bulk_update")
	m.data.SetDescription("Number of bulk update locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockModeBulkUpdate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeBulkUpdate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeBulkUpdate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeBulkUpdate(cfg MetricConfig) metricSqlserverLockModeBulkUpdate {
	m := metricSqlserverLockModeBulkUpdate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeExclusive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.exclusive metric with initial data.
func (m *metricSqlserverLockModeExclusive) init() {
	m.data.SetName("sqlserver.lock.mode.exclusive")
	m.data.SetDescription("Number of exclusive locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockModeExclusive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeExclusive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeExclusive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeExclusive(cfg MetricConfig) metricSqlserverLockModeExclusive {
	m := metricSqlserverLockModeExclusive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeIntent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.intent metric with initial data.
func (m *metricSqlserverLockModeIntent) init() {
	m.data.SetName("sqlserver.lock.mode.intent")
	m.data.SetDescription("Number of intent locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockModeIntent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeIntent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeIntent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeIntent(cfg MetricConfig) metricSqlserverLockModeIntent {
	m := metricSqlserverLockModeIntent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeSchema struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.schema metric with initial data.
func (m *metricSqlserverLockModeSchema) init() {
	m.data.SetName("sqlserver.lock.mode.schema")
	m.data.SetDescription("Number of schema locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockModeSchema) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeSchema) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeSchema) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeSchema(cfg MetricConfig) metricSqlserverLockModeSchema {
	m := metricSqlserverLockModeSchema{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeShared struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.shared metric with initial data.
func (m *metricSqlserverLockModeShared) init() {
	m.data.SetName("sqlserver.lock.mode.shared")
	m.data.SetDescription("Number of shared locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockModeShared) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeShared) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeShared) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeShared(cfg MetricConfig) metricSqlserverLockModeShared {
	m := metricSqlserverLockModeShared{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeSharedIntentExclusive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.shared_intent_exclusive metric with initial data.
func (m *metricSqlserverLockModeSharedIntentExclusive) init() {
	m.data.SetName("sqlserver.lock.mode.shared_intent_exclusive")
	m.data.SetDescription("Number of shared intent exclusive locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockModeSharedIntentExclusive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeSharedIntentExclusive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeSharedIntentExclusive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeSharedIntentExclusive(cfg MetricConfig) metricSqlserverLockModeSharedIntentExclusive {
	m := metricSqlserverLockModeSharedIntentExclusive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.total metric with initial data.
func (m *metricSqlserverLockModeTotal) init() {
	m.data.SetName("sqlserver.lock.mode.total")
	m.data.SetDescription("Total active locks by mode")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockModeTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeTotal(cfg MetricConfig) metricSqlserverLockModeTotal {
	m := metricSqlserverLockModeTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeUpdate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.update metric with initial data.
func (m *metricSqlserverLockModeUpdate) init() {
	m.data.SetName("sqlserver.lock.mode.update")
	m.data.SetDescription("Number of update locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockModeUpdate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeUpdate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeUpdate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeUpdate(cfg MetricConfig) metricSqlserverLockModeUpdate {
	m := metricSqlserverLockModeUpdate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceAllocationUnit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.allocation_unit metric with initial data.
func (m *metricSqlserverLockResourceAllocationUnit) init() {
	m.data.SetName("sqlserver.lock.resource.allocation_unit")
	m.data.SetDescription("Number of allocation unit locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockResourceAllocationUnit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceAllocationUnit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceAllocationUnit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceAllocationUnit(cfg MetricConfig) metricSqlserverLockResourceAllocationUnit {
	m := metricSqlserverLockResourceAllocationUnit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceApplication struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.application metric with initial data.
func (m *metricSqlserverLockResourceApplication) init() {
	m.data.SetName("sqlserver.lock.resource.application")
	m.data.SetDescription("Number of application locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockResourceApplication) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceApplication) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceApplication) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceApplication(cfg MetricConfig) metricSqlserverLockResourceApplication {
	m := metricSqlserverLockResourceApplication{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceDatabase struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.database metric with initial data.
func (m *metricSqlserverLockResourceDatabase) init() {
	m.data.SetName("sqlserver.lock.resource.database")
	m.data.SetDescription("Number of database-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockResourceDatabase) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceDatabase) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceDatabase) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceDatabase(cfg MetricConfig) metricSqlserverLockResourceDatabase {
	m := metricSqlserverLockResourceDatabase{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceExtent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.extent metric with initial data.
func (m *metricSqlserverLockResourceExtent) init() {
	m.data.SetName("sqlserver.lock.resource.extent")
	m.data.SetDescription("Number of extent-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockResourceExtent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceExtent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceExtent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceExtent(cfg MetricConfig) metricSqlserverLockResourceExtent {
	m := metricSqlserverLockResourceExtent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceFile struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.file metric with initial data.
func (m *metricSqlserverLockResourceFile) init() {
	m.data.SetName("sqlserver.lock.resource.file")
	m.data.SetDescription("Number of file-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockResourceFile) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceFile) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceFile) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceFile(cfg MetricConfig) metricSqlserverLockResourceFile {
	m := metricSqlserverLockResourceFile{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceHobt struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.hobt metric with initial data.
func (m *metricSqlserverLockResourceHobt) init() {
	m.data.SetName("sqlserver.lock.resource.hobt")
	m.data.SetDescription("Number of heap or B-tree locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockResourceHobt) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceHobt) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceHobt) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceHobt(cfg MetricConfig) metricSqlserverLockResourceHobt {
	m := metricSqlserverLockResourceHobt{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceKey struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.key metric with initial data.
func (m *metricSqlserverLockResourceKey) init() {
	m.data.SetName("sqlserver.lock.resource.key")
	m.data.SetDescription("Number of key-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockResourceKey) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceKey) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceKey) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceKey(cfg MetricConfig) metricSqlserverLockResourceKey {
	m := metricSqlserverLockResourceKey{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceMetadata struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.metadata metric with initial data.
func (m *metricSqlserverLockResourceMetadata) init() {
	m.data.SetName("sqlserver.lock.resource.metadata")
	m.data.SetDescription("Number of metadata locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockResourceMetadata) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceMetadata) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceMetadata) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceMetadata(cfg MetricConfig) metricSqlserverLockResourceMetadata {
	m := metricSqlserverLockResourceMetadata{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourcePage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.page metric with initial data.
func (m *metricSqlserverLockResourcePage) init() {
	m.data.SetName("sqlserver.lock.resource.page")
	m.data.SetDescription("Number of page-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockResourcePage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourcePage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourcePage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourcePage(cfg MetricConfig) metricSqlserverLockResourcePage {
	m := metricSqlserverLockResourcePage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceRow struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.row metric with initial data.
func (m *metricSqlserverLockResourceRow) init() {
	m.data.SetName("sqlserver.lock.resource.row")
	m.data.SetDescription("Number of row-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockResourceRow) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceRow) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceRow) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceRow(cfg MetricConfig) metricSqlserverLockResourceRow {
	m := metricSqlserverLockResourceRow{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceTable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.table metric with initial data.
func (m *metricSqlserverLockResourceTable) init() {
	m.data.SetName("sqlserver.lock.resource.table")
	m.data.SetDescription("Number of table-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockResourceTable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceTable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceTable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceTable(cfg MetricConfig) metricSqlserverLockResourceTable {
	m := metricSqlserverLockResourceTable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.total metric with initial data.
func (m *metricSqlserverLockResourceTotal) init() {
	m.data.SetName("sqlserver.lock.resource.total")
	m.data.SetDescription("Total active locks in the database")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockResourceTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceTotal(cfg MetricConfig) metricSqlserverLockResourceTotal {
	m := metricSqlserverLockResourceTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockedObject struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.locked_object metric with initial data.
func (m *metricSqlserverLockedObject) init() {
	m.data.SetName("sqlserver.locked_object")
	m.data.SetDescription("Information about locked database objects")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockedObject) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockedObject) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockedObject) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockedObject(cfg MetricConfig) metricSqlserverLockedObject {
	m := metricSqlserverLockedObject{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanElapsedTimeAvg struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.elapsed_time.avg metric with initial data.
func (m *metricSqlserverPlanElapsedTimeAvg) init() {
	m.data.SetName("sqlserver.plan.elapsed_time.avg")
	m.data.SetDescription("Average elapsed time for plan")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverPlanElapsedTimeAvg) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanElapsedTimeAvg) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanElapsedTimeAvg) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanElapsedTimeAvg(cfg MetricConfig) metricSqlserverPlanElapsedTimeAvg {
	m := metricSqlserverPlanElapsedTimeAvg{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanElapsedTimeTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.elapsed_time.total metric with initial data.
func (m *metricSqlserverPlanElapsedTimeTotal) init() {
	m.data.SetName("sqlserver.plan.elapsed_time.total")
	m.data.SetDescription("Total elapsed time for all executions")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverPlanElapsedTimeTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanElapsedTimeTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanElapsedTimeTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanElapsedTimeTotal(cfg MetricConfig) metricSqlserverPlanElapsedTimeTotal {
	m := metricSqlserverPlanElapsedTimeTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanExecutionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.execution_count metric with initial data.
func (m *metricSqlserverPlanExecutionCount) init() {
	m.data.SetName("sqlserver.plan.execution_count")
	m.data.SetDescription("Number of times execution plan was executed")
	m.data.SetUnit("{executions}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverPlanExecutionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanExecutionCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanExecutionCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanExecutionCount(cfg MetricConfig) metricSqlserverPlanExecutionCount {
	m := metricSqlserverPlanExecutionCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanLogicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.logical_reads metric with initial data.
func (m *metricSqlserverPlanLogicalReads) init() {
	m.data.SetName("sqlserver.plan.logical_reads")
	m.data.SetDescription("Average logical page reads")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverPlanLogicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanLogicalReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanLogicalReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanLogicalReads(cfg MetricConfig) metricSqlserverPlanLogicalReads {
	m := metricSqlserverPlanLogicalReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanLogicalWrites struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.logical_writes metric with initial data.
func (m *metricSqlserverPlanLogicalWrites) init() {
	m.data.SetName("sqlserver.plan.logical_writes")
	m.data.SetDescription("Average logical page writes")
	m.data.SetUnit("{writes}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverPlanLogicalWrites) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanLogicalWrites) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanLogicalWrites) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanLogicalWrites(cfg MetricConfig) metricSqlserverPlanLogicalWrites {
	m := metricSqlserverPlanLogicalWrites{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanWorkerTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.worker_time metric with initial data.
func (m *metricSqlserverPlanWorkerTime) init() {
	m.data.SetName("sqlserver.plan.worker_time")
	m.data.SetDescription("Average CPU worker time")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverPlanWorkerTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanWorkerTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanWorkerTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanWorkerTime(cfg MetricConfig) metricSqlserverPlanWorkerTime {
	m := metricSqlserverPlanWorkerTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSecurityPrincipalsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.security.principals.count metric with initial data.
func (m *metricSqlserverSecurityPrincipalsCount) init() {
	m.data.SetName("sqlserver.security.principals.count")
	m.data.SetDescription("Server-level principals count")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverSecurityPrincipalsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSecurityPrincipalsCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSecurityPrincipalsCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSecurityPrincipalsCount(cfg MetricConfig) metricSqlserverSecurityPrincipalsCount {
	m := metricSqlserverSecurityPrincipalsCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSecurityRoleMembersCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.security.role_members.count metric with initial data.
func (m *metricSqlserverSecurityRoleMembersCount) init() {
	m.data.SetName("sqlserver.security.role_members.count")
	m.data.SetDescription("Server role members count")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverSecurityRoleMembersCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSecurityRoleMembersCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSecurityRoleMembersCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSecurityRoleMembersCount(cfg MetricConfig) metricSqlserverSecurityRoleMembersCount {
	m := metricSqlserverSecurityRoleMembersCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.cpu_time metric with initial data.
func (m *metricSqlserverSlowqueryCPUTime) init() {
	m.data.SetName("sqlserver.slowquery.cpu_time")
	m.data.SetDescription("Average CPU time for slow query")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverSlowqueryCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryCPUTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryCPUTime(cfg MetricConfig) metricSqlserverSlowqueryCPUTime {
	m := metricSqlserverSlowqueryCPUTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryDegreeOfParallelism struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.degree_of_parallelism metric with initial data.
func (m *metricSqlserverSlowqueryDegreeOfParallelism) init() {
	m.data.SetName("sqlserver.slowquery.degree_of_parallelism")
	m.data.SetDescription("Degree of parallelism (DOP) used")
	m.data.SetUnit("{threads}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverSlowqueryDegreeOfParallelism) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryDegreeOfParallelism) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryDegreeOfParallelism) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryDegreeOfParallelism(cfg MetricConfig) metricSqlserverSlowqueryDegreeOfParallelism {
	m := metricSqlserverSlowqueryDegreeOfParallelism{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryDiskReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.disk_reads metric with initial data.
func (m *metricSqlserverSlowqueryDiskReads) init() {
	m.data.SetName("sqlserver.slowquery.disk_reads")
	m.data.SetDescription("Average physical disk reads")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverSlowqueryDiskReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryDiskReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryDiskReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryDiskReads(cfg MetricConfig) metricSqlserverSlowqueryDiskReads {
	m := metricSqlserverSlowqueryDiskReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryDiskWrites struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.disk_writes metric with initial data.
func (m *metricSqlserverSlowqueryDiskWrites) init() {
	m.data.SetName("sqlserver.slowquery.disk_writes")
	m.data.SetDescription("Average physical disk writes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverSlowqueryDiskWrites) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryDiskWrites) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryDiskWrites) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryDiskWrites(cfg MetricConfig) metricSqlserverSlowqueryDiskWrites {
	m := metricSqlserverSlowqueryDiskWrites{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryElapsedTimeHistorical struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.elapsed_time.historical metric with initial data.
func (m *metricSqlserverSlowqueryElapsedTimeHistorical) init() {
	m.data.SetName("sqlserver.slowquery.elapsed_time.historical")
	m.data.SetDescription("Historical average elapsed time since plan cached")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverSlowqueryElapsedTimeHistorical) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryElapsedTimeHistorical) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryElapsedTimeHistorical) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryElapsedTimeHistorical(cfg MetricConfig) metricSqlserverSlowqueryElapsedTimeHistorical {
	m := metricSqlserverSlowqueryElapsedTimeHistorical{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryElapsedTimeInterval struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.elapsed_time.interval metric with initial data.
func (m *metricSqlserverSlowqueryElapsedTimeInterval) init() {
	m.data.SetName("sqlserver.slowquery.elapsed_time.interval")
	m.data.SetDescription("Interval (delta) average elapsed time")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverSlowqueryElapsedTimeInterval) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryElapsedTimeInterval) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryElapsedTimeInterval) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryElapsedTimeInterval(cfg MetricConfig) metricSqlserverSlowqueryElapsedTimeInterval {
	m := metricSqlserverSlowqueryElapsedTimeInterval{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryExecutionCountHistorical struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.execution_count.historical metric with initial data.
func (m *metricSqlserverSlowqueryExecutionCountHistorical) init() {
	m.data.SetName("sqlserver.slowquery.execution_count.historical")
	m.data.SetDescription("Total execution count since plan cached")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverSlowqueryExecutionCountHistorical) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryExecutionCountHistorical) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryExecutionCountHistorical) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryExecutionCountHistorical(cfg MetricConfig) metricSqlserverSlowqueryExecutionCountHistorical {
	m := metricSqlserverSlowqueryExecutionCountHistorical{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryExecutionCountInterval struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.execution_count.interval metric with initial data.
func (m *metricSqlserverSlowqueryExecutionCountInterval) init() {
	m.data.SetName("sqlserver.slowquery.execution_count.interval")
	m.data.SetDescription("Execution count in collection interval (delta)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverSlowqueryExecutionCountInterval) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryExecutionCountInterval) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryExecutionCountInterval) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryExecutionCountInterval(cfg MetricConfig) metricSqlserverSlowqueryExecutionCountInterval {
	m := metricSqlserverSlowqueryExecutionCountInterval{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryMemoryGrant struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.memory_grant metric with initial data.
func (m *metricSqlserverSlowqueryMemoryGrant) init() {
	m.data.SetName("sqlserver.slowquery.memory_grant")
	m.data.SetDescription("Memory grant for query in KB")
	m.data.SetUnit("KBy")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverSlowqueryMemoryGrant) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryMemoryGrant) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryMemoryGrant) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryMemoryGrant(cfg MetricConfig) metricSqlserverSlowqueryMemoryGrant {
	m := metricSqlserverSlowqueryMemoryGrant{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryRowsProcessed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.rows_processed metric with initial data.
func (m *metricSqlserverSlowqueryRowsProcessed) init() {
	m.data.SetName("sqlserver.slowquery.rows_processed")
	m.data.SetDescription("Average number of rows processed")
	m.data.SetUnit("{rows}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverSlowqueryRowsProcessed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryRowsProcessed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryRowsProcessed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryRowsProcessed(cfg MetricConfig) metricSqlserverSlowqueryRowsProcessed {
	m := metricSqlserverSlowqueryRowsProcessed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryTempdbSpills struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.tempdb_spills metric with initial data.
func (m *metricSqlserverSlowqueryTempdbSpills) init() {
	m.data.SetName("sqlserver.slowquery.tempdb_spills")
	m.data.SetDescription("TempDB spill pages")
	m.data.SetUnit("{pages}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverSlowqueryTempdbSpills) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryTempdbSpills) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryTempdbSpills) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryTempdbSpills(cfg MetricConfig) metricSqlserverSlowqueryTempdbSpills {
	m := metricSqlserverSlowqueryTempdbSpills{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbAllocationWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.allocation_waits metric with initial data.
func (m *metricSqlserverTempdbAllocationWaits) init() {
	m.data.SetName("sqlserver.tempdb.allocation_waits")
	m.data.SetDescription("TempDB allocation contention wait time")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverTempdbAllocationWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbAllocationWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbAllocationWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbAllocationWaits(cfg MetricConfig) metricSqlserverTempdbAllocationWaits {
	m := metricSqlserverTempdbAllocationWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbCurrentWaiters struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.current_waiters metric with initial data.
func (m *metricSqlserverTempdbCurrentWaiters) init() {
	m.data.SetName("sqlserver.tempdb.current_waiters")
	m.data.SetDescription("Current tasks waiting on TempDB resources")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverTempdbCurrentWaiters) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbCurrentWaiters) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbCurrentWaiters) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbCurrentWaiters(cfg MetricConfig) metricSqlserverTempdbCurrentWaiters {
	m := metricSqlserverTempdbCurrentWaiters{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbDataFileCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.data_file_count metric with initial data.
func (m *metricSqlserverTempdbDataFileCount) init() {
	m.data.SetName("sqlserver.tempdb.data_file_count")
	m.data.SetDescription("Number of TempDB data files")
	m.data.SetUnit("{files}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverTempdbDataFileCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbDataFileCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbDataFileCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbDataFileCount(cfg MetricConfig) metricSqlserverTempdbDataFileCount {
	m := metricSqlserverTempdbDataFileCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbPagelatchWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.pagelatch_waits metric with initial data.
func (m *metricSqlserverTempdbPagelatchWaits) init() {
	m.data.SetName("sqlserver.tempdb.pagelatch_waits")
	m.data.SetDescription("TempDB page latch wait time")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverTempdbPagelatchWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbPagelatchWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbPagelatchWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbPagelatchWaits(cfg MetricConfig) metricSqlserverTempdbPagelatchWaits {
	m := metricSqlserverTempdbPagelatchWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbTotalSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.total_size metric with initial data.
func (m *metricSqlserverTempdbTotalSize) init() {
	m.data.SetName("sqlserver.tempdb.total_size")
	m.data.SetDescription("Total TempDB size")
	m.data.SetUnit("MBy")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverTempdbTotalSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbTotalSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbTotalSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbTotalSize(cfg MetricConfig) metricSqlserverTempdbTotalSize {
	m := metricSqlserverTempdbTotalSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolCurrentTasks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.current_tasks metric with initial data.
func (m *metricSqlserverThreadpoolCurrentTasks) init() {
	m.data.SetName("sqlserver.threadpool.current_tasks")
	m.data.SetDescription("Current number of active tasks")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverThreadpoolCurrentTasks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolCurrentTasks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolCurrentTasks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolCurrentTasks(cfg MetricConfig) metricSqlserverThreadpoolCurrentTasks {
	m := metricSqlserverThreadpoolCurrentTasks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolMaxWorkers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.max_workers metric with initial data.
func (m *metricSqlserverThreadpoolMaxWorkers) init() {
	m.data.SetName("sqlserver.threadpool.max_workers")
	m.data.SetDescription("Maximum configured worker threads")
	m.data.SetUnit("{threads}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverThreadpoolMaxWorkers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolMaxWorkers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolMaxWorkers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolMaxWorkers(cfg MetricConfig) metricSqlserverThreadpoolMaxWorkers {
	m := metricSqlserverThreadpoolMaxWorkers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolRunnableTasks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.runnable_tasks metric with initial data.
func (m *metricSqlserverThreadpoolRunnableTasks) init() {
	m.data.SetName("sqlserver.threadpool.runnable_tasks")
	m.data.SetDescription("Runnable tasks waiting for CPU")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverThreadpoolRunnableTasks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolRunnableTasks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolRunnableTasks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolRunnableTasks(cfg MetricConfig) metricSqlserverThreadpoolRunnableTasks {
	m := metricSqlserverThreadpoolRunnableTasks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolRunningWorkers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.running_workers metric with initial data.
func (m *metricSqlserverThreadpoolRunningWorkers) init() {
	m.data.SetName("sqlserver.threadpool.running_workers")
	m.data.SetDescription("Currently executing worker threads")
	m.data.SetUnit("{threads}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverThreadpoolRunningWorkers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolRunningWorkers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolRunningWorkers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolRunningWorkers(cfg MetricConfig) metricSqlserverThreadpoolRunningWorkers {
	m := metricSqlserverThreadpoolRunningWorkers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.utilization metric with initial data.
func (m *metricSqlserverThreadpoolUtilization) init() {
	m.data.SetName("sqlserver.threadpool.utilization")
	m.data.SetDescription("Thread pool utilization percentage")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverThreadpoolUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolUtilization(cfg MetricConfig) metricSqlserverThreadpoolUtilization {
	m := metricSqlserverThreadpoolUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolWaitingTasks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.waiting_tasks metric with initial data.
func (m *metricSqlserverThreadpoolWaitingTasks) init() {
	m.data.SetName("sqlserver.threadpool.waiting_tasks")
	m.data.SetDescription("Tasks waiting for thread pool resources")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverThreadpoolWaitingTasks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolWaitingTasks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolWaitingTasks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolWaitingTasks(cfg MetricConfig) metricSqlserverThreadpoolWaitingTasks {
	m := metricSqlserverThreadpoolWaitingTasks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolWorkQueueCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.work_queue_count metric with initial data.
func (m *metricSqlserverThreadpoolWorkQueueCount) init() {
	m.data.SetName("sqlserver.threadpool.work_queue_count")
	m.data.SetDescription("Work items queued for thread pool")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverThreadpoolWorkQueueCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolWorkQueueCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolWorkQueueCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolWorkQueueCount(cfg MetricConfig) metricSqlserverThreadpoolWorkQueueCount {
	m := metricSqlserverThreadpoolWorkQueueCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationFailed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.failed metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationFailed) init() {
	m.data.SetName("sqlserver.user_connections.authentication.failed")
	m.data.SetDescription("Number of failed authentication attempts")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationFailed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationFailed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationFailed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationFailed(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationFailed {
	m := metricSqlserverUserConnectionsAuthenticationFailed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationLoginsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.logins_per_sec metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationLoginsPerSec) init() {
	m.data.SetName("sqlserver.user_connections.authentication.logins_per_sec")
	m.data.SetDescription("Number of logins per second")
	m.data.SetUnit("{logins}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationLoginsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationLoginsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationLoginsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationLoginsPerSec(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationLoginsPerSec {
	m := metricSqlserverUserConnectionsAuthenticationLoginsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationLogoutsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.logouts_per_sec metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationLogoutsPerSec) init() {
	m.data.SetName("sqlserver.user_connections.authentication.logouts_per_sec")
	m.data.SetDescription("Number of logouts per second")
	m.data.SetUnit("{logouts}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationLogoutsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationLogoutsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationLogoutsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationLogoutsPerSec(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationLogoutsPerSec {
	m := metricSqlserverUserConnectionsAuthenticationLogoutsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsByStatus struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.by_status metric with initial data.
func (m *metricSqlserverUserConnectionsByStatus) init() {
	m.data.SetName("sqlserver.user_connections.by_status")
	m.data.SetDescription("User connections by status")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverUserConnectionsByStatus) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, connectionStatusAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("connection_status", connectionStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsByStatus) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsByStatus) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsByStatus(cfg MetricConfig) metricSqlserverUserConnectionsByStatus {
	m := metricSqlserverUserConnectionsByStatus{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.total metric with initial data.
func (m *metricSqlserverUserConnectionsTotal) init() {
	m.data.SetName("sqlserver.user_connections.total")
	m.data.SetDescription("Total user connections")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsTotal(cfg MetricConfig) metricSqlserverUserConnectionsTotal {
	m := metricSqlserverUserConnectionsTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsUtilizationActiveRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.utilization.active_ratio metric with initial data.
func (m *metricSqlserverUserConnectionsUtilizationActiveRatio) init() {
	m.data.SetName("sqlserver.user_connections.utilization.active_ratio")
	m.data.SetDescription("Ratio of active to total connections")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsUtilizationActiveRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsUtilizationActiveRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsUtilizationActiveRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsUtilizationActiveRatio(cfg MetricConfig) metricSqlserverUserConnectionsUtilizationActiveRatio {
	m := metricSqlserverUserConnectionsUtilizationActiveRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsUtilizationEfficiency struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.utilization.efficiency metric with initial data.
func (m *metricSqlserverUserConnectionsUtilizationEfficiency) init() {
	m.data.SetName("sqlserver.user_connections.utilization.efficiency")
	m.data.SetDescription("Connection efficiency score")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsUtilizationEfficiency) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsUtilizationEfficiency) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsUtilizationEfficiency) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsUtilizationEfficiency(cfg MetricConfig) metricSqlserverUserConnectionsUtilizationEfficiency {
	m := metricSqlserverUserConnectionsUtilizationEfficiency{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverWaitStatsLatchWaitTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.wait_stats.latch.wait_time metric with initial data.
func (m *metricSqlserverWaitStatsLatchWaitTime) init() {
	m.data.SetName("sqlserver.wait_stats.latch.wait_time")
	m.data.SetDescription("Cumulative latch wait time")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverWaitStatsLatchWaitTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, latchClassAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("latch_class", latchClassAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverWaitStatsLatchWaitTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverWaitStatsLatchWaitTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverWaitStatsLatchWaitTime(cfg MetricConfig) metricSqlserverWaitStatsLatchWaitTime {
	m := metricSqlserverWaitStatsLatchWaitTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverWaitStatsLatchWaitingTasksCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.wait_stats.latch.waiting_tasks_count metric with initial data.
func (m *metricSqlserverWaitStatsLatchWaitingTasksCount) init() {
	m.data.SetName("sqlserver.wait_stats.latch.waiting_tasks_count")
	m.data.SetDescription("Number of tasks waiting for latch")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverWaitStatsLatchWaitingTasksCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, latchClassAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("latch_class", latchClassAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverWaitStatsLatchWaitingTasksCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverWaitStatsLatchWaitingTasksCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverWaitStatsLatchWaitingTasksCount(cfg MetricConfig) metricSqlserverWaitStatsLatchWaitingTasksCount {
	m := metricSqlserverWaitStatsLatchWaitingTasksCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverWaitStatsWaitTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.wait_stats.wait_time metric with initial data.
func (m *metricSqlserverWaitStatsWaitTime) init() {
	m.data.SetName("sqlserver.wait_stats.wait_time")
	m.data.SetDescription("Cumulative wait time for wait type")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverWaitStatsWaitTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, waitTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverWaitStatsWaitTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverWaitStatsWaitTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverWaitStatsWaitTime(cfg MetricConfig) metricSqlserverWaitStatsWaitTime {
	m := metricSqlserverWaitStatsWaitTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverWaitStatsWaitingTasksCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.wait_stats.waiting_tasks_count metric with initial data.
func (m *metricSqlserverWaitStatsWaitingTasksCount) init() {
	m.data.SetName("sqlserver.wait_stats.waiting_tasks_count")
	m.data.SetDescription("Number of tasks waiting for this wait type")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverWaitStatsWaitingTasksCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, waitTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverWaitStatsWaitingTasksCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverWaitStatsWaitingTasksCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverWaitStatsWaitingTasksCount(cfg MetricConfig) metricSqlserverWaitStatsWaitingTasksCount {
	m := metricSqlserverWaitStatsWaitingTasksCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                                                    MetricsBuilderConfig // config of the metrics builder.
	startTime                                                 pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                                           int                  // maximum observed number of metrics per resource.
	metricsBuffer                                             pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                                                 component.BuildInfo  // contains version information.
	resourceAttributeIncludeFilter                            map[string]filter.Filter
	resourceAttributeExcludeFilter                            map[string]filter.Filter
	metricSqlserverActivequeryCPUTime                         metricSqlserverActivequeryCPUTime
	metricSqlserverActivequeryElapsedTime                     metricSqlserverActivequeryElapsedTime
	metricSqlserverActivequeryGrantedMemory                   metricSqlserverActivequeryGrantedMemory
	metricSqlserverActivequeryLogicalReads                    metricSqlserverActivequeryLogicalReads
	metricSqlserverActivequeryReads                           metricSqlserverActivequeryReads
	metricSqlserverActivequeryRowCount                        metricSqlserverActivequeryRowCount
	metricSqlserverActivequeryWaitTime                        metricSqlserverActivequeryWaitTime
	metricSqlserverActivequeryWrites                          metricSqlserverActivequeryWrites
	metricSqlserverDatabaseBufferpoolSize                     metricSqlserverDatabaseBufferpoolSize
	metricSqlserverDatabaseDiskMaxSize                        metricSqlserverDatabaseDiskMaxSize
	metricSqlserverDatabaseIoStallTime                        metricSqlserverDatabaseIoStallTime
	metricSqlserverDatabaseLogTransactionGrowth               metricSqlserverDatabaseLogTransactionGrowth
	metricSqlserverDatabasePagefileAvailable                  metricSqlserverDatabasePagefileAvailable
	metricSqlserverDatabasePagefileTotal                      metricSqlserverDatabasePagefileTotal
	metricSqlserverDatabasePrincipalsCount                    metricSqlserverDatabasePrincipalsCount
	metricSqlserverDatabaseRoleMembersUnique                  metricSqlserverDatabaseRoleMembersUnique
	metricSqlserverDatabaseRoleMembershipsActive              metricSqlserverDatabaseRoleMembershipsActive
	metricSqlserverDatabaseRoleMembershipsTotal               metricSqlserverDatabaseRoleMembershipsTotal
	metricSqlserverDatabaseRoleNestingLevel                   metricSqlserverDatabaseRoleNestingLevel
	metricSqlserverDatabaseRolePermissionsInherited           metricSqlserverDatabaseRolePermissionsInherited
	metricSqlserverFailoverClusterFailureConditionLevel       metricSqlserverFailoverClusterFailureConditionLevel
	metricSqlserverFailoverClusterHealthCheckTimeout          metricSqlserverFailoverClusterHealthCheckTimeout
	metricSqlserverFailoverClusterReplicaRole                 metricSqlserverFailoverClusterReplicaRole
	metricSqlserverFailoverClusterSynchronizationHealth       metricSqlserverFailoverClusterSynchronizationHealth
	metricSqlserverInstanceActiveConnections                  metricSqlserverInstanceActiveConnections
	metricSqlserverInstanceBufferPoolHitPercent               metricSqlserverInstanceBufferPoolHitPercent
	metricSqlserverInstanceBufferPoolSize                     metricSqlserverInstanceBufferPoolSize
	metricSqlserverInstanceDiskMetrics                        metricSqlserverInstanceDiskMetrics
	metricSqlserverInstanceMemoryAvailable                    metricSqlserverInstanceMemoryAvailable
	metricSqlserverInstanceMemoryTotal                        metricSqlserverInstanceMemoryTotal
	metricSqlserverInstanceMemoryUtilization                  metricSqlserverInstanceMemoryUtilization
	metricSqlserverInstanceProcessCounts                      metricSqlserverInstanceProcessCounts
	metricSqlserverInstanceRunnableTasks                      metricSqlserverInstanceRunnableTasks
	metricSqlserverLockModeBulkUpdate                         metricSqlserverLockModeBulkUpdate
	metricSqlserverLockModeExclusive                          metricSqlserverLockModeExclusive
	metricSqlserverLockModeIntent                             metricSqlserverLockModeIntent
	metricSqlserverLockModeSchema                             metricSqlserverLockModeSchema
	metricSqlserverLockModeShared                             metricSqlserverLockModeShared
	metricSqlserverLockModeSharedIntentExclusive              metricSqlserverLockModeSharedIntentExclusive
	metricSqlserverLockModeTotal                              metricSqlserverLockModeTotal
	metricSqlserverLockModeUpdate                             metricSqlserverLockModeUpdate
	metricSqlserverLockResourceAllocationUnit                 metricSqlserverLockResourceAllocationUnit
	metricSqlserverLockResourceApplication                    metricSqlserverLockResourceApplication
	metricSqlserverLockResourceDatabase                       metricSqlserverLockResourceDatabase
	metricSqlserverLockResourceExtent                         metricSqlserverLockResourceExtent
	metricSqlserverLockResourceFile                           metricSqlserverLockResourceFile
	metricSqlserverLockResourceHobt                           metricSqlserverLockResourceHobt
	metricSqlserverLockResourceKey                            metricSqlserverLockResourceKey
	metricSqlserverLockResourceMetadata                       metricSqlserverLockResourceMetadata
	metricSqlserverLockResourcePage                           metricSqlserverLockResourcePage
	metricSqlserverLockResourceRow                            metricSqlserverLockResourceRow
	metricSqlserverLockResourceTable                          metricSqlserverLockResourceTable
	metricSqlserverLockResourceTotal                          metricSqlserverLockResourceTotal
	metricSqlserverLockedObject                               metricSqlserverLockedObject
	metricSqlserverPlanElapsedTimeAvg                         metricSqlserverPlanElapsedTimeAvg
	metricSqlserverPlanElapsedTimeTotal                       metricSqlserverPlanElapsedTimeTotal
	metricSqlserverPlanExecutionCount                         metricSqlserverPlanExecutionCount
	metricSqlserverPlanLogicalReads                           metricSqlserverPlanLogicalReads
	metricSqlserverPlanLogicalWrites                          metricSqlserverPlanLogicalWrites
	metricSqlserverPlanWorkerTime                             metricSqlserverPlanWorkerTime
	metricSqlserverSecurityPrincipalsCount                    metricSqlserverSecurityPrincipalsCount
	metricSqlserverSecurityRoleMembersCount                   metricSqlserverSecurityRoleMembersCount
	metricSqlserverSlowqueryCPUTime                           metricSqlserverSlowqueryCPUTime
	metricSqlserverSlowqueryDegreeOfParallelism               metricSqlserverSlowqueryDegreeOfParallelism
	metricSqlserverSlowqueryDiskReads                         metricSqlserverSlowqueryDiskReads
	metricSqlserverSlowqueryDiskWrites                        metricSqlserverSlowqueryDiskWrites
	metricSqlserverSlowqueryElapsedTimeHistorical             metricSqlserverSlowqueryElapsedTimeHistorical
	metricSqlserverSlowqueryElapsedTimeInterval               metricSqlserverSlowqueryElapsedTimeInterval
	metricSqlserverSlowqueryExecutionCountHistorical          metricSqlserverSlowqueryExecutionCountHistorical
	metricSqlserverSlowqueryExecutionCountInterval            metricSqlserverSlowqueryExecutionCountInterval
	metricSqlserverSlowqueryMemoryGrant                       metricSqlserverSlowqueryMemoryGrant
	metricSqlserverSlowqueryRowsProcessed                     metricSqlserverSlowqueryRowsProcessed
	metricSqlserverSlowqueryTempdbSpills                      metricSqlserverSlowqueryTempdbSpills
	metricSqlserverTempdbAllocationWaits                      metricSqlserverTempdbAllocationWaits
	metricSqlserverTempdbCurrentWaiters                       metricSqlserverTempdbCurrentWaiters
	metricSqlserverTempdbDataFileCount                        metricSqlserverTempdbDataFileCount
	metricSqlserverTempdbPagelatchWaits                       metricSqlserverTempdbPagelatchWaits
	metricSqlserverTempdbTotalSize                            metricSqlserverTempdbTotalSize
	metricSqlserverThreadpoolCurrentTasks                     metricSqlserverThreadpoolCurrentTasks
	metricSqlserverThreadpoolMaxWorkers                       metricSqlserverThreadpoolMaxWorkers
	metricSqlserverThreadpoolRunnableTasks                    metricSqlserverThreadpoolRunnableTasks
	metricSqlserverThreadpoolRunningWorkers                   metricSqlserverThreadpoolRunningWorkers
	metricSqlserverThreadpoolUtilization                      metricSqlserverThreadpoolUtilization
	metricSqlserverThreadpoolWaitingTasks                     metricSqlserverThreadpoolWaitingTasks
	metricSqlserverThreadpoolWorkQueueCount                   metricSqlserverThreadpoolWorkQueueCount
	metricSqlserverUserConnectionsAuthenticationFailed        metricSqlserverUserConnectionsAuthenticationFailed
	metricSqlserverUserConnectionsAuthenticationLoginsPerSec  metricSqlserverUserConnectionsAuthenticationLoginsPerSec
	metricSqlserverUserConnectionsAuthenticationLogoutsPerSec metricSqlserverUserConnectionsAuthenticationLogoutsPerSec
	metricSqlserverUserConnectionsByStatus                    metricSqlserverUserConnectionsByStatus
	metricSqlserverUserConnectionsTotal                       metricSqlserverUserConnectionsTotal
	metricSqlserverUserConnectionsUtilizationActiveRatio      metricSqlserverUserConnectionsUtilizationActiveRatio
	metricSqlserverUserConnectionsUtilizationEfficiency       metricSqlserverUserConnectionsUtilizationEfficiency
	metricSqlserverWaitStatsLatchWaitTime                     metricSqlserverWaitStatsLatchWaitTime
	metricSqlserverWaitStatsLatchWaitingTasksCount            metricSqlserverWaitStatsLatchWaitingTasksCount
	metricSqlserverWaitStatsWaitTime                          metricSqlserverWaitStatsWaitTime
	metricSqlserverWaitStatsWaitingTasksCount                 metricSqlserverWaitStatsWaitingTasksCount
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}
func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:                                                    mbc,
		startTime:                                                 pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                                             pmetric.NewMetrics(),
		buildInfo:                                                 settings.BuildInfo,
		metricSqlserverActivequeryCPUTime:                         newMetricSqlserverActivequeryCPUTime(mbc.Metrics.SqlserverActivequeryCPUTime),
		metricSqlserverActivequeryElapsedTime:                     newMetricSqlserverActivequeryElapsedTime(mbc.Metrics.SqlserverActivequeryElapsedTime),
		metricSqlserverActivequeryGrantedMemory:                   newMetricSqlserverActivequeryGrantedMemory(mbc.Metrics.SqlserverActivequeryGrantedMemory),
		metricSqlserverActivequeryLogicalReads:                    newMetricSqlserverActivequeryLogicalReads(mbc.Metrics.SqlserverActivequeryLogicalReads),
		metricSqlserverActivequeryReads:                           newMetricSqlserverActivequeryReads(mbc.Metrics.SqlserverActivequeryReads),
		metricSqlserverActivequeryRowCount:                        newMetricSqlserverActivequeryRowCount(mbc.Metrics.SqlserverActivequeryRowCount),
		metricSqlserverActivequeryWaitTime:                        newMetricSqlserverActivequeryWaitTime(mbc.Metrics.SqlserverActivequeryWaitTime),
		metricSqlserverActivequeryWrites:                          newMetricSqlserverActivequeryWrites(mbc.Metrics.SqlserverActivequeryWrites),
		metricSqlserverDatabaseBufferpoolSize:                     newMetricSqlserverDatabaseBufferpoolSize(mbc.Metrics.SqlserverDatabaseBufferpoolSize),
		metricSqlserverDatabaseDiskMaxSize:                        newMetricSqlserverDatabaseDiskMaxSize(mbc.Metrics.SqlserverDatabaseDiskMaxSize),
		metricSqlserverDatabaseIoStallTime:                        newMetricSqlserverDatabaseIoStallTime(mbc.Metrics.SqlserverDatabaseIoStallTime),
		metricSqlserverDatabaseLogTransactionGrowth:               newMetricSqlserverDatabaseLogTransactionGrowth(mbc.Metrics.SqlserverDatabaseLogTransactionGrowth),
		metricSqlserverDatabasePagefileAvailable:                  newMetricSqlserverDatabasePagefileAvailable(mbc.Metrics.SqlserverDatabasePagefileAvailable),
		metricSqlserverDatabasePagefileTotal:                      newMetricSqlserverDatabasePagefileTotal(mbc.Metrics.SqlserverDatabasePagefileTotal),
		metricSqlserverDatabasePrincipalsCount:                    newMetricSqlserverDatabasePrincipalsCount(mbc.Metrics.SqlserverDatabasePrincipalsCount),
		metricSqlserverDatabaseRoleMembersUnique:                  newMetricSqlserverDatabaseRoleMembersUnique(mbc.Metrics.SqlserverDatabaseRoleMembersUnique),
		metricSqlserverDatabaseRoleMembershipsActive:              newMetricSqlserverDatabaseRoleMembershipsActive(mbc.Metrics.SqlserverDatabaseRoleMembershipsActive),
		metricSqlserverDatabaseRoleMembershipsTotal:               newMetricSqlserverDatabaseRoleMembershipsTotal(mbc.Metrics.SqlserverDatabaseRoleMembershipsTotal),
		metricSqlserverDatabaseRoleNestingLevel:                   newMetricSqlserverDatabaseRoleNestingLevel(mbc.Metrics.SqlserverDatabaseRoleNestingLevel),
		metricSqlserverDatabaseRolePermissionsInherited:           newMetricSqlserverDatabaseRolePermissionsInherited(mbc.Metrics.SqlserverDatabaseRolePermissionsInherited),
		metricSqlserverFailoverClusterFailureConditionLevel:       newMetricSqlserverFailoverClusterFailureConditionLevel(mbc.Metrics.SqlserverFailoverClusterFailureConditionLevel),
		metricSqlserverFailoverClusterHealthCheckTimeout:          newMetricSqlserverFailoverClusterHealthCheckTimeout(mbc.Metrics.SqlserverFailoverClusterHealthCheckTimeout),
		metricSqlserverFailoverClusterReplicaRole:                 newMetricSqlserverFailoverClusterReplicaRole(mbc.Metrics.SqlserverFailoverClusterReplicaRole),
		metricSqlserverFailoverClusterSynchronizationHealth:       newMetricSqlserverFailoverClusterSynchronizationHealth(mbc.Metrics.SqlserverFailoverClusterSynchronizationHealth),
		metricSqlserverInstanceActiveConnections:                  newMetricSqlserverInstanceActiveConnections(mbc.Metrics.SqlserverInstanceActiveConnections),
		metricSqlserverInstanceBufferPoolHitPercent:               newMetricSqlserverInstanceBufferPoolHitPercent(mbc.Metrics.SqlserverInstanceBufferPoolHitPercent),
		metricSqlserverInstanceBufferPoolSize:                     newMetricSqlserverInstanceBufferPoolSize(mbc.Metrics.SqlserverInstanceBufferPoolSize),
		metricSqlserverInstanceDiskMetrics:                        newMetricSqlserverInstanceDiskMetrics(mbc.Metrics.SqlserverInstanceDiskMetrics),
		metricSqlserverInstanceMemoryAvailable:                    newMetricSqlserverInstanceMemoryAvailable(mbc.Metrics.SqlserverInstanceMemoryAvailable),
		metricSqlserverInstanceMemoryTotal:                        newMetricSqlserverInstanceMemoryTotal(mbc.Metrics.SqlserverInstanceMemoryTotal),
		metricSqlserverInstanceMemoryUtilization:                  newMetricSqlserverInstanceMemoryUtilization(mbc.Metrics.SqlserverInstanceMemoryUtilization),
		metricSqlserverInstanceProcessCounts:                      newMetricSqlserverInstanceProcessCounts(mbc.Metrics.SqlserverInstanceProcessCounts),
		metricSqlserverInstanceRunnableTasks:                      newMetricSqlserverInstanceRunnableTasks(mbc.Metrics.SqlserverInstanceRunnableTasks),
		metricSqlserverLockModeBulkUpdate:                         newMetricSqlserverLockModeBulkUpdate(mbc.Metrics.SqlserverLockModeBulkUpdate),
		metricSqlserverLockModeExclusive:                          newMetricSqlserverLockModeExclusive(mbc.Metrics.SqlserverLockModeExclusive),
		metricSqlserverLockModeIntent:                             newMetricSqlserverLockModeIntent(mbc.Metrics.SqlserverLockModeIntent),
		metricSqlserverLockModeSchema:                             newMetricSqlserverLockModeSchema(mbc.Metrics.SqlserverLockModeSchema),
		metricSqlserverLockModeShared:                             newMetricSqlserverLockModeShared(mbc.Metrics.SqlserverLockModeShared),
		metricSqlserverLockModeSharedIntentExclusive:              newMetricSqlserverLockModeSharedIntentExclusive(mbc.Metrics.SqlserverLockModeSharedIntentExclusive),
		metricSqlserverLockModeTotal:                              newMetricSqlserverLockModeTotal(mbc.Metrics.SqlserverLockModeTotal),
		metricSqlserverLockModeUpdate:                             newMetricSqlserverLockModeUpdate(mbc.Metrics.SqlserverLockModeUpdate),
		metricSqlserverLockResourceAllocationUnit:                 newMetricSqlserverLockResourceAllocationUnit(mbc.Metrics.SqlserverLockResourceAllocationUnit),
		metricSqlserverLockResourceApplication:                    newMetricSqlserverLockResourceApplication(mbc.Metrics.SqlserverLockResourceApplication),
		metricSqlserverLockResourceDatabase:                       newMetricSqlserverLockResourceDatabase(mbc.Metrics.SqlserverLockResourceDatabase),
		metricSqlserverLockResourceExtent:                         newMetricSqlserverLockResourceExtent(mbc.Metrics.SqlserverLockResourceExtent),
		metricSqlserverLockResourceFile:                           newMetricSqlserverLockResourceFile(mbc.Metrics.SqlserverLockResourceFile),
		metricSqlserverLockResourceHobt:                           newMetricSqlserverLockResourceHobt(mbc.Metrics.SqlserverLockResourceHobt),
		metricSqlserverLockResourceKey:                            newMetricSqlserverLockResourceKey(mbc.Metrics.SqlserverLockResourceKey),
		metricSqlserverLockResourceMetadata:                       newMetricSqlserverLockResourceMetadata(mbc.Metrics.SqlserverLockResourceMetadata),
		metricSqlserverLockResourcePage:                           newMetricSqlserverLockResourcePage(mbc.Metrics.SqlserverLockResourcePage),
		metricSqlserverLockResourceRow:                            newMetricSqlserverLockResourceRow(mbc.Metrics.SqlserverLockResourceRow),
		metricSqlserverLockResourceTable:                          newMetricSqlserverLockResourceTable(mbc.Metrics.SqlserverLockResourceTable),
		metricSqlserverLockResourceTotal:                          newMetricSqlserverLockResourceTotal(mbc.Metrics.SqlserverLockResourceTotal),
		metricSqlserverLockedObject:                               newMetricSqlserverLockedObject(mbc.Metrics.SqlserverLockedObject),
		metricSqlserverPlanElapsedTimeAvg:                         newMetricSqlserverPlanElapsedTimeAvg(mbc.Metrics.SqlserverPlanElapsedTimeAvg),
		metricSqlserverPlanElapsedTimeTotal:                       newMetricSqlserverPlanElapsedTimeTotal(mbc.Metrics.SqlserverPlanElapsedTimeTotal),
		metricSqlserverPlanExecutionCount:                         newMetricSqlserverPlanExecutionCount(mbc.Metrics.SqlserverPlanExecutionCount),
		metricSqlserverPlanLogicalReads:                           newMetricSqlserverPlanLogicalReads(mbc.Metrics.SqlserverPlanLogicalReads),
		metricSqlserverPlanLogicalWrites:                          newMetricSqlserverPlanLogicalWrites(mbc.Metrics.SqlserverPlanLogicalWrites),
		metricSqlserverPlanWorkerTime:                             newMetricSqlserverPlanWorkerTime(mbc.Metrics.SqlserverPlanWorkerTime),
		metricSqlserverSecurityPrincipalsCount:                    newMetricSqlserverSecurityPrincipalsCount(mbc.Metrics.SqlserverSecurityPrincipalsCount),
		metricSqlserverSecurityRoleMembersCount:                   newMetricSqlserverSecurityRoleMembersCount(mbc.Metrics.SqlserverSecurityRoleMembersCount),
		metricSqlserverSlowqueryCPUTime:                           newMetricSqlserverSlowqueryCPUTime(mbc.Metrics.SqlserverSlowqueryCPUTime),
		metricSqlserverSlowqueryDegreeOfParallelism:               newMetricSqlserverSlowqueryDegreeOfParallelism(mbc.Metrics.SqlserverSlowqueryDegreeOfParallelism),
		metricSqlserverSlowqueryDiskReads:                         newMetricSqlserverSlowqueryDiskReads(mbc.Metrics.SqlserverSlowqueryDiskReads),
		metricSqlserverSlowqueryDiskWrites:                        newMetricSqlserverSlowqueryDiskWrites(mbc.Metrics.SqlserverSlowqueryDiskWrites),
		metricSqlserverSlowqueryElapsedTimeHistorical:             newMetricSqlserverSlowqueryElapsedTimeHistorical(mbc.Metrics.SqlserverSlowqueryElapsedTimeHistorical),
		metricSqlserverSlowqueryElapsedTimeInterval:               newMetricSqlserverSlowqueryElapsedTimeInterval(mbc.Metrics.SqlserverSlowqueryElapsedTimeInterval),
		metricSqlserverSlowqueryExecutionCountHistorical:          newMetricSqlserverSlowqueryExecutionCountHistorical(mbc.Metrics.SqlserverSlowqueryExecutionCountHistorical),
		metricSqlserverSlowqueryExecutionCountInterval:            newMetricSqlserverSlowqueryExecutionCountInterval(mbc.Metrics.SqlserverSlowqueryExecutionCountInterval),
		metricSqlserverSlowqueryMemoryGrant:                       newMetricSqlserverSlowqueryMemoryGrant(mbc.Metrics.SqlserverSlowqueryMemoryGrant),
		metricSqlserverSlowqueryRowsProcessed:                     newMetricSqlserverSlowqueryRowsProcessed(mbc.Metrics.SqlserverSlowqueryRowsProcessed),
		metricSqlserverSlowqueryTempdbSpills:                      newMetricSqlserverSlowqueryTempdbSpills(mbc.Metrics.SqlserverSlowqueryTempdbSpills),
		metricSqlserverTempdbAllocationWaits:                      newMetricSqlserverTempdbAllocationWaits(mbc.Metrics.SqlserverTempdbAllocationWaits),
		metricSqlserverTempdbCurrentWaiters:                       newMetricSqlserverTempdbCurrentWaiters(mbc.Metrics.SqlserverTempdbCurrentWaiters),
		metricSqlserverTempdbDataFileCount:                        newMetricSqlserverTempdbDataFileCount(mbc.Metrics.SqlserverTempdbDataFileCount),
		metricSqlserverTempdbPagelatchWaits:                       newMetricSqlserverTempdbPagelatchWaits(mbc.Metrics.SqlserverTempdbPagelatchWaits),
		metricSqlserverTempdbTotalSize:                            newMetricSqlserverTempdbTotalSize(mbc.Metrics.SqlserverTempdbTotalSize),
		metricSqlserverThreadpoolCurrentTasks:                     newMetricSqlserverThreadpoolCurrentTasks(mbc.Metrics.SqlserverThreadpoolCurrentTasks),
		metricSqlserverThreadpoolMaxWorkers:                       newMetricSqlserverThreadpoolMaxWorkers(mbc.Metrics.SqlserverThreadpoolMaxWorkers),
		metricSqlserverThreadpoolRunnableTasks:                    newMetricSqlserverThreadpoolRunnableTasks(mbc.Metrics.SqlserverThreadpoolRunnableTasks),
		metricSqlserverThreadpoolRunningWorkers:                   newMetricSqlserverThreadpoolRunningWorkers(mbc.Metrics.SqlserverThreadpoolRunningWorkers),
		metricSqlserverThreadpoolUtilization:                      newMetricSqlserverThreadpoolUtilization(mbc.Metrics.SqlserverThreadpoolUtilization),
		metricSqlserverThreadpoolWaitingTasks:                     newMetricSqlserverThreadpoolWaitingTasks(mbc.Metrics.SqlserverThreadpoolWaitingTasks),
		metricSqlserverThreadpoolWorkQueueCount:                   newMetricSqlserverThreadpoolWorkQueueCount(mbc.Metrics.SqlserverThreadpoolWorkQueueCount),
		metricSqlserverUserConnectionsAuthenticationFailed:        newMetricSqlserverUserConnectionsAuthenticationFailed(mbc.Metrics.SqlserverUserConnectionsAuthenticationFailed),
		metricSqlserverUserConnectionsAuthenticationLoginsPerSec:  newMetricSqlserverUserConnectionsAuthenticationLoginsPerSec(mbc.Metrics.SqlserverUserConnectionsAuthenticationLoginsPerSec),
		metricSqlserverUserConnectionsAuthenticationLogoutsPerSec: newMetricSqlserverUserConnectionsAuthenticationLogoutsPerSec(mbc.Metrics.SqlserverUserConnectionsAuthenticationLogoutsPerSec),
		metricSqlserverUserConnectionsByStatus:                    newMetricSqlserverUserConnectionsByStatus(mbc.Metrics.SqlserverUserConnectionsByStatus),
		metricSqlserverUserConnectionsTotal:                       newMetricSqlserverUserConnectionsTotal(mbc.Metrics.SqlserverUserConnectionsTotal),
		metricSqlserverUserConnectionsUtilizationActiveRatio:      newMetricSqlserverUserConnectionsUtilizationActiveRatio(mbc.Metrics.SqlserverUserConnectionsUtilizationActiveRatio),
		metricSqlserverUserConnectionsUtilizationEfficiency:       newMetricSqlserverUserConnectionsUtilizationEfficiency(mbc.Metrics.SqlserverUserConnectionsUtilizationEfficiency),
		metricSqlserverWaitStatsLatchWaitTime:                     newMetricSqlserverWaitStatsLatchWaitTime(mbc.Metrics.SqlserverWaitStatsLatchWaitTime),
		metricSqlserverWaitStatsLatchWaitingTasksCount:            newMetricSqlserverWaitStatsLatchWaitingTasksCount(mbc.Metrics.SqlserverWaitStatsLatchWaitingTasksCount),
		metricSqlserverWaitStatsWaitTime:                          newMetricSqlserverWaitStatsWaitTime(mbc.Metrics.SqlserverWaitStatsWaitTime),
		metricSqlserverWaitStatsWaitingTasksCount:                 newMetricSqlserverWaitStatsWaitingTasksCount(mbc.Metrics.SqlserverWaitStatsWaitingTasksCount),
		resourceAttributeIncludeFilter:                            make(map[string]filter.Filter),
		resourceAttributeExcludeFilter:                            make(map[string]filter.Filter),
	}
	if mbc.ResourceAttributes.DatabaseName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["database_name"] = filter.CreateFilter(mbc.ResourceAttributes.DatabaseName.MetricsInclude)
	}
	if mbc.ResourceAttributes.DatabaseName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["database_name"] = filter.CreateFilter(mbc.ResourceAttributes.DatabaseName.MetricsExclude)
	}
	if mbc.ResourceAttributes.DbSystem.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["db.system"] = filter.CreateFilter(mbc.ResourceAttributes.DbSystem.MetricsInclude)
	}
	if mbc.ResourceAttributes.DbSystem.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["db.system"] = filter.CreateFilter(mbc.ResourceAttributes.DbSystem.MetricsExclude)
	}
	if mbc.ResourceAttributes.ServerAddress.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["server.address"] = filter.CreateFilter(mbc.ResourceAttributes.ServerAddress.MetricsInclude)
	}
	if mbc.ResourceAttributes.ServerAddress.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["server.address"] = filter.CreateFilter(mbc.ResourceAttributes.ServerAddress.MetricsExclude)
	}
	if mbc.ResourceAttributes.ServerPort.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["server.port"] = filter.CreateFilter(mbc.ResourceAttributes.ServerPort.MetricsInclude)
	}
	if mbc.ResourceAttributes.ServerPort.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["server.port"] = filter.CreateFilter(mbc.ResourceAttributes.ServerPort.MetricsExclude)
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricSqlserverActivequeryCPUTime.emit(ils.Metrics())
	mb.metricSqlserverActivequeryElapsedTime.emit(ils.Metrics())
	mb.metricSqlserverActivequeryGrantedMemory.emit(ils.Metrics())
	mb.metricSqlserverActivequeryLogicalReads.emit(ils.Metrics())
	mb.metricSqlserverActivequeryReads.emit(ils.Metrics())
	mb.metricSqlserverActivequeryRowCount.emit(ils.Metrics())
	mb.metricSqlserverActivequeryWaitTime.emit(ils.Metrics())
	mb.metricSqlserverActivequeryWrites.emit(ils.Metrics())
	mb.metricSqlserverDatabaseBufferpoolSize.emit(ils.Metrics())
	mb.metricSqlserverDatabaseDiskMaxSize.emit(ils.Metrics())
	mb.metricSqlserverDatabaseIoStallTime.emit(ils.Metrics())
	mb.metricSqlserverDatabaseLogTransactionGrowth.emit(ils.Metrics())
	mb.metricSqlserverDatabasePagefileAvailable.emit(ils.Metrics())
	mb.metricSqlserverDatabasePagefileTotal.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsCount.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembersUnique.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembershipsActive.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembershipsTotal.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleNestingLevel.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRolePermissionsInherited.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterFailureConditionLevel.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterHealthCheckTimeout.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterReplicaRole.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterSynchronizationHealth.emit(ils.Metrics())
	mb.metricSqlserverInstanceActiveConnections.emit(ils.Metrics())
	mb.metricSqlserverInstanceBufferPoolHitPercent.emit(ils.Metrics())
	mb.metricSqlserverInstanceBufferPoolSize.emit(ils.Metrics())
	mb.metricSqlserverInstanceDiskMetrics.emit(ils.Metrics())
	mb.metricSqlserverInstanceMemoryAvailable.emit(ils.Metrics())
	mb.metricSqlserverInstanceMemoryTotal.emit(ils.Metrics())
	mb.metricSqlserverInstanceMemoryUtilization.emit(ils.Metrics())
	mb.metricSqlserverInstanceProcessCounts.emit(ils.Metrics())
	mb.metricSqlserverInstanceRunnableTasks.emit(ils.Metrics())
	mb.metricSqlserverLockModeBulkUpdate.emit(ils.Metrics())
	mb.metricSqlserverLockModeExclusive.emit(ils.Metrics())
	mb.metricSqlserverLockModeIntent.emit(ils.Metrics())
	mb.metricSqlserverLockModeSchema.emit(ils.Metrics())
	mb.metricSqlserverLockModeShared.emit(ils.Metrics())
	mb.metricSqlserverLockModeSharedIntentExclusive.emit(ils.Metrics())
	mb.metricSqlserverLockModeTotal.emit(ils.Metrics())
	mb.metricSqlserverLockModeUpdate.emit(ils.Metrics())
	mb.metricSqlserverLockResourceAllocationUnit.emit(ils.Metrics())
	mb.metricSqlserverLockResourceApplication.emit(ils.Metrics())
	mb.metricSqlserverLockResourceDatabase.emit(ils.Metrics())
	mb.metricSqlserverLockResourceExtent.emit(ils.Metrics())
	mb.metricSqlserverLockResourceFile.emit(ils.Metrics())
	mb.metricSqlserverLockResourceHobt.emit(ils.Metrics())
	mb.metricSqlserverLockResourceKey.emit(ils.Metrics())
	mb.metricSqlserverLockResourceMetadata.emit(ils.Metrics())
	mb.metricSqlserverLockResourcePage.emit(ils.Metrics())
	mb.metricSqlserverLockResourceRow.emit(ils.Metrics())
	mb.metricSqlserverLockResourceTable.emit(ils.Metrics())
	mb.metricSqlserverLockResourceTotal.emit(ils.Metrics())
	mb.metricSqlserverLockedObject.emit(ils.Metrics())
	mb.metricSqlserverPlanElapsedTimeAvg.emit(ils.Metrics())
	mb.metricSqlserverPlanElapsedTimeTotal.emit(ils.Metrics())
	mb.metricSqlserverPlanExecutionCount.emit(ils.Metrics())
	mb.metricSqlserverPlanLogicalReads.emit(ils.Metrics())
	mb.metricSqlserverPlanLogicalWrites.emit(ils.Metrics())
	mb.metricSqlserverPlanWorkerTime.emit(ils.Metrics())
	mb.metricSqlserverSecurityPrincipalsCount.emit(ils.Metrics())
	mb.metricSqlserverSecurityRoleMembersCount.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryCPUTime.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryDegreeOfParallelism.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryDiskReads.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryDiskWrites.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryElapsedTimeHistorical.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryElapsedTimeInterval.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryExecutionCountHistorical.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryExecutionCountInterval.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryMemoryGrant.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryRowsProcessed.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryTempdbSpills.emit(ils.Metrics())
	mb.metricSqlserverTempdbAllocationWaits.emit(ils.Metrics())
	mb.metricSqlserverTempdbCurrentWaiters.emit(ils.Metrics())
	mb.metricSqlserverTempdbDataFileCount.emit(ils.Metrics())
	mb.metricSqlserverTempdbPagelatchWaits.emit(ils.Metrics())
	mb.metricSqlserverTempdbTotalSize.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolCurrentTasks.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolMaxWorkers.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolRunnableTasks.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolRunningWorkers.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolUtilization.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolWaitingTasks.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolWorkQueueCount.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationFailed.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationLoginsPerSec.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationLogoutsPerSec.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsByStatus.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsTotal.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsUtilizationActiveRatio.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsUtilizationEfficiency.emit(ils.Metrics())
	mb.metricSqlserverWaitStatsLatchWaitTime.emit(ils.Metrics())
	mb.metricSqlserverWaitStatsLatchWaitingTasksCount.emit(ils.Metrics())
	mb.metricSqlserverWaitStatsWaitTime.emit(ils.Metrics())
	mb.metricSqlserverWaitStatsWaitingTasksCount.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}
	for attr, filter := range mb.resourceAttributeIncludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && !filter.Matches(val.AsString()) {
			return
		}
	}
	for attr, filter := range mb.resourceAttributeExcludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && filter.Matches(val.AsString()) {
			return
		}
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordSqlserverActivequeryCPUTimeDataPoint adds a data point to sqlserver.activequery.cpu_time metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryCPUTimeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverActivequeryCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverActivequeryElapsedTimeDataPoint adds a data point to sqlserver.activequery.elapsed_time metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryElapsedTimeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverActivequeryElapsedTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverActivequeryGrantedMemoryDataPoint adds a data point to sqlserver.activequery.granted_memory metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryGrantedMemoryDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverActivequeryGrantedMemory.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverActivequeryLogicalReadsDataPoint adds a data point to sqlserver.activequery.logical_reads metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryLogicalReadsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverActivequeryLogicalReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverActivequeryReadsDataPoint adds a data point to sqlserver.activequery.reads metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryReadsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverActivequeryReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverActivequeryRowCountDataPoint adds a data point to sqlserver.activequery.row_count metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryRowCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverActivequeryRowCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverActivequeryWaitTimeDataPoint adds a data point to sqlserver.activequery.wait_time metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryWaitTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverActivequeryWaitTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverActivequeryWritesDataPoint adds a data point to sqlserver.activequery.writes metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryWritesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverActivequeryWrites.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverDatabaseBufferpoolSizeDataPoint adds a data point to sqlserver.database.bufferpool.size metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseBufferpoolSizeDataPoint(ts pcommon.Timestamp, val int64, dbNameAttributeValue string) {
	mb.metricSqlserverDatabaseBufferpoolSize.recordDataPoint(mb.startTime, ts, val, dbNameAttributeValue)
}

// RecordSqlserverDatabaseDiskMaxSizeDataPoint adds a data point to sqlserver.database.disk.max_size metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseDiskMaxSizeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverDatabaseDiskMaxSize.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverDatabaseIoStallTimeDataPoint adds a data point to sqlserver.database.io.stall_time metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseIoStallTimeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverDatabaseIoStallTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverDatabaseLogTransactionGrowthDataPoint adds a data point to sqlserver.database.log.transaction_growth metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseLogTransactionGrowthDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverDatabaseLogTransactionGrowth.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverDatabasePagefileAvailableDataPoint adds a data point to sqlserver.database.pagefile.available metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePagefileAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverDatabasePagefileAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverDatabasePagefileTotalDataPoint adds a data point to sqlserver.database.pagefile.total metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePagefileTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverDatabasePagefileTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverDatabasePrincipalsCountDataPoint adds a data point to sqlserver.database.principals.count metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverDatabasePrincipalsCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverDatabaseRoleMembersUniqueDataPoint adds a data point to sqlserver.database.role.members.unique metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembersUniqueDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverDatabaseRoleMembersUnique.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverDatabaseRoleMembershipsActiveDataPoint adds a data point to sqlserver.database.role.memberships.active metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembershipsActiveDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverDatabaseRoleMembershipsActive.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverDatabaseRoleMembershipsTotalDataPoint adds a data point to sqlserver.database.role.memberships.total metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembershipsTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverDatabaseRoleMembershipsTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverDatabaseRoleNestingLevelDataPoint adds a data point to sqlserver.database.role.nesting_level metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleNestingLevelDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverDatabaseRoleNestingLevel.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverDatabaseRolePermissionsInheritedDataPoint adds a data point to sqlserver.database.role.permissions.inherited metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRolePermissionsInheritedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverDatabaseRolePermissionsInherited.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverFailoverClusterFailureConditionLevelDataPoint adds a data point to sqlserver.failover_cluster.failure_condition_level metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterFailureConditionLevelDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverFailoverClusterFailureConditionLevel.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverFailoverClusterHealthCheckTimeoutDataPoint adds a data point to sqlserver.failover_cluster.health_check_timeout metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterHealthCheckTimeoutDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverFailoverClusterHealthCheckTimeout.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverFailoverClusterReplicaRoleDataPoint adds a data point to sqlserver.failover_cluster.replica_role metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterReplicaRoleDataPoint(ts pcommon.Timestamp, val int64, replicaIDAttributeValue string, roleAttributeValue string) {
	mb.metricSqlserverFailoverClusterReplicaRole.recordDataPoint(mb.startTime, ts, val, replicaIDAttributeValue, roleAttributeValue)
}

// RecordSqlserverFailoverClusterSynchronizationHealthDataPoint adds a data point to sqlserver.failover_cluster.synchronization_health metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterSynchronizationHealthDataPoint(ts pcommon.Timestamp, val int64, replicaIDAttributeValue string, synchronizationHealthAttributeValue string) {
	mb.metricSqlserverFailoverClusterSynchronizationHealth.recordDataPoint(mb.startTime, ts, val, replicaIDAttributeValue, synchronizationHealthAttributeValue)
}

// RecordSqlserverInstanceActiveConnectionsDataPoint adds a data point to sqlserver.instance.active_connections metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceActiveConnectionsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceActiveConnections.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceBufferPoolHitPercentDataPoint adds a data point to sqlserver.instance.buffer_pool.hit_percent metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceBufferPoolHitPercentDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceBufferPoolHitPercent.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceBufferPoolSizeDataPoint adds a data point to sqlserver.instance.buffer_pool.size metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceBufferPoolSizeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceBufferPoolSize.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceDiskMetricsDataPoint adds a data point to sqlserver.instance.disk_metrics metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceDiskMetricsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceDiskMetrics.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceMemoryAvailableDataPoint adds a data point to sqlserver.instance.memory.available metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceMemoryTotalDataPoint adds a data point to sqlserver.instance.memory.total metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceMemoryTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceMemoryTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceMemoryUtilizationDataPoint adds a data point to sqlserver.instance.memory.utilization metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceMemoryUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceMemoryUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceProcessCountsDataPoint adds a data point to sqlserver.instance.process_counts metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceProcessCountsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceProcessCounts.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceRunnableTasksDataPoint adds a data point to sqlserver.instance.runnable_tasks metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceRunnableTasksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceRunnableTasks.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockModeBulkUpdateDataPoint adds a data point to sqlserver.lock.mode.bulk_update metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeBulkUpdateDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockModeBulkUpdate.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockModeExclusiveDataPoint adds a data point to sqlserver.lock.mode.exclusive metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeExclusiveDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockModeExclusive.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockModeIntentDataPoint adds a data point to sqlserver.lock.mode.intent metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeIntentDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockModeIntent.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockModeSchemaDataPoint adds a data point to sqlserver.lock.mode.schema metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeSchemaDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockModeSchema.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockModeSharedDataPoint adds a data point to sqlserver.lock.mode.shared metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeSharedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockModeShared.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockModeSharedIntentExclusiveDataPoint adds a data point to sqlserver.lock.mode.shared_intent_exclusive metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeSharedIntentExclusiveDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockModeSharedIntentExclusive.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockModeTotalDataPoint adds a data point to sqlserver.lock.mode.total metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockModeTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockModeUpdateDataPoint adds a data point to sqlserver.lock.mode.update metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeUpdateDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockModeUpdate.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockResourceAllocationUnitDataPoint adds a data point to sqlserver.lock.resource.allocation_unit metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceAllocationUnitDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockResourceAllocationUnit.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockResourceApplicationDataPoint adds a data point to sqlserver.lock.resource.application metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceApplicationDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockResourceApplication.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockResourceDatabaseDataPoint adds a data point to sqlserver.lock.resource.database metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceDatabaseDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockResourceDatabase.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockResourceExtentDataPoint adds a data point to sqlserver.lock.resource.extent metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceExtentDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockResourceExtent.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockResourceFileDataPoint adds a data point to sqlserver.lock.resource.file metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceFileDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockResourceFile.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockResourceHobtDataPoint adds a data point to sqlserver.lock.resource.hobt metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceHobtDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockResourceHobt.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockResourceKeyDataPoint adds a data point to sqlserver.lock.resource.key metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceKeyDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockResourceKey.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockResourceMetadataDataPoint adds a data point to sqlserver.lock.resource.metadata metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceMetadataDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockResourceMetadata.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockResourcePageDataPoint adds a data point to sqlserver.lock.resource.page metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourcePageDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockResourcePage.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockResourceRowDataPoint adds a data point to sqlserver.lock.resource.row metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceRowDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockResourceRow.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockResourceTableDataPoint adds a data point to sqlserver.lock.resource.table metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceTableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockResourceTable.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockResourceTotalDataPoint adds a data point to sqlserver.lock.resource.total metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockResourceTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockedObjectDataPoint adds a data point to sqlserver.locked_object metric.
func (mb *MetricsBuilder) RecordSqlserverLockedObjectDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockedObject.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverPlanElapsedTimeAvgDataPoint adds a data point to sqlserver.plan.elapsed_time.avg metric.
func (mb *MetricsBuilder) RecordSqlserverPlanElapsedTimeAvgDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverPlanElapsedTimeAvg.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverPlanElapsedTimeTotalDataPoint adds a data point to sqlserver.plan.elapsed_time.total metric.
func (mb *MetricsBuilder) RecordSqlserverPlanElapsedTimeTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverPlanElapsedTimeTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverPlanExecutionCountDataPoint adds a data point to sqlserver.plan.execution_count metric.
func (mb *MetricsBuilder) RecordSqlserverPlanExecutionCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverPlanExecutionCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverPlanLogicalReadsDataPoint adds a data point to sqlserver.plan.logical_reads metric.
func (mb *MetricsBuilder) RecordSqlserverPlanLogicalReadsDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverPlanLogicalReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverPlanLogicalWritesDataPoint adds a data point to sqlserver.plan.logical_writes metric.
func (mb *MetricsBuilder) RecordSqlserverPlanLogicalWritesDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverPlanLogicalWrites.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverPlanWorkerTimeDataPoint adds a data point to sqlserver.plan.worker_time metric.
func (mb *MetricsBuilder) RecordSqlserverPlanWorkerTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverPlanWorkerTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverSecurityPrincipalsCountDataPoint adds a data point to sqlserver.security.principals.count metric.
func (mb *MetricsBuilder) RecordSqlserverSecurityPrincipalsCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverSecurityPrincipalsCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverSecurityRoleMembersCountDataPoint adds a data point to sqlserver.security.role_members.count metric.
func (mb *MetricsBuilder) RecordSqlserverSecurityRoleMembersCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverSecurityRoleMembersCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverSlowqueryCPUTimeDataPoint adds a data point to sqlserver.slowquery.cpu_time metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverSlowqueryCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverSlowqueryDegreeOfParallelismDataPoint adds a data point to sqlserver.slowquery.degree_of_parallelism metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryDegreeOfParallelismDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverSlowqueryDegreeOfParallelism.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverSlowqueryDiskReadsDataPoint adds a data point to sqlserver.slowquery.disk_reads metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryDiskReadsDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverSlowqueryDiskReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverSlowqueryDiskWritesDataPoint adds a data point to sqlserver.slowquery.disk_writes metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryDiskWritesDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverSlowqueryDiskWrites.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverSlowqueryElapsedTimeHistoricalDataPoint adds a data point to sqlserver.slowquery.elapsed_time.historical metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryElapsedTimeHistoricalDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverSlowqueryElapsedTimeHistorical.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverSlowqueryElapsedTimeIntervalDataPoint adds a data point to sqlserver.slowquery.elapsed_time.interval metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryElapsedTimeIntervalDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverSlowqueryElapsedTimeInterval.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverSlowqueryExecutionCountHistoricalDataPoint adds a data point to sqlserver.slowquery.execution_count.historical metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryExecutionCountHistoricalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverSlowqueryExecutionCountHistorical.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverSlowqueryExecutionCountIntervalDataPoint adds a data point to sqlserver.slowquery.execution_count.interval metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryExecutionCountIntervalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverSlowqueryExecutionCountInterval.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverSlowqueryMemoryGrantDataPoint adds a data point to sqlserver.slowquery.memory_grant metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryMemoryGrantDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverSlowqueryMemoryGrant.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverSlowqueryRowsProcessedDataPoint adds a data point to sqlserver.slowquery.rows_processed metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryRowsProcessedDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverSlowqueryRowsProcessed.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverSlowqueryTempdbSpillsDataPoint adds a data point to sqlserver.slowquery.tempdb_spills metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryTempdbSpillsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverSlowqueryTempdbSpills.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverTempdbAllocationWaitsDataPoint adds a data point to sqlserver.tempdb.allocation_waits metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbAllocationWaitsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverTempdbAllocationWaits.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverTempdbCurrentWaitersDataPoint adds a data point to sqlserver.tempdb.current_waiters metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbCurrentWaitersDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverTempdbCurrentWaiters.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverTempdbDataFileCountDataPoint adds a data point to sqlserver.tempdb.data_file_count metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbDataFileCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverTempdbDataFileCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverTempdbPagelatchWaitsDataPoint adds a data point to sqlserver.tempdb.pagelatch_waits metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbPagelatchWaitsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverTempdbPagelatchWaits.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverTempdbTotalSizeDataPoint adds a data point to sqlserver.tempdb.total_size metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbTotalSizeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverTempdbTotalSize.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverThreadpoolCurrentTasksDataPoint adds a data point to sqlserver.threadpool.current_tasks metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolCurrentTasksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverThreadpoolCurrentTasks.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverThreadpoolMaxWorkersDataPoint adds a data point to sqlserver.threadpool.max_workers metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolMaxWorkersDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverThreadpoolMaxWorkers.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverThreadpoolRunnableTasksDataPoint adds a data point to sqlserver.threadpool.runnable_tasks metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolRunnableTasksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverThreadpoolRunnableTasks.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverThreadpoolRunningWorkersDataPoint adds a data point to sqlserver.threadpool.running_workers metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolRunningWorkersDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverThreadpoolRunningWorkers.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverThreadpoolUtilizationDataPoint adds a data point to sqlserver.threadpool.utilization metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverThreadpoolUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverThreadpoolWaitingTasksDataPoint adds a data point to sqlserver.threadpool.waiting_tasks metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolWaitingTasksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverThreadpoolWaitingTasks.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverThreadpoolWorkQueueCountDataPoint adds a data point to sqlserver.threadpool.work_queue_count metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolWorkQueueCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverThreadpoolWorkQueueCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationFailedDataPoint adds a data point to sqlserver.user_connections.authentication.failed metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationFailedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsAuthenticationFailed.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationLoginsPerSecDataPoint adds a data point to sqlserver.user_connections.authentication.logins_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationLoginsPerSecDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverUserConnectionsAuthenticationLoginsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationLogoutsPerSecDataPoint adds a data point to sqlserver.user_connections.authentication.logouts_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationLogoutsPerSecDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverUserConnectionsAuthenticationLogoutsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsByStatusDataPoint adds a data point to sqlserver.user_connections.by_status metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsByStatusDataPoint(ts pcommon.Timestamp, val int64, connectionStatusAttributeValue string) {
	mb.metricSqlserverUserConnectionsByStatus.recordDataPoint(mb.startTime, ts, val, connectionStatusAttributeValue)
}

// RecordSqlserverUserConnectionsTotalDataPoint adds a data point to sqlserver.user_connections.total metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsUtilizationActiveRatioDataPoint adds a data point to sqlserver.user_connections.utilization.active_ratio metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsUtilizationActiveRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverUserConnectionsUtilizationActiveRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsUtilizationEfficiencyDataPoint adds a data point to sqlserver.user_connections.utilization.efficiency metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsUtilizationEfficiencyDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverUserConnectionsUtilizationEfficiency.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverWaitStatsLatchWaitTimeDataPoint adds a data point to sqlserver.wait_stats.latch.wait_time metric.
func (mb *MetricsBuilder) RecordSqlserverWaitStatsLatchWaitTimeDataPoint(ts pcommon.Timestamp, val int64, latchClassAttributeValue string) {
	mb.metricSqlserverWaitStatsLatchWaitTime.recordDataPoint(mb.startTime, ts, val, latchClassAttributeValue)
}

// RecordSqlserverWaitStatsLatchWaitingTasksCountDataPoint adds a data point to sqlserver.wait_stats.latch.waiting_tasks_count metric.
func (mb *MetricsBuilder) RecordSqlserverWaitStatsLatchWaitingTasksCountDataPoint(ts pcommon.Timestamp, val int64, latchClassAttributeValue string) {
	mb.metricSqlserverWaitStatsLatchWaitingTasksCount.recordDataPoint(mb.startTime, ts, val, latchClassAttributeValue)
}

// RecordSqlserverWaitStatsWaitTimeDataPoint adds a data point to sqlserver.wait_stats.wait_time metric.
func (mb *MetricsBuilder) RecordSqlserverWaitStatsWaitTimeDataPoint(ts pcommon.Timestamp, val int64, waitTypeAttributeValue string) {
	mb.metricSqlserverWaitStatsWaitTime.recordDataPoint(mb.startTime, ts, val, waitTypeAttributeValue)
}

// RecordSqlserverWaitStatsWaitingTasksCountDataPoint adds a data point to sqlserver.wait_stats.waiting_tasks_count metric.
func (mb *MetricsBuilder) RecordSqlserverWaitStatsWaitingTasksCountDataPoint(ts pcommon.Timestamp, val int64, waitTypeAttributeValue string) {
	mb.metricSqlserverWaitStatsWaitingTasksCount.recordDataPoint(mb.startTime, ts, val, waitTypeAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
