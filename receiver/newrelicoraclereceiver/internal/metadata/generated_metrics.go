// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/filter"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

var MetricsInfo = metricsInfo{
	NewrelicOracleDbActiveParallelSessions: metricInfo{
		Name: "newrelic.oracle.db.active_parallel_sessions",
	},
	NewrelicOracleDbActiveSerialSessions: metricInfo{
		Name: "newrelic.oracle.db.active_serial_sessions",
	},
	NewrelicOracleDbAverageActiveSessions: metricInfo{
		Name: "newrelic.oracle.db.average_active_sessions",
	},
	NewrelicOracleDbBackgroundCheckpointsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.background_checkpoints_per_second",
	},
	NewrelicOracleDbBackgroundCPUUsagePerSecond: metricInfo{
		Name: "newrelic.oracle.db.background_cpu_usage_per_second",
	},
	NewrelicOracleDbBackgroundTimePerSecond: metricInfo{
		Name: "newrelic.oracle.db.background_time_per_second",
	},
	NewrelicOracleDbBlockChangesPerSecond: metricInfo{
		Name: "newrelic.oracle.db.block_changes_per_second",
	},
	NewrelicOracleDbBlockChangesPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.block_changes_per_transaction",
	},
	NewrelicOracleDbBlockChangesPerUserCall: metricInfo{
		Name: "newrelic.oracle.db.block_changes_per_user_call",
	},
	NewrelicOracleDbBlockGetsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.block_gets_per_second",
	},
	NewrelicOracleDbBlockGetsPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.block_gets_per_transaction",
	},
	NewrelicOracleDbBlockGetsPerUserCall: metricInfo{
		Name: "newrelic.oracle.db.block_gets_per_user_call",
	},
	NewrelicOracleDbBranchNodeSplitsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.branch_node_splits_per_second",
	},
	NewrelicOracleDbBranchNodeSplitsPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.branch_node_splits_per_transaction",
	},
	NewrelicOracleDbCapturedUserCalls: metricInfo{
		Name: "newrelic.oracle.db.captured_user_calls",
	},
	NewrelicOracleDbConsistentReadChangesPerSecond: metricInfo{
		Name: "newrelic.oracle.db.consistent_read_changes_per_second",
	},
	NewrelicOracleDbConsistentReadChangesPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.consistent_read_changes_per_transaction",
	},
	NewrelicOracleDbConsistentReadGetsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.consistent_read_gets_per_second",
	},
	NewrelicOracleDbConsistentReadGetsPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.consistent_read_gets_per_transaction",
	},
	NewrelicOracleDbCPUTimeRatio: metricInfo{
		Name: "newrelic.oracle.db.cpu_time_ratio",
	},
	NewrelicOracleDbCPUUsagePerSecond: metricInfo{
		Name: "newrelic.oracle.db.cpu_usage_per_second",
	},
	NewrelicOracleDbCPUUsagePerTransaction: metricInfo{
		Name: "newrelic.oracle.db.cpu_usage_per_transaction",
	},
	NewrelicOracleDbCrBlocksCreatedPerSecond: metricInfo{
		Name: "newrelic.oracle.db.cr_blocks_created_per_second",
	},
	NewrelicOracleDbCrBlocksCreatedPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.cr_blocks_created_per_transaction",
	},
	NewrelicOracleDbCrUndoRecordsAppliedPerSecond: metricInfo{
		Name: "newrelic.oracle.db.cr_undo_records_applied_per_second",
	},
	NewrelicOracleDbCrUndoRecordsAppliedPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.cr_undo_records_applied_per_transaction",
	},
	NewrelicOracleDbCurrentLogons: metricInfo{
		Name: "newrelic.oracle.db.current_logons",
	},
	NewrelicOracleDbCurrentOpenCursors: metricInfo{
		Name: "newrelic.oracle.db.current_open_cursors",
	},
	NewrelicOracleDbCursorCacheHitsPerAttempts: metricInfo{
		Name: "newrelic.oracle.db.cursor_cache_hits_per_attempts",
	},
	NewrelicOracleDbDatabaseCPUTimePerSecond: metricInfo{
		Name: "newrelic.oracle.db.database_cpu_time_per_second",
	},
	NewrelicOracleDbDbwrCheckpointsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.dbwr_checkpoints_per_second",
	},
	NewrelicOracleDbEnqueueDeadlocksPerSecond: metricInfo{
		Name: "newrelic.oracle.db.enqueue_deadlocks_per_second",
	},
	NewrelicOracleDbEnqueueDeadlocksPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.enqueue_deadlocks_per_transaction",
	},
	NewrelicOracleDbEnqueueRequestsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.enqueue_requests_per_second",
	},
	NewrelicOracleDbEnqueueRequestsPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.enqueue_requests_per_transaction",
	},
	NewrelicOracleDbEnqueueTimeoutsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.enqueue_timeouts_per_second",
	},
	NewrelicOracleDbEnqueueTimeoutsPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.enqueue_timeouts_per_transaction",
	},
	NewrelicOracleDbEnqueueWaitsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.enqueue_waits_per_second",
	},
	NewrelicOracleDbEnqueueWaitsPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.enqueue_waits_per_transaction",
	},
	NewrelicOracleDbExecuteWithoutParseRatio: metricInfo{
		Name: "newrelic.oracle.db.execute_without_parse_ratio",
	},
	NewrelicOracleDbExecutionsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.executions_per_second",
	},
	NewrelicOracleDbExecutionsPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.executions_per_transaction",
	},
	NewrelicOracleDbExecutionsPerUserCall: metricInfo{
		Name: "newrelic.oracle.db.executions_per_user_call",
	},
	NewrelicOracleDbFullIndexScansPerSecond: metricInfo{
		Name: "newrelic.oracle.db.full_index_scans_per_second",
	},
	NewrelicOracleDbFullIndexScansPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.full_index_scans_per_transaction",
	},
	NewrelicOracleDbGcCrBlockReceivedPerSecond: metricInfo{
		Name: "newrelic.oracle.db.gc_cr_block_received_per_second",
	},
	NewrelicOracleDbGcCrBlockReceivedPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.gc_cr_block_received_per_transaction",
	},
	NewrelicOracleDbGcCurrentBlockReceivedPerSecond: metricInfo{
		Name: "newrelic.oracle.db.gc_current_block_received_per_second",
	},
	NewrelicOracleDbGcCurrentBlockReceivedPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.gc_current_block_received_per_transaction",
	},
	NewrelicOracleDbGlobalCacheAverageCrGetTime: metricInfo{
		Name: "newrelic.oracle.db.global_cache_average_cr_get_time",
	},
	NewrelicOracleDbGlobalCacheAverageCurrentGetTime: metricInfo{
		Name: "newrelic.oracle.db.global_cache_average_current_get_time",
	},
	NewrelicOracleDbHardParseCountPerSecond: metricInfo{
		Name: "newrelic.oracle.db.hard_parse_count_per_second",
	},
	NewrelicOracleDbHardParseCountPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.hard_parse_count_per_transaction",
	},
	NewrelicOracleDbHostCPUUsagePerSecond: metricInfo{
		Name: "newrelic.oracle.db.host_cpu_usage_per_second",
	},
	NewrelicOracleDbHostCPUUtilization: metricInfo{
		Name: "newrelic.oracle.db.host_cpu_utilization",
	},
	NewrelicOracleDbLeafNodeSplitsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.leaf_node_splits_per_second",
	},
	NewrelicOracleDbLeafNodeSplitsPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.leaf_node_splits_per_transaction",
	},
	NewrelicOracleDbLibraryCacheHitRatio: metricInfo{
		Name: "newrelic.oracle.db.library_cache_hit_ratio",
	},
	NewrelicOracleDbLibraryCacheMissRatio: metricInfo{
		Name: "newrelic.oracle.db.library_cache_miss_ratio",
	},
	NewrelicOracleDbLogicalReadsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.logical_reads_per_second",
	},
	NewrelicOracleDbLogicalReadsPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.logical_reads_per_transaction",
	},
	NewrelicOracleDbLogonsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.logons_per_second",
	},
	NewrelicOracleDbLogonsPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.logons_per_transaction",
	},
	NewrelicOracleDbLongTableScansPerSecond: metricInfo{
		Name: "newrelic.oracle.db.long_table_scans_per_second",
	},
	NewrelicOracleDbLongTableScansPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.long_table_scans_per_transaction",
	},
	NewrelicOracleDbOpenCursorsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.open_cursors_per_second",
	},
	NewrelicOracleDbOpenCursorsPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.open_cursors_per_transaction",
	},
	NewrelicOracleDbOsLoad: metricInfo{
		Name: "newrelic.oracle.db.os_load",
	},
	NewrelicOracleDbParseFailureCountPerSecond: metricInfo{
		Name: "newrelic.oracle.db.parse_failure_count_per_second",
	},
	NewrelicOracleDbParseFailureCountPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.parse_failure_count_per_transaction",
	},
	NewrelicOracleDbPgaCacheHitPercentage: metricInfo{
		Name: "newrelic.oracle.db.pga_cache_hit_percentage",
	},
	NewrelicOracleDbPhysicalReadBytesPerSecond: metricInfo{
		Name: "newrelic.oracle.db.physical_read_bytes_per_second",
	},
	NewrelicOracleDbPhysicalReadIoRequestsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.physical_read_io_requests_per_second",
	},
	NewrelicOracleDbPhysicalReadsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.physical_reads_per_second",
	},
	NewrelicOracleDbPhysicalWriteBytesPerSecond: metricInfo{
		Name: "newrelic.oracle.db.physical_write_bytes_per_second",
	},
	NewrelicOracleDbPhysicalWritesPerSecond: metricInfo{
		Name: "newrelic.oracle.db.physical_writes_per_second",
	},
	NewrelicOracleDbProcessLimitPercentage: metricInfo{
		Name: "newrelic.oracle.db.process_limit_percentage",
	},
	NewrelicOracleDbRecursiveCallsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.recursive_calls_per_second",
	},
	NewrelicOracleDbRecursiveCallsPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.recursive_calls_per_transaction",
	},
	NewrelicOracleDbRedoWritesPerSecond: metricInfo{
		Name: "newrelic.oracle.db.redo_writes_per_second",
	},
	NewrelicOracleDbRedoWritesPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.redo_writes_per_transaction",
	},
	NewrelicOracleDbResponseTimePerTransaction: metricInfo{
		Name: "newrelic.oracle.db.response_time_per_transaction",
	},
	NewrelicOracleDbRowCacheHitRatio: metricInfo{
		Name: "newrelic.oracle.db.row_cache_hit_ratio",
	},
	NewrelicOracleDbRowCacheMissRatio: metricInfo{
		Name: "newrelic.oracle.db.row_cache_miss_ratio",
	},
	NewrelicOracleDbRowsPerSort: metricInfo{
		Name: "newrelic.oracle.db.rows_per_sort",
	},
	NewrelicOracleDbSessionCount: metricInfo{
		Name: "newrelic.oracle.db.session_count",
	},
	NewrelicOracleDbSessionLimitPercentage: metricInfo{
		Name: "newrelic.oracle.db.session_limit_percentage",
	},
	NewrelicOracleDbSharedPoolFreePercentage: metricInfo{
		Name: "newrelic.oracle.db.shared_pool_free_percentage",
	},
	NewrelicOracleDbSoftParseRatio: metricInfo{
		Name: "newrelic.oracle.db.soft_parse_ratio",
	},
	NewrelicOracleDbSortsPerUserCall: metricInfo{
		Name: "newrelic.oracle.db.sorts_per_user_call",
	},
	NewrelicOracleDbSQLServiceResponseTime: metricInfo{
		Name: "newrelic.oracle.db.sql_service_response_time",
	},
	NewrelicOracleDbStreamsPoolUsagePercentage: metricInfo{
		Name: "newrelic.oracle.db.streams_pool_usage_percentage",
	},
	NewrelicOracleDbTableScansPerUserCall: metricInfo{
		Name: "newrelic.oracle.db.table_scans_per_user_call",
	},
	NewrelicOracleDbTotalIndexScansPerSecond: metricInfo{
		Name: "newrelic.oracle.db.total_index_scans_per_second",
	},
	NewrelicOracleDbTotalIndexScansPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.total_index_scans_per_transaction",
	},
	NewrelicOracleDbTotalParseCountPerSecond: metricInfo{
		Name: "newrelic.oracle.db.total_parse_count_per_second",
	},
	NewrelicOracleDbTotalParseCountPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.total_parse_count_per_transaction",
	},
	NewrelicOracleDbTotalTableScansPerSecond: metricInfo{
		Name: "newrelic.oracle.db.total_table_scans_per_second",
	},
	NewrelicOracleDbTotalTableScansPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.total_table_scans_per_transaction",
	},
	NewrelicOracleDbTransactionsPerLogon: metricInfo{
		Name: "newrelic.oracle.db.transactions_per_logon",
	},
	NewrelicOracleDbUserCallsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.user_calls_per_second",
	},
	NewrelicOracleDbUserCallsPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.user_calls_per_transaction",
	},
	NewrelicOracleDbUserCallsRatio: metricInfo{
		Name: "newrelic.oracle.db.user_calls_ratio",
	},
	NewrelicOracleDbUserCommitsPerSecond: metricInfo{
		Name: "newrelic.oracle.db.user_commits_per_second",
	},
	NewrelicOracleDbUserCommitsPercentage: metricInfo{
		Name: "newrelic.oracle.db.user_commits_percentage",
	},
	NewrelicOracleDbUserLimitPercentage: metricInfo{
		Name: "newrelic.oracle.db.user_limit_percentage",
	},
	NewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond: metricInfo{
		Name: "newrelic.oracle.db.user_rollback_undo_records_applied_per_second",
	},
	NewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction: metricInfo{
		Name: "newrelic.oracle.db.user_rollback_undo_records_applied_per_transaction",
	},
	NewrelicOracleDbUserRollbacksPerSecond: metricInfo{
		Name: "newrelic.oracle.db.user_rollbacks_per_second",
	},
	NewrelicOracleDbUserRollbacksPercentage: metricInfo{
		Name: "newrelic.oracle.db.user_rollbacks_percentage",
	},
	NewrelicOracleDbWaitTimeRatio: metricInfo{
		Name: "newrelic.oracle.db.wait_time_ratio",
	},
	NewrelicOracleDiskBlocksRead: metricInfo{
		Name: "newrelic.oracle.disk.blocks_read",
	},
	NewrelicOracleDiskBlocksWritten: metricInfo{
		Name: "newrelic.oracle.disk.blocks_written",
	},
	NewrelicOracleDiskLogicalReadsPerUserCall: metricInfo{
		Name: "newrelic.oracle.disk.logical_reads_per_user_call",
	},
	NewrelicOracleDiskPhysicalLobsReadsPerSecond: metricInfo{
		Name: "newrelic.oracle.disk.physical_lobs_reads_per_second",
	},
	NewrelicOracleDiskPhysicalLobsWritesPerSecond: metricInfo{
		Name: "newrelic.oracle.disk.physical_lobs_writes_per_second",
	},
	NewrelicOracleDiskPhysicalReadBytesPerSecond: metricInfo{
		Name: "newrelic.oracle.disk.physical_read_bytes_per_second",
	},
	NewrelicOracleDiskPhysicalReadIoRequestsPerSecond: metricInfo{
		Name: "newrelic.oracle.disk.physical_read_io_requests_per_second",
	},
	NewrelicOracleDiskPhysicalReadsPerSecond: metricInfo{
		Name: "newrelic.oracle.disk.physical_reads_per_second",
	},
	NewrelicOracleDiskPhysicalWriteBytesPerSecond: metricInfo{
		Name: "newrelic.oracle.disk.physical_write_bytes_per_second",
	},
	NewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond: metricInfo{
		Name: "newrelic.oracle.disk.physical_write_total_io_requests_per_second",
	},
	NewrelicOracleDiskPhysicalWritesPerSecond: metricInfo{
		Name: "newrelic.oracle.disk.physical_writes_per_second",
	},
	NewrelicOracleDiskReadTimeMilliseconds: metricInfo{
		Name: "newrelic.oracle.disk.read_time_milliseconds",
	},
	NewrelicOracleDiskReads: metricInfo{
		Name: "newrelic.oracle.disk.reads",
	},
	NewrelicOracleDiskSortPerSecond: metricInfo{
		Name: "newrelic.oracle.disk.sort_per_second",
	},
	NewrelicOracleDiskSortPerTransaction: metricInfo{
		Name: "newrelic.oracle.disk.sort_per_transaction",
	},
	NewrelicOracleDiskTempSpaceUsedBytes: metricInfo{
		Name: "newrelic.oracle.disk.temp_space_used_bytes",
	},
	NewrelicOracleDiskWriteTimeMilliseconds: metricInfo{
		Name: "newrelic.oracle.disk.write_time_milliseconds",
	},
	NewrelicOracleDiskWrites: metricInfo{
		Name: "newrelic.oracle.disk.writes",
	},
	NewrelicOracleLockedAccounts: metricInfo{
		Name: "newrelic.oracle.locked_accounts",
	},
	NewrelicOracleLongRunningQueries: metricInfo{
		Name: "newrelic.oracle.long_running_queries",
	},
	NewrelicOracleMemoryBufferCacheHitRatio: metricInfo{
		Name: "newrelic.oracle.memory.buffer_cache_hit_ratio",
	},
	NewrelicOracleMemoryGlobalCacheBlocksCorrupted: metricInfo{
		Name: "newrelic.oracle.memory.global_cache_blocks_corrupted",
	},
	NewrelicOracleMemoryGlobalCacheBlocksLost: metricInfo{
		Name: "newrelic.oracle.memory.global_cache_blocks_lost",
	},
	NewrelicOracleMemoryPgaAllocatedBytes: metricInfo{
		Name: "newrelic.oracle.memory.pga_allocated_bytes",
	},
	NewrelicOracleMemoryPgaFreeableBytes: metricInfo{
		Name: "newrelic.oracle.memory.pga_freeable_bytes",
	},
	NewrelicOracleMemoryPgaInUseBytes: metricInfo{
		Name: "newrelic.oracle.memory.pga_in_use_bytes",
	},
	NewrelicOracleMemoryPgaMaxSizeBytes: metricInfo{
		Name: "newrelic.oracle.memory.pga_max_size_bytes",
	},
	NewrelicOracleMemoryRedoAllocationHitRatio: metricInfo{
		Name: "newrelic.oracle.memory.redo_allocation_hit_ratio",
	},
	NewrelicOracleMemoryRedoGeneratedBytesPerSecond: metricInfo{
		Name: "newrelic.oracle.memory.redo_generated_bytes_per_second",
	},
	NewrelicOracleMemoryRedoGeneratedBytesPerTransaction: metricInfo{
		Name: "newrelic.oracle.memory.redo_generated_bytes_per_transaction",
	},
	NewrelicOracleMemorySortsRatio: metricInfo{
		Name: "newrelic.oracle.memory.sorts_ratio",
	},
	NewrelicOracleNetworkIoMegabytesPerSecond: metricInfo{
		Name: "newrelic.oracle.network.io_megabytes_per_second",
	},
	NewrelicOracleNetworkIoRequestsPerSecond: metricInfo{
		Name: "newrelic.oracle.network.io_requests_per_second",
	},
	NewrelicOracleNetworkTrafficBytesPerSecond: metricInfo{
		Name: "newrelic.oracle.network.traffic_bytes_per_second",
	},
	NewrelicOracleQueryPhysicalLobsReadsPerTransaction: metricInfo{
		Name: "newrelic.oracle.query.physical_lobs_reads_per_transaction",
	},
	NewrelicOracleQueryPhysicalLobsWritesPerTransaction: metricInfo{
		Name: "newrelic.oracle.query.physical_lobs_writes_per_transaction",
	},
	NewrelicOracleQueryPhysicalReadsPerTransaction: metricInfo{
		Name: "newrelic.oracle.query.physical_reads_per_transaction",
	},
	NewrelicOracleQueryPhysicalWritesPerTransaction: metricInfo{
		Name: "newrelic.oracle.query.physical_writes_per_transaction",
	},
	NewrelicOracleQueryTransactionsPerSecond: metricInfo{
		Name: "newrelic.oracle.query.transactions_per_second",
	},
	NewrelicOracleRedoLogFileSwitch: metricInfo{
		Name: "newrelic.oracle.redo_log.file_switch",
	},
	NewrelicOracleRedoLogFileSwitchArchivingNeeded: metricInfo{
		Name: "newrelic.oracle.redo_log.file_switch_archiving_needed",
	},
	NewrelicOracleRedoLogFileSwitchCheckpointIncomplete: metricInfo{
		Name: "newrelic.oracle.redo_log.file_switch_checkpoint_incomplete",
	},
	NewrelicOracleRedoLogWaits: metricInfo{
		Name: "newrelic.oracle.redo_log.waits",
	},
	NewrelicOracleRollbackSegmentsGets: metricInfo{
		Name: "newrelic.oracle.rollback_segments.gets",
	},
	NewrelicOracleRollbackSegmentsRatioWait: metricInfo{
		Name: "newrelic.oracle.rollback_segments.ratio_wait",
	},
	NewrelicOracleRollbackSegmentsWaits: metricInfo{
		Name: "newrelic.oracle.rollback_segments.waits",
	},
	NewrelicOracleSgaBufferBusyWaits: metricInfo{
		Name: "newrelic.oracle.sga.buffer_busy_waits",
	},
	NewrelicOracleSgaFixedSizeBytes: metricInfo{
		Name: "newrelic.oracle.sga.fixed_size_bytes",
	},
	NewrelicOracleSgaFreeBufferInspected: metricInfo{
		Name: "newrelic.oracle.sga.free_buffer_inspected",
	},
	NewrelicOracleSgaFreeBufferWaits: metricInfo{
		Name: "newrelic.oracle.sga.free_buffer_waits",
	},
	NewrelicOracleSgaHitRatio: metricInfo{
		Name: "newrelic.oracle.sga.hit_ratio",
	},
	NewrelicOracleSgaLogBufferAllocationRetriesRatio: metricInfo{
		Name: "newrelic.oracle.sga.log_buffer_allocation_retries_ratio",
	},
	NewrelicOracleSgaLogBufferRedoAllocationRetries: metricInfo{
		Name: "newrelic.oracle.sga.log_buffer_redo_allocation_retries",
	},
	NewrelicOracleSgaLogBufferRedoEntries: metricInfo{
		Name: "newrelic.oracle.sga.log_buffer_redo_entries",
	},
	NewrelicOracleSgaLogBufferSpaceWaits: metricInfo{
		Name: "newrelic.oracle.sga.log_buffer_space_waits",
	},
	NewrelicOracleSgaRedoBuffersBytes: metricInfo{
		Name: "newrelic.oracle.sga.redo_buffers_bytes",
	},
	NewrelicOracleSgaSharedPoolDictCacheMissRatio: metricInfo{
		Name: "newrelic.oracle.sga.shared_pool_dict_cache_miss_ratio",
	},
	NewrelicOracleSgaSharedPoolLibraryCacheHitRatio: metricInfo{
		Name: "newrelic.oracle.sga.shared_pool_library_cache_hit_ratio",
	},
	NewrelicOracleSgaSharedPoolLibraryCacheReloadRatio: metricInfo{
		Name: "newrelic.oracle.sga.shared_pool_library_cache_reload_ratio",
	},
	NewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes: metricInfo{
		Name: "newrelic.oracle.sga.shared_pool_library_cache_shareable_memory_per_statement_bytes",
	},
	NewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes: metricInfo{
		Name: "newrelic.oracle.sga.shared_pool_library_cache_shareable_memory_per_user_bytes",
	},
	NewrelicOracleSgaUgaTotalMemoryBytes: metricInfo{
		Name: "newrelic.oracle.sga.uga_total_memory_bytes",
	},
	NewrelicOracleSortsDiskBytes: metricInfo{
		Name: "newrelic.oracle.sorts.disk_bytes",
	},
	NewrelicOracleSortsMemoryBytes: metricInfo{
		Name: "newrelic.oracle.sorts.memory_bytes",
	},
	NewrelicOracleTablespaceIsOffline: metricInfo{
		Name: "newrelic.oracle.tablespace.is_offline",
	},
	NewrelicOracleTablespaceOfflineCdbDatafiles: metricInfo{
		Name: "newrelic.oracle.tablespace.offline_cdb_datafiles",
	},
	NewrelicOracleTablespaceOfflinePdbDatafiles: metricInfo{
		Name: "newrelic.oracle.tablespace.offline_pdb_datafiles",
	},
	NewrelicOracleTablespacePdbDatafilesNonWrite: metricInfo{
		Name: "newrelic.oracle.tablespace.pdb_datafiles_non_write",
	},
	NewrelicOracleTablespaceSpaceConsumedBytes: metricInfo{
		Name: "newrelic.oracle.tablespace.space_consumed_bytes",
	},
	NewrelicOracleTablespaceSpaceReservedBytes: metricInfo{
		Name: "newrelic.oracle.tablespace.space_reserved_bytes",
	},
	NewrelicOracleTablespaceSpaceUsedPercentage: metricInfo{
		Name: "newrelic.oracle.tablespace.space_used_percentage",
	},
}

type metricsInfo struct {
	NewrelicOracleDbActiveParallelSessions                                  metricInfo
	NewrelicOracleDbActiveSerialSessions                                    metricInfo
	NewrelicOracleDbAverageActiveSessions                                   metricInfo
	NewrelicOracleDbBackgroundCheckpointsPerSecond                          metricInfo
	NewrelicOracleDbBackgroundCPUUsagePerSecond                             metricInfo
	NewrelicOracleDbBackgroundTimePerSecond                                 metricInfo
	NewrelicOracleDbBlockChangesPerSecond                                   metricInfo
	NewrelicOracleDbBlockChangesPerTransaction                              metricInfo
	NewrelicOracleDbBlockChangesPerUserCall                                 metricInfo
	NewrelicOracleDbBlockGetsPerSecond                                      metricInfo
	NewrelicOracleDbBlockGetsPerTransaction                                 metricInfo
	NewrelicOracleDbBlockGetsPerUserCall                                    metricInfo
	NewrelicOracleDbBranchNodeSplitsPerSecond                               metricInfo
	NewrelicOracleDbBranchNodeSplitsPerTransaction                          metricInfo
	NewrelicOracleDbCapturedUserCalls                                       metricInfo
	NewrelicOracleDbConsistentReadChangesPerSecond                          metricInfo
	NewrelicOracleDbConsistentReadChangesPerTransaction                     metricInfo
	NewrelicOracleDbConsistentReadGetsPerSecond                             metricInfo
	NewrelicOracleDbConsistentReadGetsPerTransaction                        metricInfo
	NewrelicOracleDbCPUTimeRatio                                            metricInfo
	NewrelicOracleDbCPUUsagePerSecond                                       metricInfo
	NewrelicOracleDbCPUUsagePerTransaction                                  metricInfo
	NewrelicOracleDbCrBlocksCreatedPerSecond                                metricInfo
	NewrelicOracleDbCrBlocksCreatedPerTransaction                           metricInfo
	NewrelicOracleDbCrUndoRecordsAppliedPerSecond                           metricInfo
	NewrelicOracleDbCrUndoRecordsAppliedPerTransaction                      metricInfo
	NewrelicOracleDbCurrentLogons                                           metricInfo
	NewrelicOracleDbCurrentOpenCursors                                      metricInfo
	NewrelicOracleDbCursorCacheHitsPerAttempts                              metricInfo
	NewrelicOracleDbDatabaseCPUTimePerSecond                                metricInfo
	NewrelicOracleDbDbwrCheckpointsPerSecond                                metricInfo
	NewrelicOracleDbEnqueueDeadlocksPerSecond                               metricInfo
	NewrelicOracleDbEnqueueDeadlocksPerTransaction                          metricInfo
	NewrelicOracleDbEnqueueRequestsPerSecond                                metricInfo
	NewrelicOracleDbEnqueueRequestsPerTransaction                           metricInfo
	NewrelicOracleDbEnqueueTimeoutsPerSecond                                metricInfo
	NewrelicOracleDbEnqueueTimeoutsPerTransaction                           metricInfo
	NewrelicOracleDbEnqueueWaitsPerSecond                                   metricInfo
	NewrelicOracleDbEnqueueWaitsPerTransaction                              metricInfo
	NewrelicOracleDbExecuteWithoutParseRatio                                metricInfo
	NewrelicOracleDbExecutionsPerSecond                                     metricInfo
	NewrelicOracleDbExecutionsPerTransaction                                metricInfo
	NewrelicOracleDbExecutionsPerUserCall                                   metricInfo
	NewrelicOracleDbFullIndexScansPerSecond                                 metricInfo
	NewrelicOracleDbFullIndexScansPerTransaction                            metricInfo
	NewrelicOracleDbGcCrBlockReceivedPerSecond                              metricInfo
	NewrelicOracleDbGcCrBlockReceivedPerTransaction                         metricInfo
	NewrelicOracleDbGcCurrentBlockReceivedPerSecond                         metricInfo
	NewrelicOracleDbGcCurrentBlockReceivedPerTransaction                    metricInfo
	NewrelicOracleDbGlobalCacheAverageCrGetTime                             metricInfo
	NewrelicOracleDbGlobalCacheAverageCurrentGetTime                        metricInfo
	NewrelicOracleDbHardParseCountPerSecond                                 metricInfo
	NewrelicOracleDbHardParseCountPerTransaction                            metricInfo
	NewrelicOracleDbHostCPUUsagePerSecond                                   metricInfo
	NewrelicOracleDbHostCPUUtilization                                      metricInfo
	NewrelicOracleDbLeafNodeSplitsPerSecond                                 metricInfo
	NewrelicOracleDbLeafNodeSplitsPerTransaction                            metricInfo
	NewrelicOracleDbLibraryCacheHitRatio                                    metricInfo
	NewrelicOracleDbLibraryCacheMissRatio                                   metricInfo
	NewrelicOracleDbLogicalReadsPerSecond                                   metricInfo
	NewrelicOracleDbLogicalReadsPerTransaction                              metricInfo
	NewrelicOracleDbLogonsPerSecond                                         metricInfo
	NewrelicOracleDbLogonsPerTransaction                                    metricInfo
	NewrelicOracleDbLongTableScansPerSecond                                 metricInfo
	NewrelicOracleDbLongTableScansPerTransaction                            metricInfo
	NewrelicOracleDbOpenCursorsPerSecond                                    metricInfo
	NewrelicOracleDbOpenCursorsPerTransaction                               metricInfo
	NewrelicOracleDbOsLoad                                                  metricInfo
	NewrelicOracleDbParseFailureCountPerSecond                              metricInfo
	NewrelicOracleDbParseFailureCountPerTransaction                         metricInfo
	NewrelicOracleDbPgaCacheHitPercentage                                   metricInfo
	NewrelicOracleDbPhysicalReadBytesPerSecond                              metricInfo
	NewrelicOracleDbPhysicalReadIoRequestsPerSecond                         metricInfo
	NewrelicOracleDbPhysicalReadsPerSecond                                  metricInfo
	NewrelicOracleDbPhysicalWriteBytesPerSecond                             metricInfo
	NewrelicOracleDbPhysicalWritesPerSecond                                 metricInfo
	NewrelicOracleDbProcessLimitPercentage                                  metricInfo
	NewrelicOracleDbRecursiveCallsPerSecond                                 metricInfo
	NewrelicOracleDbRecursiveCallsPerTransaction                            metricInfo
	NewrelicOracleDbRedoWritesPerSecond                                     metricInfo
	NewrelicOracleDbRedoWritesPerTransaction                                metricInfo
	NewrelicOracleDbResponseTimePerTransaction                              metricInfo
	NewrelicOracleDbRowCacheHitRatio                                        metricInfo
	NewrelicOracleDbRowCacheMissRatio                                       metricInfo
	NewrelicOracleDbRowsPerSort                                             metricInfo
	NewrelicOracleDbSessionCount                                            metricInfo
	NewrelicOracleDbSessionLimitPercentage                                  metricInfo
	NewrelicOracleDbSharedPoolFreePercentage                                metricInfo
	NewrelicOracleDbSoftParseRatio                                          metricInfo
	NewrelicOracleDbSortsPerUserCall                                        metricInfo
	NewrelicOracleDbSQLServiceResponseTime                                  metricInfo
	NewrelicOracleDbStreamsPoolUsagePercentage                              metricInfo
	NewrelicOracleDbTableScansPerUserCall                                   metricInfo
	NewrelicOracleDbTotalIndexScansPerSecond                                metricInfo
	NewrelicOracleDbTotalIndexScansPerTransaction                           metricInfo
	NewrelicOracleDbTotalParseCountPerSecond                                metricInfo
	NewrelicOracleDbTotalParseCountPerTransaction                           metricInfo
	NewrelicOracleDbTotalTableScansPerSecond                                metricInfo
	NewrelicOracleDbTotalTableScansPerTransaction                           metricInfo
	NewrelicOracleDbTransactionsPerLogon                                    metricInfo
	NewrelicOracleDbUserCallsPerSecond                                      metricInfo
	NewrelicOracleDbUserCallsPerTransaction                                 metricInfo
	NewrelicOracleDbUserCallsRatio                                          metricInfo
	NewrelicOracleDbUserCommitsPerSecond                                    metricInfo
	NewrelicOracleDbUserCommitsPercentage                                   metricInfo
	NewrelicOracleDbUserLimitPercentage                                     metricInfo
	NewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond                 metricInfo
	NewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction            metricInfo
	NewrelicOracleDbUserRollbacksPerSecond                                  metricInfo
	NewrelicOracleDbUserRollbacksPercentage                                 metricInfo
	NewrelicOracleDbWaitTimeRatio                                           metricInfo
	NewrelicOracleDiskBlocksRead                                            metricInfo
	NewrelicOracleDiskBlocksWritten                                         metricInfo
	NewrelicOracleDiskLogicalReadsPerUserCall                               metricInfo
	NewrelicOracleDiskPhysicalLobsReadsPerSecond                            metricInfo
	NewrelicOracleDiskPhysicalLobsWritesPerSecond                           metricInfo
	NewrelicOracleDiskPhysicalReadBytesPerSecond                            metricInfo
	NewrelicOracleDiskPhysicalReadIoRequestsPerSecond                       metricInfo
	NewrelicOracleDiskPhysicalReadsPerSecond                                metricInfo
	NewrelicOracleDiskPhysicalWriteBytesPerSecond                           metricInfo
	NewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond                 metricInfo
	NewrelicOracleDiskPhysicalWritesPerSecond                               metricInfo
	NewrelicOracleDiskReadTimeMilliseconds                                  metricInfo
	NewrelicOracleDiskReads                                                 metricInfo
	NewrelicOracleDiskSortPerSecond                                         metricInfo
	NewrelicOracleDiskSortPerTransaction                                    metricInfo
	NewrelicOracleDiskTempSpaceUsedBytes                                    metricInfo
	NewrelicOracleDiskWriteTimeMilliseconds                                 metricInfo
	NewrelicOracleDiskWrites                                                metricInfo
	NewrelicOracleLockedAccounts                                            metricInfo
	NewrelicOracleLongRunningQueries                                        metricInfo
	NewrelicOracleMemoryBufferCacheHitRatio                                 metricInfo
	NewrelicOracleMemoryGlobalCacheBlocksCorrupted                          metricInfo
	NewrelicOracleMemoryGlobalCacheBlocksLost                               metricInfo
	NewrelicOracleMemoryPgaAllocatedBytes                                   metricInfo
	NewrelicOracleMemoryPgaFreeableBytes                                    metricInfo
	NewrelicOracleMemoryPgaInUseBytes                                       metricInfo
	NewrelicOracleMemoryPgaMaxSizeBytes                                     metricInfo
	NewrelicOracleMemoryRedoAllocationHitRatio                              metricInfo
	NewrelicOracleMemoryRedoGeneratedBytesPerSecond                         metricInfo
	NewrelicOracleMemoryRedoGeneratedBytesPerTransaction                    metricInfo
	NewrelicOracleMemorySortsRatio                                          metricInfo
	NewrelicOracleNetworkIoMegabytesPerSecond                               metricInfo
	NewrelicOracleNetworkIoRequestsPerSecond                                metricInfo
	NewrelicOracleNetworkTrafficBytesPerSecond                              metricInfo
	NewrelicOracleQueryPhysicalLobsReadsPerTransaction                      metricInfo
	NewrelicOracleQueryPhysicalLobsWritesPerTransaction                     metricInfo
	NewrelicOracleQueryPhysicalReadsPerTransaction                          metricInfo
	NewrelicOracleQueryPhysicalWritesPerTransaction                         metricInfo
	NewrelicOracleQueryTransactionsPerSecond                                metricInfo
	NewrelicOracleRedoLogFileSwitch                                         metricInfo
	NewrelicOracleRedoLogFileSwitchArchivingNeeded                          metricInfo
	NewrelicOracleRedoLogFileSwitchCheckpointIncomplete                     metricInfo
	NewrelicOracleRedoLogWaits                                              metricInfo
	NewrelicOracleRollbackSegmentsGets                                      metricInfo
	NewrelicOracleRollbackSegmentsRatioWait                                 metricInfo
	NewrelicOracleRollbackSegmentsWaits                                     metricInfo
	NewrelicOracleSgaBufferBusyWaits                                        metricInfo
	NewrelicOracleSgaFixedSizeBytes                                         metricInfo
	NewrelicOracleSgaFreeBufferInspected                                    metricInfo
	NewrelicOracleSgaFreeBufferWaits                                        metricInfo
	NewrelicOracleSgaHitRatio                                               metricInfo
	NewrelicOracleSgaLogBufferAllocationRetriesRatio                        metricInfo
	NewrelicOracleSgaLogBufferRedoAllocationRetries                         metricInfo
	NewrelicOracleSgaLogBufferRedoEntries                                   metricInfo
	NewrelicOracleSgaLogBufferSpaceWaits                                    metricInfo
	NewrelicOracleSgaRedoBuffersBytes                                       metricInfo
	NewrelicOracleSgaSharedPoolDictCacheMissRatio                           metricInfo
	NewrelicOracleSgaSharedPoolLibraryCacheHitRatio                         metricInfo
	NewrelicOracleSgaSharedPoolLibraryCacheReloadRatio                      metricInfo
	NewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes metricInfo
	NewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes      metricInfo
	NewrelicOracleSgaUgaTotalMemoryBytes                                    metricInfo
	NewrelicOracleSortsDiskBytes                                            metricInfo
	NewrelicOracleSortsMemoryBytes                                          metricInfo
	NewrelicOracleTablespaceIsOffline                                       metricInfo
	NewrelicOracleTablespaceOfflineCdbDatafiles                             metricInfo
	NewrelicOracleTablespaceOfflinePdbDatafiles                             metricInfo
	NewrelicOracleTablespacePdbDatafilesNonWrite                            metricInfo
	NewrelicOracleTablespaceSpaceConsumedBytes                              metricInfo
	NewrelicOracleTablespaceSpaceReservedBytes                              metricInfo
	NewrelicOracleTablespaceSpaceUsedPercentage                             metricInfo
}

type metricInfo struct {
	Name string
}

type metricNewrelicOracleDbActiveParallelSessions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.active_parallel_sessions metric with initial data.
func (m *metricNewrelicOracleDbActiveParallelSessions) init() {
	m.data.SetName("newrelic.oracle.db.active_parallel_sessions")
	m.data.SetDescription("Active parallel sessions")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbActiveParallelSessions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbActiveParallelSessions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbActiveParallelSessions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbActiveParallelSessions(cfg MetricConfig) metricNewrelicOracleDbActiveParallelSessions {
	m := metricNewrelicOracleDbActiveParallelSessions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbActiveSerialSessions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.active_serial_sessions metric with initial data.
func (m *metricNewrelicOracleDbActiveSerialSessions) init() {
	m.data.SetName("newrelic.oracle.db.active_serial_sessions")
	m.data.SetDescription("Active serial sessions")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbActiveSerialSessions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbActiveSerialSessions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbActiveSerialSessions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbActiveSerialSessions(cfg MetricConfig) metricNewrelicOracleDbActiveSerialSessions {
	m := metricNewrelicOracleDbActiveSerialSessions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbAverageActiveSessions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.average_active_sessions metric with initial data.
func (m *metricNewrelicOracleDbAverageActiveSessions) init() {
	m.data.SetName("newrelic.oracle.db.average_active_sessions")
	m.data.SetDescription("Average active sessions")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbAverageActiveSessions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbAverageActiveSessions) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbAverageActiveSessions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbAverageActiveSessions(cfg MetricConfig) metricNewrelicOracleDbAverageActiveSessions {
	m := metricNewrelicOracleDbAverageActiveSessions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbBackgroundCheckpointsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.background_checkpoints_per_second metric with initial data.
func (m *metricNewrelicOracleDbBackgroundCheckpointsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.background_checkpoints_per_second")
	m.data.SetDescription("Background checkpoints per second")
	m.data.SetUnit("{checkpoints}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbBackgroundCheckpointsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbBackgroundCheckpointsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbBackgroundCheckpointsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbBackgroundCheckpointsPerSecond(cfg MetricConfig) metricNewrelicOracleDbBackgroundCheckpointsPerSecond {
	m := metricNewrelicOracleDbBackgroundCheckpointsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbBackgroundCPUUsagePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.background_cpu_usage_per_second metric with initial data.
func (m *metricNewrelicOracleDbBackgroundCPUUsagePerSecond) init() {
	m.data.SetName("newrelic.oracle.db.background_cpu_usage_per_second")
	m.data.SetDescription("Background CPU usage per second")
	m.data.SetUnit("{cpu}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbBackgroundCPUUsagePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbBackgroundCPUUsagePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbBackgroundCPUUsagePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbBackgroundCPUUsagePerSecond(cfg MetricConfig) metricNewrelicOracleDbBackgroundCPUUsagePerSecond {
	m := metricNewrelicOracleDbBackgroundCPUUsagePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbBackgroundTimePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.background_time_per_second metric with initial data.
func (m *metricNewrelicOracleDbBackgroundTimePerSecond) init() {
	m.data.SetName("newrelic.oracle.db.background_time_per_second")
	m.data.SetDescription("Background time per second")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbBackgroundTimePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbBackgroundTimePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbBackgroundTimePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbBackgroundTimePerSecond(cfg MetricConfig) metricNewrelicOracleDbBackgroundTimePerSecond {
	m := metricNewrelicOracleDbBackgroundTimePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbBlockChangesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.block_changes_per_second metric with initial data.
func (m *metricNewrelicOracleDbBlockChangesPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.block_changes_per_second")
	m.data.SetDescription("DB block changes per second")
	m.data.SetUnit("{changes}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbBlockChangesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbBlockChangesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbBlockChangesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbBlockChangesPerSecond(cfg MetricConfig) metricNewrelicOracleDbBlockChangesPerSecond {
	m := metricNewrelicOracleDbBlockChangesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbBlockChangesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.block_changes_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbBlockChangesPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.block_changes_per_transaction")
	m.data.SetDescription("DB block changes per transaction")
	m.data.SetUnit("{changes}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbBlockChangesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbBlockChangesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbBlockChangesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbBlockChangesPerTransaction(cfg MetricConfig) metricNewrelicOracleDbBlockChangesPerTransaction {
	m := metricNewrelicOracleDbBlockChangesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbBlockChangesPerUserCall struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.block_changes_per_user_call metric with initial data.
func (m *metricNewrelicOracleDbBlockChangesPerUserCall) init() {
	m.data.SetName("newrelic.oracle.db.block_changes_per_user_call")
	m.data.SetDescription("DB block changes per user call")
	m.data.SetUnit("{changes}/{call}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbBlockChangesPerUserCall) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbBlockChangesPerUserCall) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbBlockChangesPerUserCall) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbBlockChangesPerUserCall(cfg MetricConfig) metricNewrelicOracleDbBlockChangesPerUserCall {
	m := metricNewrelicOracleDbBlockChangesPerUserCall{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbBlockGetsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.block_gets_per_second metric with initial data.
func (m *metricNewrelicOracleDbBlockGetsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.block_gets_per_second")
	m.data.SetDescription("DB block gets per second")
	m.data.SetUnit("{gets}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbBlockGetsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbBlockGetsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbBlockGetsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbBlockGetsPerSecond(cfg MetricConfig) metricNewrelicOracleDbBlockGetsPerSecond {
	m := metricNewrelicOracleDbBlockGetsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbBlockGetsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.block_gets_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbBlockGetsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.block_gets_per_transaction")
	m.data.SetDescription("DB block gets per transaction")
	m.data.SetUnit("{gets}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbBlockGetsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbBlockGetsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbBlockGetsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbBlockGetsPerTransaction(cfg MetricConfig) metricNewrelicOracleDbBlockGetsPerTransaction {
	m := metricNewrelicOracleDbBlockGetsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbBlockGetsPerUserCall struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.block_gets_per_user_call metric with initial data.
func (m *metricNewrelicOracleDbBlockGetsPerUserCall) init() {
	m.data.SetName("newrelic.oracle.db.block_gets_per_user_call")
	m.data.SetDescription("DB block gets per user call")
	m.data.SetUnit("{gets}/{call}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbBlockGetsPerUserCall) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbBlockGetsPerUserCall) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbBlockGetsPerUserCall) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbBlockGetsPerUserCall(cfg MetricConfig) metricNewrelicOracleDbBlockGetsPerUserCall {
	m := metricNewrelicOracleDbBlockGetsPerUserCall{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbBranchNodeSplitsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.branch_node_splits_per_second metric with initial data.
func (m *metricNewrelicOracleDbBranchNodeSplitsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.branch_node_splits_per_second")
	m.data.SetDescription("Branch node splits per second")
	m.data.SetUnit("{splits}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbBranchNodeSplitsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbBranchNodeSplitsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbBranchNodeSplitsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbBranchNodeSplitsPerSecond(cfg MetricConfig) metricNewrelicOracleDbBranchNodeSplitsPerSecond {
	m := metricNewrelicOracleDbBranchNodeSplitsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbBranchNodeSplitsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.branch_node_splits_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbBranchNodeSplitsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.branch_node_splits_per_transaction")
	m.data.SetDescription("Branch node splits per transaction")
	m.data.SetUnit("{splits}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbBranchNodeSplitsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbBranchNodeSplitsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbBranchNodeSplitsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbBranchNodeSplitsPerTransaction(cfg MetricConfig) metricNewrelicOracleDbBranchNodeSplitsPerTransaction {
	m := metricNewrelicOracleDbBranchNodeSplitsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbCapturedUserCalls struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.captured_user_calls metric with initial data.
func (m *metricNewrelicOracleDbCapturedUserCalls) init() {
	m.data.SetName("newrelic.oracle.db.captured_user_calls")
	m.data.SetDescription("Captured user calls")
	m.data.SetUnit("{calls}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbCapturedUserCalls) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbCapturedUserCalls) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbCapturedUserCalls) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbCapturedUserCalls(cfg MetricConfig) metricNewrelicOracleDbCapturedUserCalls {
	m := metricNewrelicOracleDbCapturedUserCalls{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbConsistentReadChangesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.consistent_read_changes_per_second metric with initial data.
func (m *metricNewrelicOracleDbConsistentReadChangesPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.consistent_read_changes_per_second")
	m.data.SetDescription("Consistent read changes per second")
	m.data.SetUnit("{changes}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbConsistentReadChangesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbConsistentReadChangesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbConsistentReadChangesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbConsistentReadChangesPerSecond(cfg MetricConfig) metricNewrelicOracleDbConsistentReadChangesPerSecond {
	m := metricNewrelicOracleDbConsistentReadChangesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbConsistentReadChangesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.consistent_read_changes_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbConsistentReadChangesPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.consistent_read_changes_per_transaction")
	m.data.SetDescription("Consistent read changes per transaction")
	m.data.SetUnit("{changes}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbConsistentReadChangesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbConsistentReadChangesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbConsistentReadChangesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbConsistentReadChangesPerTransaction(cfg MetricConfig) metricNewrelicOracleDbConsistentReadChangesPerTransaction {
	m := metricNewrelicOracleDbConsistentReadChangesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbConsistentReadGetsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.consistent_read_gets_per_second metric with initial data.
func (m *metricNewrelicOracleDbConsistentReadGetsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.consistent_read_gets_per_second")
	m.data.SetDescription("Consistent read gets per second")
	m.data.SetUnit("{gets}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbConsistentReadGetsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbConsistentReadGetsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbConsistentReadGetsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbConsistentReadGetsPerSecond(cfg MetricConfig) metricNewrelicOracleDbConsistentReadGetsPerSecond {
	m := metricNewrelicOracleDbConsistentReadGetsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbConsistentReadGetsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.consistent_read_gets_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbConsistentReadGetsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.consistent_read_gets_per_transaction")
	m.data.SetDescription("Consistent read gets per transaction")
	m.data.SetUnit("{gets}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbConsistentReadGetsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbConsistentReadGetsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbConsistentReadGetsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbConsistentReadGetsPerTransaction(cfg MetricConfig) metricNewrelicOracleDbConsistentReadGetsPerTransaction {
	m := metricNewrelicOracleDbConsistentReadGetsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbCPUTimeRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.cpu_time_ratio metric with initial data.
func (m *metricNewrelicOracleDbCPUTimeRatio) init() {
	m.data.SetName("newrelic.oracle.db.cpu_time_ratio")
	m.data.SetDescription("Database CPU time ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbCPUTimeRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbCPUTimeRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbCPUTimeRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbCPUTimeRatio(cfg MetricConfig) metricNewrelicOracleDbCPUTimeRatio {
	m := metricNewrelicOracleDbCPUTimeRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbCPUUsagePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.cpu_usage_per_second metric with initial data.
func (m *metricNewrelicOracleDbCPUUsagePerSecond) init() {
	m.data.SetName("newrelic.oracle.db.cpu_usage_per_second")
	m.data.SetDescription("CPU usage per second")
	m.data.SetUnit("{cpu}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbCPUUsagePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbCPUUsagePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbCPUUsagePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbCPUUsagePerSecond(cfg MetricConfig) metricNewrelicOracleDbCPUUsagePerSecond {
	m := metricNewrelicOracleDbCPUUsagePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbCPUUsagePerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.cpu_usage_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbCPUUsagePerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.cpu_usage_per_transaction")
	m.data.SetDescription("CPU usage per transaction")
	m.data.SetUnit("{cpu}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbCPUUsagePerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbCPUUsagePerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbCPUUsagePerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbCPUUsagePerTransaction(cfg MetricConfig) metricNewrelicOracleDbCPUUsagePerTransaction {
	m := metricNewrelicOracleDbCPUUsagePerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbCrBlocksCreatedPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.cr_blocks_created_per_second metric with initial data.
func (m *metricNewrelicOracleDbCrBlocksCreatedPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.cr_blocks_created_per_second")
	m.data.SetDescription("CR blocks created per second")
	m.data.SetUnit("{blocks}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbCrBlocksCreatedPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbCrBlocksCreatedPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbCrBlocksCreatedPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbCrBlocksCreatedPerSecond(cfg MetricConfig) metricNewrelicOracleDbCrBlocksCreatedPerSecond {
	m := metricNewrelicOracleDbCrBlocksCreatedPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbCrBlocksCreatedPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.cr_blocks_created_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbCrBlocksCreatedPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.cr_blocks_created_per_transaction")
	m.data.SetDescription("CR blocks created per transaction")
	m.data.SetUnit("{blocks}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbCrBlocksCreatedPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbCrBlocksCreatedPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbCrBlocksCreatedPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbCrBlocksCreatedPerTransaction(cfg MetricConfig) metricNewrelicOracleDbCrBlocksCreatedPerTransaction {
	m := metricNewrelicOracleDbCrBlocksCreatedPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbCrUndoRecordsAppliedPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.cr_undo_records_applied_per_second metric with initial data.
func (m *metricNewrelicOracleDbCrUndoRecordsAppliedPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.cr_undo_records_applied_per_second")
	m.data.SetDescription("CR undo records applied per second")
	m.data.SetUnit("{records}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbCrUndoRecordsAppliedPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbCrUndoRecordsAppliedPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbCrUndoRecordsAppliedPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbCrUndoRecordsAppliedPerSecond(cfg MetricConfig) metricNewrelicOracleDbCrUndoRecordsAppliedPerSecond {
	m := metricNewrelicOracleDbCrUndoRecordsAppliedPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.cr_undo_records_applied_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.cr_undo_records_applied_per_transaction")
	m.data.SetDescription("CR undo records applied per transaction")
	m.data.SetUnit("{records}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction(cfg MetricConfig) metricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction {
	m := metricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbCurrentLogons struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.current_logons metric with initial data.
func (m *metricNewrelicOracleDbCurrentLogons) init() {
	m.data.SetName("newrelic.oracle.db.current_logons")
	m.data.SetDescription("Current logons count")
	m.data.SetUnit("{logons}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbCurrentLogons) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbCurrentLogons) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbCurrentLogons) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbCurrentLogons(cfg MetricConfig) metricNewrelicOracleDbCurrentLogons {
	m := metricNewrelicOracleDbCurrentLogons{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbCurrentOpenCursors struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.current_open_cursors metric with initial data.
func (m *metricNewrelicOracleDbCurrentOpenCursors) init() {
	m.data.SetName("newrelic.oracle.db.current_open_cursors")
	m.data.SetDescription("Current open cursors count")
	m.data.SetUnit("{cursors}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbCurrentOpenCursors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbCurrentOpenCursors) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbCurrentOpenCursors) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbCurrentOpenCursors(cfg MetricConfig) metricNewrelicOracleDbCurrentOpenCursors {
	m := metricNewrelicOracleDbCurrentOpenCursors{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbCursorCacheHitsPerAttempts struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.cursor_cache_hits_per_attempts metric with initial data.
func (m *metricNewrelicOracleDbCursorCacheHitsPerAttempts) init() {
	m.data.SetName("newrelic.oracle.db.cursor_cache_hits_per_attempts")
	m.data.SetDescription("Cursor cache hit ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbCursorCacheHitsPerAttempts) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbCursorCacheHitsPerAttempts) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbCursorCacheHitsPerAttempts) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbCursorCacheHitsPerAttempts(cfg MetricConfig) metricNewrelicOracleDbCursorCacheHitsPerAttempts {
	m := metricNewrelicOracleDbCursorCacheHitsPerAttempts{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbDatabaseCPUTimePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.database_cpu_time_per_second metric with initial data.
func (m *metricNewrelicOracleDbDatabaseCPUTimePerSecond) init() {
	m.data.SetName("newrelic.oracle.db.database_cpu_time_per_second")
	m.data.SetDescription("Database CPU time per second")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbDatabaseCPUTimePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbDatabaseCPUTimePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbDatabaseCPUTimePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbDatabaseCPUTimePerSecond(cfg MetricConfig) metricNewrelicOracleDbDatabaseCPUTimePerSecond {
	m := metricNewrelicOracleDbDatabaseCPUTimePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbDbwrCheckpointsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.dbwr_checkpoints_per_second metric with initial data.
func (m *metricNewrelicOracleDbDbwrCheckpointsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.dbwr_checkpoints_per_second")
	m.data.SetDescription("DBWR checkpoints per second")
	m.data.SetUnit("{checkpoints}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbDbwrCheckpointsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbDbwrCheckpointsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbDbwrCheckpointsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbDbwrCheckpointsPerSecond(cfg MetricConfig) metricNewrelicOracleDbDbwrCheckpointsPerSecond {
	m := metricNewrelicOracleDbDbwrCheckpointsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbEnqueueDeadlocksPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.enqueue_deadlocks_per_second metric with initial data.
func (m *metricNewrelicOracleDbEnqueueDeadlocksPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.enqueue_deadlocks_per_second")
	m.data.SetDescription("Enqueue deadlocks per second")
	m.data.SetUnit("{deadlocks}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbEnqueueDeadlocksPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbEnqueueDeadlocksPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbEnqueueDeadlocksPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbEnqueueDeadlocksPerSecond(cfg MetricConfig) metricNewrelicOracleDbEnqueueDeadlocksPerSecond {
	m := metricNewrelicOracleDbEnqueueDeadlocksPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbEnqueueDeadlocksPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.enqueue_deadlocks_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbEnqueueDeadlocksPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.enqueue_deadlocks_per_transaction")
	m.data.SetDescription("Enqueue deadlocks per transaction")
	m.data.SetUnit("{deadlocks}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbEnqueueDeadlocksPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbEnqueueDeadlocksPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbEnqueueDeadlocksPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbEnqueueDeadlocksPerTransaction(cfg MetricConfig) metricNewrelicOracleDbEnqueueDeadlocksPerTransaction {
	m := metricNewrelicOracleDbEnqueueDeadlocksPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbEnqueueRequestsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.enqueue_requests_per_second metric with initial data.
func (m *metricNewrelicOracleDbEnqueueRequestsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.enqueue_requests_per_second")
	m.data.SetDescription("Enqueue requests per second")
	m.data.SetUnit("{requests}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbEnqueueRequestsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbEnqueueRequestsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbEnqueueRequestsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbEnqueueRequestsPerSecond(cfg MetricConfig) metricNewrelicOracleDbEnqueueRequestsPerSecond {
	m := metricNewrelicOracleDbEnqueueRequestsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbEnqueueRequestsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.enqueue_requests_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbEnqueueRequestsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.enqueue_requests_per_transaction")
	m.data.SetDescription("Enqueue requests per transaction")
	m.data.SetUnit("{requests}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbEnqueueRequestsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbEnqueueRequestsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbEnqueueRequestsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbEnqueueRequestsPerTransaction(cfg MetricConfig) metricNewrelicOracleDbEnqueueRequestsPerTransaction {
	m := metricNewrelicOracleDbEnqueueRequestsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbEnqueueTimeoutsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.enqueue_timeouts_per_second metric with initial data.
func (m *metricNewrelicOracleDbEnqueueTimeoutsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.enqueue_timeouts_per_second")
	m.data.SetDescription("Enqueue timeouts per second")
	m.data.SetUnit("{timeouts}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbEnqueueTimeoutsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbEnqueueTimeoutsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbEnqueueTimeoutsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbEnqueueTimeoutsPerSecond(cfg MetricConfig) metricNewrelicOracleDbEnqueueTimeoutsPerSecond {
	m := metricNewrelicOracleDbEnqueueTimeoutsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbEnqueueTimeoutsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.enqueue_timeouts_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbEnqueueTimeoutsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.enqueue_timeouts_per_transaction")
	m.data.SetDescription("Enqueue timeouts per transaction")
	m.data.SetUnit("{timeouts}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbEnqueueTimeoutsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbEnqueueTimeoutsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbEnqueueTimeoutsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbEnqueueTimeoutsPerTransaction(cfg MetricConfig) metricNewrelicOracleDbEnqueueTimeoutsPerTransaction {
	m := metricNewrelicOracleDbEnqueueTimeoutsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbEnqueueWaitsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.enqueue_waits_per_second metric with initial data.
func (m *metricNewrelicOracleDbEnqueueWaitsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.enqueue_waits_per_second")
	m.data.SetDescription("Enqueue waits per second")
	m.data.SetUnit("{waits}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbEnqueueWaitsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbEnqueueWaitsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbEnqueueWaitsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbEnqueueWaitsPerSecond(cfg MetricConfig) metricNewrelicOracleDbEnqueueWaitsPerSecond {
	m := metricNewrelicOracleDbEnqueueWaitsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbEnqueueWaitsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.enqueue_waits_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbEnqueueWaitsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.enqueue_waits_per_transaction")
	m.data.SetDescription("Enqueue waits per transaction")
	m.data.SetUnit("{waits}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbEnqueueWaitsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbEnqueueWaitsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbEnqueueWaitsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbEnqueueWaitsPerTransaction(cfg MetricConfig) metricNewrelicOracleDbEnqueueWaitsPerTransaction {
	m := metricNewrelicOracleDbEnqueueWaitsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbExecuteWithoutParseRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.execute_without_parse_ratio metric with initial data.
func (m *metricNewrelicOracleDbExecuteWithoutParseRatio) init() {
	m.data.SetName("newrelic.oracle.db.execute_without_parse_ratio")
	m.data.SetDescription("Execute without parse ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbExecuteWithoutParseRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbExecuteWithoutParseRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbExecuteWithoutParseRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbExecuteWithoutParseRatio(cfg MetricConfig) metricNewrelicOracleDbExecuteWithoutParseRatio {
	m := metricNewrelicOracleDbExecuteWithoutParseRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbExecutionsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.executions_per_second metric with initial data.
func (m *metricNewrelicOracleDbExecutionsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.executions_per_second")
	m.data.SetDescription("Executions per second")
	m.data.SetUnit("{executions}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbExecutionsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbExecutionsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbExecutionsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbExecutionsPerSecond(cfg MetricConfig) metricNewrelicOracleDbExecutionsPerSecond {
	m := metricNewrelicOracleDbExecutionsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbExecutionsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.executions_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbExecutionsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.executions_per_transaction")
	m.data.SetDescription("Executions per transaction")
	m.data.SetUnit("{executions}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbExecutionsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbExecutionsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbExecutionsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbExecutionsPerTransaction(cfg MetricConfig) metricNewrelicOracleDbExecutionsPerTransaction {
	m := metricNewrelicOracleDbExecutionsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbExecutionsPerUserCall struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.executions_per_user_call metric with initial data.
func (m *metricNewrelicOracleDbExecutionsPerUserCall) init() {
	m.data.SetName("newrelic.oracle.db.executions_per_user_call")
	m.data.SetDescription("Executions per user call")
	m.data.SetUnit("{executions}/{call}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbExecutionsPerUserCall) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbExecutionsPerUserCall) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbExecutionsPerUserCall) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbExecutionsPerUserCall(cfg MetricConfig) metricNewrelicOracleDbExecutionsPerUserCall {
	m := metricNewrelicOracleDbExecutionsPerUserCall{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbFullIndexScansPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.full_index_scans_per_second metric with initial data.
func (m *metricNewrelicOracleDbFullIndexScansPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.full_index_scans_per_second")
	m.data.SetDescription("Full index scans per second")
	m.data.SetUnit("{scans}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbFullIndexScansPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbFullIndexScansPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbFullIndexScansPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbFullIndexScansPerSecond(cfg MetricConfig) metricNewrelicOracleDbFullIndexScansPerSecond {
	m := metricNewrelicOracleDbFullIndexScansPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbFullIndexScansPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.full_index_scans_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbFullIndexScansPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.full_index_scans_per_transaction")
	m.data.SetDescription("Full index scans per transaction")
	m.data.SetUnit("{scans}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbFullIndexScansPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbFullIndexScansPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbFullIndexScansPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbFullIndexScansPerTransaction(cfg MetricConfig) metricNewrelicOracleDbFullIndexScansPerTransaction {
	m := metricNewrelicOracleDbFullIndexScansPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbGcCrBlockReceivedPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.gc_cr_block_received_per_second metric with initial data.
func (m *metricNewrelicOracleDbGcCrBlockReceivedPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.gc_cr_block_received_per_second")
	m.data.SetDescription("GC CR block received per second")
	m.data.SetUnit("{blocks}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbGcCrBlockReceivedPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbGcCrBlockReceivedPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbGcCrBlockReceivedPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbGcCrBlockReceivedPerSecond(cfg MetricConfig) metricNewrelicOracleDbGcCrBlockReceivedPerSecond {
	m := metricNewrelicOracleDbGcCrBlockReceivedPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbGcCrBlockReceivedPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.gc_cr_block_received_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbGcCrBlockReceivedPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.gc_cr_block_received_per_transaction")
	m.data.SetDescription("GC CR block received per transaction")
	m.data.SetUnit("{blocks}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbGcCrBlockReceivedPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbGcCrBlockReceivedPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbGcCrBlockReceivedPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbGcCrBlockReceivedPerTransaction(cfg MetricConfig) metricNewrelicOracleDbGcCrBlockReceivedPerTransaction {
	m := metricNewrelicOracleDbGcCrBlockReceivedPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbGcCurrentBlockReceivedPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.gc_current_block_received_per_second metric with initial data.
func (m *metricNewrelicOracleDbGcCurrentBlockReceivedPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.gc_current_block_received_per_second")
	m.data.SetDescription("GC current block received per second")
	m.data.SetUnit("{blocks}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbGcCurrentBlockReceivedPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbGcCurrentBlockReceivedPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbGcCurrentBlockReceivedPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbGcCurrentBlockReceivedPerSecond(cfg MetricConfig) metricNewrelicOracleDbGcCurrentBlockReceivedPerSecond {
	m := metricNewrelicOracleDbGcCurrentBlockReceivedPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.gc_current_block_received_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.gc_current_block_received_per_transaction")
	m.data.SetDescription("GC current block received per transaction")
	m.data.SetUnit("{blocks}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction(cfg MetricConfig) metricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction {
	m := metricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbGlobalCacheAverageCrGetTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.global_cache_average_cr_get_time metric with initial data.
func (m *metricNewrelicOracleDbGlobalCacheAverageCrGetTime) init() {
	m.data.SetName("newrelic.oracle.db.global_cache_average_cr_get_time")
	m.data.SetDescription("Global cache average CR get time")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbGlobalCacheAverageCrGetTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbGlobalCacheAverageCrGetTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbGlobalCacheAverageCrGetTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbGlobalCacheAverageCrGetTime(cfg MetricConfig) metricNewrelicOracleDbGlobalCacheAverageCrGetTime {
	m := metricNewrelicOracleDbGlobalCacheAverageCrGetTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbGlobalCacheAverageCurrentGetTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.global_cache_average_current_get_time metric with initial data.
func (m *metricNewrelicOracleDbGlobalCacheAverageCurrentGetTime) init() {
	m.data.SetName("newrelic.oracle.db.global_cache_average_current_get_time")
	m.data.SetDescription("Global cache average current get time")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbGlobalCacheAverageCurrentGetTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbGlobalCacheAverageCurrentGetTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbGlobalCacheAverageCurrentGetTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbGlobalCacheAverageCurrentGetTime(cfg MetricConfig) metricNewrelicOracleDbGlobalCacheAverageCurrentGetTime {
	m := metricNewrelicOracleDbGlobalCacheAverageCurrentGetTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbHardParseCountPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.hard_parse_count_per_second metric with initial data.
func (m *metricNewrelicOracleDbHardParseCountPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.hard_parse_count_per_second")
	m.data.SetDescription("Hard parse count per second")
	m.data.SetUnit("{parses}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbHardParseCountPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbHardParseCountPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbHardParseCountPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbHardParseCountPerSecond(cfg MetricConfig) metricNewrelicOracleDbHardParseCountPerSecond {
	m := metricNewrelicOracleDbHardParseCountPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbHardParseCountPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.hard_parse_count_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbHardParseCountPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.hard_parse_count_per_transaction")
	m.data.SetDescription("Hard parse count per transaction")
	m.data.SetUnit("{parses}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbHardParseCountPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbHardParseCountPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbHardParseCountPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbHardParseCountPerTransaction(cfg MetricConfig) metricNewrelicOracleDbHardParseCountPerTransaction {
	m := metricNewrelicOracleDbHardParseCountPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbHostCPUUsagePerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.host_cpu_usage_per_second metric with initial data.
func (m *metricNewrelicOracleDbHostCPUUsagePerSecond) init() {
	m.data.SetName("newrelic.oracle.db.host_cpu_usage_per_second")
	m.data.SetDescription("Host CPU usage per second")
	m.data.SetUnit("{cpu}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbHostCPUUsagePerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbHostCPUUsagePerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbHostCPUUsagePerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbHostCPUUsagePerSecond(cfg MetricConfig) metricNewrelicOracleDbHostCPUUsagePerSecond {
	m := metricNewrelicOracleDbHostCPUUsagePerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbHostCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.host_cpu_utilization metric with initial data.
func (m *metricNewrelicOracleDbHostCPUUtilization) init() {
	m.data.SetName("newrelic.oracle.db.host_cpu_utilization")
	m.data.SetDescription("Host CPU utilization percentage")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbHostCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbHostCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbHostCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbHostCPUUtilization(cfg MetricConfig) metricNewrelicOracleDbHostCPUUtilization {
	m := metricNewrelicOracleDbHostCPUUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbLeafNodeSplitsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.leaf_node_splits_per_second metric with initial data.
func (m *metricNewrelicOracleDbLeafNodeSplitsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.leaf_node_splits_per_second")
	m.data.SetDescription("Leaf node splits per second")
	m.data.SetUnit("{splits}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbLeafNodeSplitsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbLeafNodeSplitsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbLeafNodeSplitsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbLeafNodeSplitsPerSecond(cfg MetricConfig) metricNewrelicOracleDbLeafNodeSplitsPerSecond {
	m := metricNewrelicOracleDbLeafNodeSplitsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbLeafNodeSplitsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.leaf_node_splits_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbLeafNodeSplitsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.leaf_node_splits_per_transaction")
	m.data.SetDescription("Leaf node splits per transaction")
	m.data.SetUnit("{splits}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbLeafNodeSplitsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbLeafNodeSplitsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbLeafNodeSplitsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbLeafNodeSplitsPerTransaction(cfg MetricConfig) metricNewrelicOracleDbLeafNodeSplitsPerTransaction {
	m := metricNewrelicOracleDbLeafNodeSplitsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbLibraryCacheHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.library_cache_hit_ratio metric with initial data.
func (m *metricNewrelicOracleDbLibraryCacheHitRatio) init() {
	m.data.SetName("newrelic.oracle.db.library_cache_hit_ratio")
	m.data.SetDescription("Library cache hit ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbLibraryCacheHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbLibraryCacheHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbLibraryCacheHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbLibraryCacheHitRatio(cfg MetricConfig) metricNewrelicOracleDbLibraryCacheHitRatio {
	m := metricNewrelicOracleDbLibraryCacheHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbLibraryCacheMissRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.library_cache_miss_ratio metric with initial data.
func (m *metricNewrelicOracleDbLibraryCacheMissRatio) init() {
	m.data.SetName("newrelic.oracle.db.library_cache_miss_ratio")
	m.data.SetDescription("Library cache miss ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbLibraryCacheMissRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbLibraryCacheMissRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbLibraryCacheMissRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbLibraryCacheMissRatio(cfg MetricConfig) metricNewrelicOracleDbLibraryCacheMissRatio {
	m := metricNewrelicOracleDbLibraryCacheMissRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbLogicalReadsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.logical_reads_per_second metric with initial data.
func (m *metricNewrelicOracleDbLogicalReadsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.logical_reads_per_second")
	m.data.SetDescription("Logical reads per second")
	m.data.SetUnit("{reads}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbLogicalReadsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbLogicalReadsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbLogicalReadsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbLogicalReadsPerSecond(cfg MetricConfig) metricNewrelicOracleDbLogicalReadsPerSecond {
	m := metricNewrelicOracleDbLogicalReadsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbLogicalReadsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.logical_reads_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbLogicalReadsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.logical_reads_per_transaction")
	m.data.SetDescription("Logical reads per transaction")
	m.data.SetUnit("{reads}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbLogicalReadsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbLogicalReadsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbLogicalReadsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbLogicalReadsPerTransaction(cfg MetricConfig) metricNewrelicOracleDbLogicalReadsPerTransaction {
	m := metricNewrelicOracleDbLogicalReadsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbLogonsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.logons_per_second metric with initial data.
func (m *metricNewrelicOracleDbLogonsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.logons_per_second")
	m.data.SetDescription("Logons per second")
	m.data.SetUnit("{logons}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbLogonsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbLogonsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbLogonsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbLogonsPerSecond(cfg MetricConfig) metricNewrelicOracleDbLogonsPerSecond {
	m := metricNewrelicOracleDbLogonsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbLogonsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.logons_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbLogonsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.logons_per_transaction")
	m.data.SetDescription("Logons per transaction")
	m.data.SetUnit("{logons}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbLogonsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbLogonsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbLogonsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbLogonsPerTransaction(cfg MetricConfig) metricNewrelicOracleDbLogonsPerTransaction {
	m := metricNewrelicOracleDbLogonsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbLongTableScansPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.long_table_scans_per_second metric with initial data.
func (m *metricNewrelicOracleDbLongTableScansPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.long_table_scans_per_second")
	m.data.SetDescription("Long table scans per second")
	m.data.SetUnit("{scans}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbLongTableScansPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbLongTableScansPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbLongTableScansPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbLongTableScansPerSecond(cfg MetricConfig) metricNewrelicOracleDbLongTableScansPerSecond {
	m := metricNewrelicOracleDbLongTableScansPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbLongTableScansPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.long_table_scans_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbLongTableScansPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.long_table_scans_per_transaction")
	m.data.SetDescription("Long table scans per transaction")
	m.data.SetUnit("{scans}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbLongTableScansPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbLongTableScansPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbLongTableScansPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbLongTableScansPerTransaction(cfg MetricConfig) metricNewrelicOracleDbLongTableScansPerTransaction {
	m := metricNewrelicOracleDbLongTableScansPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbOpenCursorsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.open_cursors_per_second metric with initial data.
func (m *metricNewrelicOracleDbOpenCursorsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.open_cursors_per_second")
	m.data.SetDescription("Open cursors per second")
	m.data.SetUnit("{cursors}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbOpenCursorsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbOpenCursorsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbOpenCursorsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbOpenCursorsPerSecond(cfg MetricConfig) metricNewrelicOracleDbOpenCursorsPerSecond {
	m := metricNewrelicOracleDbOpenCursorsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbOpenCursorsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.open_cursors_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbOpenCursorsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.open_cursors_per_transaction")
	m.data.SetDescription("Open cursors per transaction")
	m.data.SetUnit("{cursors}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbOpenCursorsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbOpenCursorsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbOpenCursorsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbOpenCursorsPerTransaction(cfg MetricConfig) metricNewrelicOracleDbOpenCursorsPerTransaction {
	m := metricNewrelicOracleDbOpenCursorsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbOsLoad struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.os_load metric with initial data.
func (m *metricNewrelicOracleDbOsLoad) init() {
	m.data.SetName("newrelic.oracle.db.os_load")
	m.data.SetDescription("Current OS load")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbOsLoad) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbOsLoad) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbOsLoad) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbOsLoad(cfg MetricConfig) metricNewrelicOracleDbOsLoad {
	m := metricNewrelicOracleDbOsLoad{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbParseFailureCountPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.parse_failure_count_per_second metric with initial data.
func (m *metricNewrelicOracleDbParseFailureCountPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.parse_failure_count_per_second")
	m.data.SetDescription("Parse failure count per second")
	m.data.SetUnit("{failures}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbParseFailureCountPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbParseFailureCountPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbParseFailureCountPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbParseFailureCountPerSecond(cfg MetricConfig) metricNewrelicOracleDbParseFailureCountPerSecond {
	m := metricNewrelicOracleDbParseFailureCountPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbParseFailureCountPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.parse_failure_count_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbParseFailureCountPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.parse_failure_count_per_transaction")
	m.data.SetDescription("Parse failure count per transaction")
	m.data.SetUnit("{failures}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbParseFailureCountPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbParseFailureCountPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbParseFailureCountPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbParseFailureCountPerTransaction(cfg MetricConfig) metricNewrelicOracleDbParseFailureCountPerTransaction {
	m := metricNewrelicOracleDbParseFailureCountPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbPgaCacheHitPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.pga_cache_hit_percentage metric with initial data.
func (m *metricNewrelicOracleDbPgaCacheHitPercentage) init() {
	m.data.SetName("newrelic.oracle.db.pga_cache_hit_percentage")
	m.data.SetDescription("PGA cache hit percentage")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbPgaCacheHitPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbPgaCacheHitPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbPgaCacheHitPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbPgaCacheHitPercentage(cfg MetricConfig) metricNewrelicOracleDbPgaCacheHitPercentage {
	m := metricNewrelicOracleDbPgaCacheHitPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbPhysicalReadBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.physical_read_bytes_per_second metric with initial data.
func (m *metricNewrelicOracleDbPhysicalReadBytesPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.physical_read_bytes_per_second")
	m.data.SetDescription("Physical read bytes per second")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbPhysicalReadBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbPhysicalReadBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbPhysicalReadBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbPhysicalReadBytesPerSecond(cfg MetricConfig) metricNewrelicOracleDbPhysicalReadBytesPerSecond {
	m := metricNewrelicOracleDbPhysicalReadBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbPhysicalReadIoRequestsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.physical_read_io_requests_per_second metric with initial data.
func (m *metricNewrelicOracleDbPhysicalReadIoRequestsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.physical_read_io_requests_per_second")
	m.data.SetDescription("Physical read I/O requests per second")
	m.data.SetUnit("{requests}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbPhysicalReadIoRequestsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbPhysicalReadIoRequestsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbPhysicalReadIoRequestsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbPhysicalReadIoRequestsPerSecond(cfg MetricConfig) metricNewrelicOracleDbPhysicalReadIoRequestsPerSecond {
	m := metricNewrelicOracleDbPhysicalReadIoRequestsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbPhysicalReadsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.physical_reads_per_second metric with initial data.
func (m *metricNewrelicOracleDbPhysicalReadsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.physical_reads_per_second")
	m.data.SetDescription("Physical reads per second")
	m.data.SetUnit("{reads}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbPhysicalReadsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbPhysicalReadsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbPhysicalReadsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbPhysicalReadsPerSecond(cfg MetricConfig) metricNewrelicOracleDbPhysicalReadsPerSecond {
	m := metricNewrelicOracleDbPhysicalReadsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbPhysicalWriteBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.physical_write_bytes_per_second metric with initial data.
func (m *metricNewrelicOracleDbPhysicalWriteBytesPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.physical_write_bytes_per_second")
	m.data.SetDescription("Physical write bytes per second")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbPhysicalWriteBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbPhysicalWriteBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbPhysicalWriteBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbPhysicalWriteBytesPerSecond(cfg MetricConfig) metricNewrelicOracleDbPhysicalWriteBytesPerSecond {
	m := metricNewrelicOracleDbPhysicalWriteBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbPhysicalWritesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.physical_writes_per_second metric with initial data.
func (m *metricNewrelicOracleDbPhysicalWritesPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.physical_writes_per_second")
	m.data.SetDescription("Physical writes per second")
	m.data.SetUnit("{writes}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbPhysicalWritesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbPhysicalWritesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbPhysicalWritesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbPhysicalWritesPerSecond(cfg MetricConfig) metricNewrelicOracleDbPhysicalWritesPerSecond {
	m := metricNewrelicOracleDbPhysicalWritesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbProcessLimitPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.process_limit_percentage metric with initial data.
func (m *metricNewrelicOracleDbProcessLimitPercentage) init() {
	m.data.SetName("newrelic.oracle.db.process_limit_percentage")
	m.data.SetDescription("Process limit percentage")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbProcessLimitPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbProcessLimitPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbProcessLimitPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbProcessLimitPercentage(cfg MetricConfig) metricNewrelicOracleDbProcessLimitPercentage {
	m := metricNewrelicOracleDbProcessLimitPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbRecursiveCallsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.recursive_calls_per_second metric with initial data.
func (m *metricNewrelicOracleDbRecursiveCallsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.recursive_calls_per_second")
	m.data.SetDescription("Recursive calls per second")
	m.data.SetUnit("{calls}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbRecursiveCallsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbRecursiveCallsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbRecursiveCallsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbRecursiveCallsPerSecond(cfg MetricConfig) metricNewrelicOracleDbRecursiveCallsPerSecond {
	m := metricNewrelicOracleDbRecursiveCallsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbRecursiveCallsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.recursive_calls_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbRecursiveCallsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.recursive_calls_per_transaction")
	m.data.SetDescription("Recursive calls per transaction")
	m.data.SetUnit("{calls}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbRecursiveCallsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbRecursiveCallsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbRecursiveCallsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbRecursiveCallsPerTransaction(cfg MetricConfig) metricNewrelicOracleDbRecursiveCallsPerTransaction {
	m := metricNewrelicOracleDbRecursiveCallsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbRedoWritesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.redo_writes_per_second metric with initial data.
func (m *metricNewrelicOracleDbRedoWritesPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.redo_writes_per_second")
	m.data.SetDescription("Redo writes per second")
	m.data.SetUnit("{writes}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbRedoWritesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbRedoWritesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbRedoWritesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbRedoWritesPerSecond(cfg MetricConfig) metricNewrelicOracleDbRedoWritesPerSecond {
	m := metricNewrelicOracleDbRedoWritesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbRedoWritesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.redo_writes_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbRedoWritesPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.redo_writes_per_transaction")
	m.data.SetDescription("Redo writes per transaction")
	m.data.SetUnit("{writes}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbRedoWritesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbRedoWritesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbRedoWritesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbRedoWritesPerTransaction(cfg MetricConfig) metricNewrelicOracleDbRedoWritesPerTransaction {
	m := metricNewrelicOracleDbRedoWritesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbResponseTimePerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.response_time_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbResponseTimePerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.response_time_per_transaction")
	m.data.SetDescription("Response time per transaction")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbResponseTimePerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbResponseTimePerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbResponseTimePerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbResponseTimePerTransaction(cfg MetricConfig) metricNewrelicOracleDbResponseTimePerTransaction {
	m := metricNewrelicOracleDbResponseTimePerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbRowCacheHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.row_cache_hit_ratio metric with initial data.
func (m *metricNewrelicOracleDbRowCacheHitRatio) init() {
	m.data.SetName("newrelic.oracle.db.row_cache_hit_ratio")
	m.data.SetDescription("Row cache hit ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbRowCacheHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbRowCacheHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbRowCacheHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbRowCacheHitRatio(cfg MetricConfig) metricNewrelicOracleDbRowCacheHitRatio {
	m := metricNewrelicOracleDbRowCacheHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbRowCacheMissRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.row_cache_miss_ratio metric with initial data.
func (m *metricNewrelicOracleDbRowCacheMissRatio) init() {
	m.data.SetName("newrelic.oracle.db.row_cache_miss_ratio")
	m.data.SetDescription("Row cache miss ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbRowCacheMissRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbRowCacheMissRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbRowCacheMissRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbRowCacheMissRatio(cfg MetricConfig) metricNewrelicOracleDbRowCacheMissRatio {
	m := metricNewrelicOracleDbRowCacheMissRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbRowsPerSort struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.rows_per_sort metric with initial data.
func (m *metricNewrelicOracleDbRowsPerSort) init() {
	m.data.SetName("newrelic.oracle.db.rows_per_sort")
	m.data.SetDescription("Rows per sort")
	m.data.SetUnit("{rows}/{sort}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbRowsPerSort) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbRowsPerSort) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbRowsPerSort) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbRowsPerSort(cfg MetricConfig) metricNewrelicOracleDbRowsPerSort {
	m := metricNewrelicOracleDbRowsPerSort{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbSessionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.session_count metric with initial data.
func (m *metricNewrelicOracleDbSessionCount) init() {
	m.data.SetName("newrelic.oracle.db.session_count")
	m.data.SetDescription("Session count")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbSessionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbSessionCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbSessionCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbSessionCount(cfg MetricConfig) metricNewrelicOracleDbSessionCount {
	m := metricNewrelicOracleDbSessionCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbSessionLimitPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.session_limit_percentage metric with initial data.
func (m *metricNewrelicOracleDbSessionLimitPercentage) init() {
	m.data.SetName("newrelic.oracle.db.session_limit_percentage")
	m.data.SetDescription("Session limit percentage")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbSessionLimitPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbSessionLimitPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbSessionLimitPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbSessionLimitPercentage(cfg MetricConfig) metricNewrelicOracleDbSessionLimitPercentage {
	m := metricNewrelicOracleDbSessionLimitPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbSharedPoolFreePercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.shared_pool_free_percentage metric with initial data.
func (m *metricNewrelicOracleDbSharedPoolFreePercentage) init() {
	m.data.SetName("newrelic.oracle.db.shared_pool_free_percentage")
	m.data.SetDescription("Shared pool free percentage")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbSharedPoolFreePercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbSharedPoolFreePercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbSharedPoolFreePercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbSharedPoolFreePercentage(cfg MetricConfig) metricNewrelicOracleDbSharedPoolFreePercentage {
	m := metricNewrelicOracleDbSharedPoolFreePercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbSoftParseRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.soft_parse_ratio metric with initial data.
func (m *metricNewrelicOracleDbSoftParseRatio) init() {
	m.data.SetName("newrelic.oracle.db.soft_parse_ratio")
	m.data.SetDescription("Soft parse ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbSoftParseRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbSoftParseRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbSoftParseRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbSoftParseRatio(cfg MetricConfig) metricNewrelicOracleDbSoftParseRatio {
	m := metricNewrelicOracleDbSoftParseRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbSortsPerUserCall struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.sorts_per_user_call metric with initial data.
func (m *metricNewrelicOracleDbSortsPerUserCall) init() {
	m.data.SetName("newrelic.oracle.db.sorts_per_user_call")
	m.data.SetDescription("Total sorts per user call")
	m.data.SetUnit("{sorts}/{call}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbSortsPerUserCall) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbSortsPerUserCall) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbSortsPerUserCall) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbSortsPerUserCall(cfg MetricConfig) metricNewrelicOracleDbSortsPerUserCall {
	m := metricNewrelicOracleDbSortsPerUserCall{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbSQLServiceResponseTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.sql_service_response_time metric with initial data.
func (m *metricNewrelicOracleDbSQLServiceResponseTime) init() {
	m.data.SetName("newrelic.oracle.db.sql_service_response_time")
	m.data.SetDescription("SQL service response time")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbSQLServiceResponseTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbSQLServiceResponseTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbSQLServiceResponseTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbSQLServiceResponseTime(cfg MetricConfig) metricNewrelicOracleDbSQLServiceResponseTime {
	m := metricNewrelicOracleDbSQLServiceResponseTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbStreamsPoolUsagePercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.streams_pool_usage_percentage metric with initial data.
func (m *metricNewrelicOracleDbStreamsPoolUsagePercentage) init() {
	m.data.SetName("newrelic.oracle.db.streams_pool_usage_percentage")
	m.data.SetDescription("Streams pool usage percentage")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbStreamsPoolUsagePercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbStreamsPoolUsagePercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbStreamsPoolUsagePercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbStreamsPoolUsagePercentage(cfg MetricConfig) metricNewrelicOracleDbStreamsPoolUsagePercentage {
	m := metricNewrelicOracleDbStreamsPoolUsagePercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbTableScansPerUserCall struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.table_scans_per_user_call metric with initial data.
func (m *metricNewrelicOracleDbTableScansPerUserCall) init() {
	m.data.SetName("newrelic.oracle.db.table_scans_per_user_call")
	m.data.SetDescription("Total table scans per user call")
	m.data.SetUnit("{scans}/{call}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbTableScansPerUserCall) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbTableScansPerUserCall) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbTableScansPerUserCall) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbTableScansPerUserCall(cfg MetricConfig) metricNewrelicOracleDbTableScansPerUserCall {
	m := metricNewrelicOracleDbTableScansPerUserCall{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbTotalIndexScansPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.total_index_scans_per_second metric with initial data.
func (m *metricNewrelicOracleDbTotalIndexScansPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.total_index_scans_per_second")
	m.data.SetDescription("Total index scans per second")
	m.data.SetUnit("{scans}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbTotalIndexScansPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbTotalIndexScansPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbTotalIndexScansPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbTotalIndexScansPerSecond(cfg MetricConfig) metricNewrelicOracleDbTotalIndexScansPerSecond {
	m := metricNewrelicOracleDbTotalIndexScansPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbTotalIndexScansPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.total_index_scans_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbTotalIndexScansPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.total_index_scans_per_transaction")
	m.data.SetDescription("Total index scans per transaction")
	m.data.SetUnit("{scans}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbTotalIndexScansPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbTotalIndexScansPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbTotalIndexScansPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbTotalIndexScansPerTransaction(cfg MetricConfig) metricNewrelicOracleDbTotalIndexScansPerTransaction {
	m := metricNewrelicOracleDbTotalIndexScansPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbTotalParseCountPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.total_parse_count_per_second metric with initial data.
func (m *metricNewrelicOracleDbTotalParseCountPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.total_parse_count_per_second")
	m.data.SetDescription("Total parse count per second")
	m.data.SetUnit("{parses}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbTotalParseCountPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbTotalParseCountPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbTotalParseCountPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbTotalParseCountPerSecond(cfg MetricConfig) metricNewrelicOracleDbTotalParseCountPerSecond {
	m := metricNewrelicOracleDbTotalParseCountPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbTotalParseCountPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.total_parse_count_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbTotalParseCountPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.total_parse_count_per_transaction")
	m.data.SetDescription("Total parse count per transaction")
	m.data.SetUnit("{parses}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbTotalParseCountPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbTotalParseCountPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbTotalParseCountPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbTotalParseCountPerTransaction(cfg MetricConfig) metricNewrelicOracleDbTotalParseCountPerTransaction {
	m := metricNewrelicOracleDbTotalParseCountPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbTotalTableScansPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.total_table_scans_per_second metric with initial data.
func (m *metricNewrelicOracleDbTotalTableScansPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.total_table_scans_per_second")
	m.data.SetDescription("Total table scans per second")
	m.data.SetUnit("{scans}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbTotalTableScansPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbTotalTableScansPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbTotalTableScansPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbTotalTableScansPerSecond(cfg MetricConfig) metricNewrelicOracleDbTotalTableScansPerSecond {
	m := metricNewrelicOracleDbTotalTableScansPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbTotalTableScansPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.total_table_scans_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbTotalTableScansPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.total_table_scans_per_transaction")
	m.data.SetDescription("Total table scans per transaction")
	m.data.SetUnit("{scans}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbTotalTableScansPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbTotalTableScansPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbTotalTableScansPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbTotalTableScansPerTransaction(cfg MetricConfig) metricNewrelicOracleDbTotalTableScansPerTransaction {
	m := metricNewrelicOracleDbTotalTableScansPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbTransactionsPerLogon struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.transactions_per_logon metric with initial data.
func (m *metricNewrelicOracleDbTransactionsPerLogon) init() {
	m.data.SetName("newrelic.oracle.db.transactions_per_logon")
	m.data.SetDescription("Transactions per logon")
	m.data.SetUnit("{transactions}/{logon}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbTransactionsPerLogon) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbTransactionsPerLogon) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbTransactionsPerLogon) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbTransactionsPerLogon(cfg MetricConfig) metricNewrelicOracleDbTransactionsPerLogon {
	m := metricNewrelicOracleDbTransactionsPerLogon{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbUserCallsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.user_calls_per_second metric with initial data.
func (m *metricNewrelicOracleDbUserCallsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.user_calls_per_second")
	m.data.SetDescription("User calls per second")
	m.data.SetUnit("{calls}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbUserCallsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbUserCallsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbUserCallsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbUserCallsPerSecond(cfg MetricConfig) metricNewrelicOracleDbUserCallsPerSecond {
	m := metricNewrelicOracleDbUserCallsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbUserCallsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.user_calls_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbUserCallsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.user_calls_per_transaction")
	m.data.SetDescription("User calls per transaction")
	m.data.SetUnit("{calls}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbUserCallsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbUserCallsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbUserCallsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbUserCallsPerTransaction(cfg MetricConfig) metricNewrelicOracleDbUserCallsPerTransaction {
	m := metricNewrelicOracleDbUserCallsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbUserCallsRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.user_calls_ratio metric with initial data.
func (m *metricNewrelicOracleDbUserCallsRatio) init() {
	m.data.SetName("newrelic.oracle.db.user_calls_ratio")
	m.data.SetDescription("User calls ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbUserCallsRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbUserCallsRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbUserCallsRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbUserCallsRatio(cfg MetricConfig) metricNewrelicOracleDbUserCallsRatio {
	m := metricNewrelicOracleDbUserCallsRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbUserCommitsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.user_commits_per_second metric with initial data.
func (m *metricNewrelicOracleDbUserCommitsPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.user_commits_per_second")
	m.data.SetDescription("User commits per second")
	m.data.SetUnit("{commits}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbUserCommitsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbUserCommitsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbUserCommitsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbUserCommitsPerSecond(cfg MetricConfig) metricNewrelicOracleDbUserCommitsPerSecond {
	m := metricNewrelicOracleDbUserCommitsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbUserCommitsPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.user_commits_percentage metric with initial data.
func (m *metricNewrelicOracleDbUserCommitsPercentage) init() {
	m.data.SetName("newrelic.oracle.db.user_commits_percentage")
	m.data.SetDescription("User commits percentage")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbUserCommitsPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbUserCommitsPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbUserCommitsPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbUserCommitsPercentage(cfg MetricConfig) metricNewrelicOracleDbUserCommitsPercentage {
	m := metricNewrelicOracleDbUserCommitsPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbUserLimitPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.user_limit_percentage metric with initial data.
func (m *metricNewrelicOracleDbUserLimitPercentage) init() {
	m.data.SetName("newrelic.oracle.db.user_limit_percentage")
	m.data.SetDescription("User limit percentage")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbUserLimitPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbUserLimitPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbUserLimitPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbUserLimitPercentage(cfg MetricConfig) metricNewrelicOracleDbUserLimitPercentage {
	m := metricNewrelicOracleDbUserLimitPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.user_rollback_undo_records_applied_per_second metric with initial data.
func (m *metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.user_rollback_undo_records_applied_per_second")
	m.data.SetDescription("User rollback undo records applied per second")
	m.data.SetUnit("{records}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond(cfg MetricConfig) metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond {
	m := metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.user_rollback_undo_records_applied_per_transaction metric with initial data.
func (m *metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction) init() {
	m.data.SetName("newrelic.oracle.db.user_rollback_undo_records_applied_per_transaction")
	m.data.SetDescription("User rollback undo records applied per transaction")
	m.data.SetUnit("{records}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction(cfg MetricConfig) metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction {
	m := metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbUserRollbacksPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.user_rollbacks_per_second metric with initial data.
func (m *metricNewrelicOracleDbUserRollbacksPerSecond) init() {
	m.data.SetName("newrelic.oracle.db.user_rollbacks_per_second")
	m.data.SetDescription("User rollbacks per second")
	m.data.SetUnit("{rollbacks}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbUserRollbacksPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbUserRollbacksPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbUserRollbacksPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbUserRollbacksPerSecond(cfg MetricConfig) metricNewrelicOracleDbUserRollbacksPerSecond {
	m := metricNewrelicOracleDbUserRollbacksPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbUserRollbacksPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.user_rollbacks_percentage metric with initial data.
func (m *metricNewrelicOracleDbUserRollbacksPercentage) init() {
	m.data.SetName("newrelic.oracle.db.user_rollbacks_percentage")
	m.data.SetDescription("User rollbacks percentage")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbUserRollbacksPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbUserRollbacksPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbUserRollbacksPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbUserRollbacksPercentage(cfg MetricConfig) metricNewrelicOracleDbUserRollbacksPercentage {
	m := metricNewrelicOracleDbUserRollbacksPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDbWaitTimeRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.db.wait_time_ratio metric with initial data.
func (m *metricNewrelicOracleDbWaitTimeRatio) init() {
	m.data.SetName("newrelic.oracle.db.wait_time_ratio")
	m.data.SetDescription("Database wait time ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDbWaitTimeRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDbWaitTimeRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDbWaitTimeRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDbWaitTimeRatio(cfg MetricConfig) metricNewrelicOracleDbWaitTimeRatio {
	m := metricNewrelicOracleDbWaitTimeRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskBlocksRead struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.blocks_read metric with initial data.
func (m *metricNewrelicOracleDiskBlocksRead) init() {
	m.data.SetName("newrelic.oracle.disk.blocks_read")
	m.data.SetDescription("Physical blocks read")
	m.data.SetUnit("{blocks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricNewrelicOracleDiskBlocksRead) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskBlocksRead) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskBlocksRead) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskBlocksRead(cfg MetricConfig) metricNewrelicOracleDiskBlocksRead {
	m := metricNewrelicOracleDiskBlocksRead{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskBlocksWritten struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.blocks_written metric with initial data.
func (m *metricNewrelicOracleDiskBlocksWritten) init() {
	m.data.SetName("newrelic.oracle.disk.blocks_written")
	m.data.SetDescription("Physical blocks written")
	m.data.SetUnit("{blocks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricNewrelicOracleDiskBlocksWritten) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskBlocksWritten) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskBlocksWritten) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskBlocksWritten(cfg MetricConfig) metricNewrelicOracleDiskBlocksWritten {
	m := metricNewrelicOracleDiskBlocksWritten{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskLogicalReadsPerUserCall struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.logical_reads_per_user_call metric with initial data.
func (m *metricNewrelicOracleDiskLogicalReadsPerUserCall) init() {
	m.data.SetName("newrelic.oracle.disk.logical_reads_per_user_call")
	m.data.SetDescription("Logical reads per user call")
	m.data.SetUnit("{reads}/{call}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDiskLogicalReadsPerUserCall) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskLogicalReadsPerUserCall) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskLogicalReadsPerUserCall) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskLogicalReadsPerUserCall(cfg MetricConfig) metricNewrelicOracleDiskLogicalReadsPerUserCall {
	m := metricNewrelicOracleDiskLogicalReadsPerUserCall{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskPhysicalLobsReadsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.physical_lobs_reads_per_second metric with initial data.
func (m *metricNewrelicOracleDiskPhysicalLobsReadsPerSecond) init() {
	m.data.SetName("newrelic.oracle.disk.physical_lobs_reads_per_second")
	m.data.SetDescription("Physical LOB reads per second")
	m.data.SetUnit("{reads}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDiskPhysicalLobsReadsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskPhysicalLobsReadsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskPhysicalLobsReadsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskPhysicalLobsReadsPerSecond(cfg MetricConfig) metricNewrelicOracleDiskPhysicalLobsReadsPerSecond {
	m := metricNewrelicOracleDiskPhysicalLobsReadsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskPhysicalLobsWritesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.physical_lobs_writes_per_second metric with initial data.
func (m *metricNewrelicOracleDiskPhysicalLobsWritesPerSecond) init() {
	m.data.SetName("newrelic.oracle.disk.physical_lobs_writes_per_second")
	m.data.SetDescription("Physical LOB writes per second")
	m.data.SetUnit("{writes}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDiskPhysicalLobsWritesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskPhysicalLobsWritesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskPhysicalLobsWritesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskPhysicalLobsWritesPerSecond(cfg MetricConfig) metricNewrelicOracleDiskPhysicalLobsWritesPerSecond {
	m := metricNewrelicOracleDiskPhysicalLobsWritesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskPhysicalReadBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.physical_read_bytes_per_second metric with initial data.
func (m *metricNewrelicOracleDiskPhysicalReadBytesPerSecond) init() {
	m.data.SetName("newrelic.oracle.disk.physical_read_bytes_per_second")
	m.data.SetDescription("Physical read bytes per second")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDiskPhysicalReadBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskPhysicalReadBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskPhysicalReadBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskPhysicalReadBytesPerSecond(cfg MetricConfig) metricNewrelicOracleDiskPhysicalReadBytesPerSecond {
	m := metricNewrelicOracleDiskPhysicalReadBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.physical_read_io_requests_per_second metric with initial data.
func (m *metricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond) init() {
	m.data.SetName("newrelic.oracle.disk.physical_read_io_requests_per_second")
	m.data.SetDescription("Physical read I/O requests per second")
	m.data.SetUnit("{requests}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond(cfg MetricConfig) metricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond {
	m := metricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskPhysicalReadsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.physical_reads_per_second metric with initial data.
func (m *metricNewrelicOracleDiskPhysicalReadsPerSecond) init() {
	m.data.SetName("newrelic.oracle.disk.physical_reads_per_second")
	m.data.SetDescription("Physical reads per second")
	m.data.SetUnit("{reads}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDiskPhysicalReadsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskPhysicalReadsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskPhysicalReadsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskPhysicalReadsPerSecond(cfg MetricConfig) metricNewrelicOracleDiskPhysicalReadsPerSecond {
	m := metricNewrelicOracleDiskPhysicalReadsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskPhysicalWriteBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.physical_write_bytes_per_second metric with initial data.
func (m *metricNewrelicOracleDiskPhysicalWriteBytesPerSecond) init() {
	m.data.SetName("newrelic.oracle.disk.physical_write_bytes_per_second")
	m.data.SetDescription("Physical write bytes per second")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDiskPhysicalWriteBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskPhysicalWriteBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskPhysicalWriteBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskPhysicalWriteBytesPerSecond(cfg MetricConfig) metricNewrelicOracleDiskPhysicalWriteBytesPerSecond {
	m := metricNewrelicOracleDiskPhysicalWriteBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.physical_write_total_io_requests_per_second metric with initial data.
func (m *metricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond) init() {
	m.data.SetName("newrelic.oracle.disk.physical_write_total_io_requests_per_second")
	m.data.SetDescription("Physical write total I/O requests per second")
	m.data.SetUnit("{requests}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond(cfg MetricConfig) metricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond {
	m := metricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskPhysicalWritesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.physical_writes_per_second metric with initial data.
func (m *metricNewrelicOracleDiskPhysicalWritesPerSecond) init() {
	m.data.SetName("newrelic.oracle.disk.physical_writes_per_second")
	m.data.SetDescription("Physical writes per second")
	m.data.SetUnit("{writes}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDiskPhysicalWritesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskPhysicalWritesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskPhysicalWritesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskPhysicalWritesPerSecond(cfg MetricConfig) metricNewrelicOracleDiskPhysicalWritesPerSecond {
	m := metricNewrelicOracleDiskPhysicalWritesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskReadTimeMilliseconds struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.read_time_milliseconds metric with initial data.
func (m *metricNewrelicOracleDiskReadTimeMilliseconds) init() {
	m.data.SetName("newrelic.oracle.disk.read_time_milliseconds")
	m.data.SetDescription("Disk read time in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricNewrelicOracleDiskReadTimeMilliseconds) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskReadTimeMilliseconds) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskReadTimeMilliseconds) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskReadTimeMilliseconds(cfg MetricConfig) metricNewrelicOracleDiskReadTimeMilliseconds {
	m := metricNewrelicOracleDiskReadTimeMilliseconds{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.reads metric with initial data.
func (m *metricNewrelicOracleDiskReads) init() {
	m.data.SetName("newrelic.oracle.disk.reads")
	m.data.SetDescription("Physical disk reads")
	m.data.SetUnit("{reads}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricNewrelicOracleDiskReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskReads) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskReads(cfg MetricConfig) metricNewrelicOracleDiskReads {
	m := metricNewrelicOracleDiskReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskSortPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.sort_per_second metric with initial data.
func (m *metricNewrelicOracleDiskSortPerSecond) init() {
	m.data.SetName("newrelic.oracle.disk.sort_per_second")
	m.data.SetDescription("Disk sorts per second")
	m.data.SetUnit("{sorts}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDiskSortPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskSortPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskSortPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskSortPerSecond(cfg MetricConfig) metricNewrelicOracleDiskSortPerSecond {
	m := metricNewrelicOracleDiskSortPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskSortPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.sort_per_transaction metric with initial data.
func (m *metricNewrelicOracleDiskSortPerTransaction) init() {
	m.data.SetName("newrelic.oracle.disk.sort_per_transaction")
	m.data.SetDescription("Disk sorts per transaction")
	m.data.SetUnit("{sorts}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDiskSortPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskSortPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskSortPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskSortPerTransaction(cfg MetricConfig) metricNewrelicOracleDiskSortPerTransaction {
	m := metricNewrelicOracleDiskSortPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskTempSpaceUsedBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.temp_space_used_bytes metric with initial data.
func (m *metricNewrelicOracleDiskTempSpaceUsedBytes) init() {
	m.data.SetName("newrelic.oracle.disk.temp_space_used_bytes")
	m.data.SetDescription("Temporary space used in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleDiskTempSpaceUsedBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskTempSpaceUsedBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskTempSpaceUsedBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskTempSpaceUsedBytes(cfg MetricConfig) metricNewrelicOracleDiskTempSpaceUsedBytes {
	m := metricNewrelicOracleDiskTempSpaceUsedBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskWriteTimeMilliseconds struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.write_time_milliseconds metric with initial data.
func (m *metricNewrelicOracleDiskWriteTimeMilliseconds) init() {
	m.data.SetName("newrelic.oracle.disk.write_time_milliseconds")
	m.data.SetDescription("Disk write time in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricNewrelicOracleDiskWriteTimeMilliseconds) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskWriteTimeMilliseconds) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskWriteTimeMilliseconds) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskWriteTimeMilliseconds(cfg MetricConfig) metricNewrelicOracleDiskWriteTimeMilliseconds {
	m := metricNewrelicOracleDiskWriteTimeMilliseconds{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleDiskWrites struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.disk.writes metric with initial data.
func (m *metricNewrelicOracleDiskWrites) init() {
	m.data.SetName("newrelic.oracle.disk.writes")
	m.data.SetDescription("Physical disk writes")
	m.data.SetUnit("{writes}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricNewrelicOracleDiskWrites) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleDiskWrites) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleDiskWrites) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleDiskWrites(cfg MetricConfig) metricNewrelicOracleDiskWrites {
	m := metricNewrelicOracleDiskWrites{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleLockedAccounts struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.locked_accounts metric with initial data.
func (m *metricNewrelicOracleLockedAccounts) init() {
	m.data.SetName("newrelic.oracle.locked_accounts")
	m.data.SetDescription("Number of locked user accounts")
	m.data.SetUnit("{accounts}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicOracleLockedAccounts) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("instance_id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleLockedAccounts) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleLockedAccounts) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleLockedAccounts(cfg MetricConfig) metricNewrelicOracleLockedAccounts {
	m := metricNewrelicOracleLockedAccounts{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleLongRunningQueries struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.long_running_queries metric with initial data.
func (m *metricNewrelicOracleLongRunningQueries) init() {
	m.data.SetName("newrelic.oracle.long_running_queries")
	m.data.SetDescription("Number of long running queries (> 60 seconds)")
	m.data.SetUnit("{queries}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicOracleLongRunningQueries) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, instanceIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("instance_id", instanceIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleLongRunningQueries) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleLongRunningQueries) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleLongRunningQueries(cfg MetricConfig) metricNewrelicOracleLongRunningQueries {
	m := metricNewrelicOracleLongRunningQueries{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleMemoryBufferCacheHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.memory.buffer_cache_hit_ratio metric with initial data.
func (m *metricNewrelicOracleMemoryBufferCacheHitRatio) init() {
	m.data.SetName("newrelic.oracle.memory.buffer_cache_hit_ratio")
	m.data.SetDescription("Buffer cache hit ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleMemoryBufferCacheHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleMemoryBufferCacheHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleMemoryBufferCacheHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleMemoryBufferCacheHitRatio(cfg MetricConfig) metricNewrelicOracleMemoryBufferCacheHitRatio {
	m := metricNewrelicOracleMemoryBufferCacheHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleMemoryGlobalCacheBlocksCorrupted struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.memory.global_cache_blocks_corrupted metric with initial data.
func (m *metricNewrelicOracleMemoryGlobalCacheBlocksCorrupted) init() {
	m.data.SetName("newrelic.oracle.memory.global_cache_blocks_corrupted")
	m.data.SetDescription("Global cache blocks corrupted")
	m.data.SetUnit("{blocks}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleMemoryGlobalCacheBlocksCorrupted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleMemoryGlobalCacheBlocksCorrupted) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleMemoryGlobalCacheBlocksCorrupted) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleMemoryGlobalCacheBlocksCorrupted(cfg MetricConfig) metricNewrelicOracleMemoryGlobalCacheBlocksCorrupted {
	m := metricNewrelicOracleMemoryGlobalCacheBlocksCorrupted{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleMemoryGlobalCacheBlocksLost struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.memory.global_cache_blocks_lost metric with initial data.
func (m *metricNewrelicOracleMemoryGlobalCacheBlocksLost) init() {
	m.data.SetName("newrelic.oracle.memory.global_cache_blocks_lost")
	m.data.SetDescription("Global cache blocks lost")
	m.data.SetUnit("{blocks}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleMemoryGlobalCacheBlocksLost) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleMemoryGlobalCacheBlocksLost) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleMemoryGlobalCacheBlocksLost) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleMemoryGlobalCacheBlocksLost(cfg MetricConfig) metricNewrelicOracleMemoryGlobalCacheBlocksLost {
	m := metricNewrelicOracleMemoryGlobalCacheBlocksLost{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleMemoryPgaAllocatedBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.memory.pga_allocated_bytes metric with initial data.
func (m *metricNewrelicOracleMemoryPgaAllocatedBytes) init() {
	m.data.SetName("newrelic.oracle.memory.pga_allocated_bytes")
	m.data.SetDescription("PGA memory allocated in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleMemoryPgaAllocatedBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleMemoryPgaAllocatedBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleMemoryPgaAllocatedBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleMemoryPgaAllocatedBytes(cfg MetricConfig) metricNewrelicOracleMemoryPgaAllocatedBytes {
	m := metricNewrelicOracleMemoryPgaAllocatedBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleMemoryPgaFreeableBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.memory.pga_freeable_bytes metric with initial data.
func (m *metricNewrelicOracleMemoryPgaFreeableBytes) init() {
	m.data.SetName("newrelic.oracle.memory.pga_freeable_bytes")
	m.data.SetDescription("PGA freeable memory in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleMemoryPgaFreeableBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleMemoryPgaFreeableBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleMemoryPgaFreeableBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleMemoryPgaFreeableBytes(cfg MetricConfig) metricNewrelicOracleMemoryPgaFreeableBytes {
	m := metricNewrelicOracleMemoryPgaFreeableBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleMemoryPgaInUseBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.memory.pga_in_use_bytes metric with initial data.
func (m *metricNewrelicOracleMemoryPgaInUseBytes) init() {
	m.data.SetName("newrelic.oracle.memory.pga_in_use_bytes")
	m.data.SetDescription("PGA memory in use in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleMemoryPgaInUseBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleMemoryPgaInUseBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleMemoryPgaInUseBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleMemoryPgaInUseBytes(cfg MetricConfig) metricNewrelicOracleMemoryPgaInUseBytes {
	m := metricNewrelicOracleMemoryPgaInUseBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleMemoryPgaMaxSizeBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.memory.pga_max_size_bytes metric with initial data.
func (m *metricNewrelicOracleMemoryPgaMaxSizeBytes) init() {
	m.data.SetName("newrelic.oracle.memory.pga_max_size_bytes")
	m.data.SetDescription("PGA maximum size in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleMemoryPgaMaxSizeBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleMemoryPgaMaxSizeBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleMemoryPgaMaxSizeBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleMemoryPgaMaxSizeBytes(cfg MetricConfig) metricNewrelicOracleMemoryPgaMaxSizeBytes {
	m := metricNewrelicOracleMemoryPgaMaxSizeBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleMemoryRedoAllocationHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.memory.redo_allocation_hit_ratio metric with initial data.
func (m *metricNewrelicOracleMemoryRedoAllocationHitRatio) init() {
	m.data.SetName("newrelic.oracle.memory.redo_allocation_hit_ratio")
	m.data.SetDescription("Redo allocation hit ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleMemoryRedoAllocationHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleMemoryRedoAllocationHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleMemoryRedoAllocationHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleMemoryRedoAllocationHitRatio(cfg MetricConfig) metricNewrelicOracleMemoryRedoAllocationHitRatio {
	m := metricNewrelicOracleMemoryRedoAllocationHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleMemoryRedoGeneratedBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.memory.redo_generated_bytes_per_second metric with initial data.
func (m *metricNewrelicOracleMemoryRedoGeneratedBytesPerSecond) init() {
	m.data.SetName("newrelic.oracle.memory.redo_generated_bytes_per_second")
	m.data.SetDescription("Redo generated bytes per second")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleMemoryRedoGeneratedBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleMemoryRedoGeneratedBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleMemoryRedoGeneratedBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleMemoryRedoGeneratedBytesPerSecond(cfg MetricConfig) metricNewrelicOracleMemoryRedoGeneratedBytesPerSecond {
	m := metricNewrelicOracleMemoryRedoGeneratedBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.memory.redo_generated_bytes_per_transaction metric with initial data.
func (m *metricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction) init() {
	m.data.SetName("newrelic.oracle.memory.redo_generated_bytes_per_transaction")
	m.data.SetDescription("Redo generated bytes per transaction")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction(cfg MetricConfig) metricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction {
	m := metricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleMemorySortsRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.memory.sorts_ratio metric with initial data.
func (m *metricNewrelicOracleMemorySortsRatio) init() {
	m.data.SetName("newrelic.oracle.memory.sorts_ratio")
	m.data.SetDescription("Memory sorts ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleMemorySortsRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleMemorySortsRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleMemorySortsRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleMemorySortsRatio(cfg MetricConfig) metricNewrelicOracleMemorySortsRatio {
	m := metricNewrelicOracleMemorySortsRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleNetworkIoMegabytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.network.io_megabytes_per_second metric with initial data.
func (m *metricNewrelicOracleNetworkIoMegabytesPerSecond) init() {
	m.data.SetName("newrelic.oracle.network.io_megabytes_per_second")
	m.data.SetDescription("I/O megabytes per second")
	m.data.SetUnit("MBy/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleNetworkIoMegabytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleNetworkIoMegabytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleNetworkIoMegabytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleNetworkIoMegabytesPerSecond(cfg MetricConfig) metricNewrelicOracleNetworkIoMegabytesPerSecond {
	m := metricNewrelicOracleNetworkIoMegabytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleNetworkIoRequestsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.network.io_requests_per_second metric with initial data.
func (m *metricNewrelicOracleNetworkIoRequestsPerSecond) init() {
	m.data.SetName("newrelic.oracle.network.io_requests_per_second")
	m.data.SetDescription("I/O requests per second")
	m.data.SetUnit("{requests}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleNetworkIoRequestsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleNetworkIoRequestsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleNetworkIoRequestsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleNetworkIoRequestsPerSecond(cfg MetricConfig) metricNewrelicOracleNetworkIoRequestsPerSecond {
	m := metricNewrelicOracleNetworkIoRequestsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleNetworkTrafficBytesPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.network.traffic_bytes_per_second metric with initial data.
func (m *metricNewrelicOracleNetworkTrafficBytesPerSecond) init() {
	m.data.SetName("newrelic.oracle.network.traffic_bytes_per_second")
	m.data.SetDescription("Network traffic volume per second")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleNetworkTrafficBytesPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleNetworkTrafficBytesPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleNetworkTrafficBytesPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleNetworkTrafficBytesPerSecond(cfg MetricConfig) metricNewrelicOracleNetworkTrafficBytesPerSecond {
	m := metricNewrelicOracleNetworkTrafficBytesPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleQueryPhysicalLobsReadsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.query.physical_lobs_reads_per_transaction metric with initial data.
func (m *metricNewrelicOracleQueryPhysicalLobsReadsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.query.physical_lobs_reads_per_transaction")
	m.data.SetDescription("Physical LOB reads per transaction")
	m.data.SetUnit("{reads}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleQueryPhysicalLobsReadsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleQueryPhysicalLobsReadsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleQueryPhysicalLobsReadsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleQueryPhysicalLobsReadsPerTransaction(cfg MetricConfig) metricNewrelicOracleQueryPhysicalLobsReadsPerTransaction {
	m := metricNewrelicOracleQueryPhysicalLobsReadsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleQueryPhysicalLobsWritesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.query.physical_lobs_writes_per_transaction metric with initial data.
func (m *metricNewrelicOracleQueryPhysicalLobsWritesPerTransaction) init() {
	m.data.SetName("newrelic.oracle.query.physical_lobs_writes_per_transaction")
	m.data.SetDescription("Physical LOB writes per transaction")
	m.data.SetUnit("{writes}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleQueryPhysicalLobsWritesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleQueryPhysicalLobsWritesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleQueryPhysicalLobsWritesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleQueryPhysicalLobsWritesPerTransaction(cfg MetricConfig) metricNewrelicOracleQueryPhysicalLobsWritesPerTransaction {
	m := metricNewrelicOracleQueryPhysicalLobsWritesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleQueryPhysicalReadsPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.query.physical_reads_per_transaction metric with initial data.
func (m *metricNewrelicOracleQueryPhysicalReadsPerTransaction) init() {
	m.data.SetName("newrelic.oracle.query.physical_reads_per_transaction")
	m.data.SetDescription("Physical reads per transaction")
	m.data.SetUnit("{reads}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleQueryPhysicalReadsPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleQueryPhysicalReadsPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleQueryPhysicalReadsPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleQueryPhysicalReadsPerTransaction(cfg MetricConfig) metricNewrelicOracleQueryPhysicalReadsPerTransaction {
	m := metricNewrelicOracleQueryPhysicalReadsPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleQueryPhysicalWritesPerTransaction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.query.physical_writes_per_transaction metric with initial data.
func (m *metricNewrelicOracleQueryPhysicalWritesPerTransaction) init() {
	m.data.SetName("newrelic.oracle.query.physical_writes_per_transaction")
	m.data.SetDescription("Physical writes per transaction")
	m.data.SetUnit("{writes}/{transaction}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleQueryPhysicalWritesPerTransaction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleQueryPhysicalWritesPerTransaction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleQueryPhysicalWritesPerTransaction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleQueryPhysicalWritesPerTransaction(cfg MetricConfig) metricNewrelicOracleQueryPhysicalWritesPerTransaction {
	m := metricNewrelicOracleQueryPhysicalWritesPerTransaction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleQueryTransactionsPerSecond struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.query.transactions_per_second metric with initial data.
func (m *metricNewrelicOracleQueryTransactionsPerSecond) init() {
	m.data.SetName("newrelic.oracle.query.transactions_per_second")
	m.data.SetDescription("User transactions per second")
	m.data.SetUnit("{transactions}/s")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleQueryTransactionsPerSecond) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleQueryTransactionsPerSecond) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleQueryTransactionsPerSecond) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleQueryTransactionsPerSecond(cfg MetricConfig) metricNewrelicOracleQueryTransactionsPerSecond {
	m := metricNewrelicOracleQueryTransactionsPerSecond{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleRedoLogFileSwitch struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.redo_log.file_switch metric with initial data.
func (m *metricNewrelicOracleRedoLogFileSwitch) init() {
	m.data.SetName("newrelic.oracle.redo_log.file_switch")
	m.data.SetDescription("Log file switch completion")
	m.data.SetUnit("{switches}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleRedoLogFileSwitch) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleRedoLogFileSwitch) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleRedoLogFileSwitch) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleRedoLogFileSwitch(cfg MetricConfig) metricNewrelicOracleRedoLogFileSwitch {
	m := metricNewrelicOracleRedoLogFileSwitch{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleRedoLogFileSwitchArchivingNeeded struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.redo_log.file_switch_archiving_needed metric with initial data.
func (m *metricNewrelicOracleRedoLogFileSwitchArchivingNeeded) init() {
	m.data.SetName("newrelic.oracle.redo_log.file_switch_archiving_needed")
	m.data.SetDescription("Log file switch due to archiving needed")
	m.data.SetUnit("{switches}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleRedoLogFileSwitchArchivingNeeded) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleRedoLogFileSwitchArchivingNeeded) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleRedoLogFileSwitchArchivingNeeded) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleRedoLogFileSwitchArchivingNeeded(cfg MetricConfig) metricNewrelicOracleRedoLogFileSwitchArchivingNeeded {
	m := metricNewrelicOracleRedoLogFileSwitchArchivingNeeded{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.redo_log.file_switch_checkpoint_incomplete metric with initial data.
func (m *metricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete) init() {
	m.data.SetName("newrelic.oracle.redo_log.file_switch_checkpoint_incomplete")
	m.data.SetDescription("Log file switch due to checkpoint incomplete")
	m.data.SetUnit("{switches}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete(cfg MetricConfig) metricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete {
	m := metricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleRedoLogWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.redo_log.waits metric with initial data.
func (m *metricNewrelicOracleRedoLogWaits) init() {
	m.data.SetName("newrelic.oracle.redo_log.waits")
	m.data.SetDescription("Redo log waits")
	m.data.SetUnit("{waits}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleRedoLogWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleRedoLogWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleRedoLogWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleRedoLogWaits(cfg MetricConfig) metricNewrelicOracleRedoLogWaits {
	m := metricNewrelicOracleRedoLogWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleRollbackSegmentsGets struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.rollback_segments.gets metric with initial data.
func (m *metricNewrelicOracleRollbackSegmentsGets) init() {
	m.data.SetName("newrelic.oracle.rollback_segments.gets")
	m.data.SetDescription("Rollback segment gets")
	m.data.SetUnit("{gets}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleRollbackSegmentsGets) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleRollbackSegmentsGets) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleRollbackSegmentsGets) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleRollbackSegmentsGets(cfg MetricConfig) metricNewrelicOracleRollbackSegmentsGets {
	m := metricNewrelicOracleRollbackSegmentsGets{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleRollbackSegmentsRatioWait struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.rollback_segments.ratio_wait metric with initial data.
func (m *metricNewrelicOracleRollbackSegmentsRatioWait) init() {
	m.data.SetName("newrelic.oracle.rollback_segments.ratio_wait")
	m.data.SetDescription("Rollback segment wait ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleRollbackSegmentsRatioWait) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleRollbackSegmentsRatioWait) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleRollbackSegmentsRatioWait) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleRollbackSegmentsRatioWait(cfg MetricConfig) metricNewrelicOracleRollbackSegmentsRatioWait {
	m := metricNewrelicOracleRollbackSegmentsRatioWait{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleRollbackSegmentsWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.rollback_segments.waits metric with initial data.
func (m *metricNewrelicOracleRollbackSegmentsWaits) init() {
	m.data.SetName("newrelic.oracle.rollback_segments.waits")
	m.data.SetDescription("Rollback segment waits")
	m.data.SetUnit("{waits}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleRollbackSegmentsWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleRollbackSegmentsWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleRollbackSegmentsWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleRollbackSegmentsWaits(cfg MetricConfig) metricNewrelicOracleRollbackSegmentsWaits {
	m := metricNewrelicOracleRollbackSegmentsWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaBufferBusyWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.buffer_busy_waits metric with initial data.
func (m *metricNewrelicOracleSgaBufferBusyWaits) init() {
	m.data.SetName("newrelic.oracle.sga.buffer_busy_waits")
	m.data.SetDescription("Buffer busy waits")
	m.data.SetUnit("{waits}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaBufferBusyWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaBufferBusyWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaBufferBusyWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaBufferBusyWaits(cfg MetricConfig) metricNewrelicOracleSgaBufferBusyWaits {
	m := metricNewrelicOracleSgaBufferBusyWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaFixedSizeBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.fixed_size_bytes metric with initial data.
func (m *metricNewrelicOracleSgaFixedSizeBytes) init() {
	m.data.SetName("newrelic.oracle.sga.fixed_size_bytes")
	m.data.SetDescription("SGA fixed size area in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaFixedSizeBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaFixedSizeBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaFixedSizeBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaFixedSizeBytes(cfg MetricConfig) metricNewrelicOracleSgaFixedSizeBytes {
	m := metricNewrelicOracleSgaFixedSizeBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaFreeBufferInspected struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.free_buffer_inspected metric with initial data.
func (m *metricNewrelicOracleSgaFreeBufferInspected) init() {
	m.data.SetName("newrelic.oracle.sga.free_buffer_inspected")
	m.data.SetDescription("Free buffer inspected")
	m.data.SetUnit("{buffers}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaFreeBufferInspected) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaFreeBufferInspected) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaFreeBufferInspected) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaFreeBufferInspected(cfg MetricConfig) metricNewrelicOracleSgaFreeBufferInspected {
	m := metricNewrelicOracleSgaFreeBufferInspected{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaFreeBufferWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.free_buffer_waits metric with initial data.
func (m *metricNewrelicOracleSgaFreeBufferWaits) init() {
	m.data.SetName("newrelic.oracle.sga.free_buffer_waits")
	m.data.SetDescription("Free buffer waits")
	m.data.SetUnit("{waits}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaFreeBufferWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaFreeBufferWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaFreeBufferWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaFreeBufferWaits(cfg MetricConfig) metricNewrelicOracleSgaFreeBufferWaits {
	m := metricNewrelicOracleSgaFreeBufferWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.hit_ratio metric with initial data.
func (m *metricNewrelicOracleSgaHitRatio) init() {
	m.data.SetName("newrelic.oracle.sga.hit_ratio")
	m.data.SetDescription("SGA buffer cache hit ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaHitRatio(cfg MetricConfig) metricNewrelicOracleSgaHitRatio {
	m := metricNewrelicOracleSgaHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaLogBufferAllocationRetriesRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.log_buffer_allocation_retries_ratio metric with initial data.
func (m *metricNewrelicOracleSgaLogBufferAllocationRetriesRatio) init() {
	m.data.SetName("newrelic.oracle.sga.log_buffer_allocation_retries_ratio")
	m.data.SetDescription("Log buffer allocation retries ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaLogBufferAllocationRetriesRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaLogBufferAllocationRetriesRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaLogBufferAllocationRetriesRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaLogBufferAllocationRetriesRatio(cfg MetricConfig) metricNewrelicOracleSgaLogBufferAllocationRetriesRatio {
	m := metricNewrelicOracleSgaLogBufferAllocationRetriesRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaLogBufferRedoAllocationRetries struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.log_buffer_redo_allocation_retries metric with initial data.
func (m *metricNewrelicOracleSgaLogBufferRedoAllocationRetries) init() {
	m.data.SetName("newrelic.oracle.sga.log_buffer_redo_allocation_retries")
	m.data.SetDescription("Log buffer redo allocation retries")
	m.data.SetUnit("{retries}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaLogBufferRedoAllocationRetries) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaLogBufferRedoAllocationRetries) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaLogBufferRedoAllocationRetries) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaLogBufferRedoAllocationRetries(cfg MetricConfig) metricNewrelicOracleSgaLogBufferRedoAllocationRetries {
	m := metricNewrelicOracleSgaLogBufferRedoAllocationRetries{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaLogBufferRedoEntries struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.log_buffer_redo_entries metric with initial data.
func (m *metricNewrelicOracleSgaLogBufferRedoEntries) init() {
	m.data.SetName("newrelic.oracle.sga.log_buffer_redo_entries")
	m.data.SetDescription("Log buffer redo entries")
	m.data.SetUnit("{entries}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaLogBufferRedoEntries) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaLogBufferRedoEntries) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaLogBufferRedoEntries) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaLogBufferRedoEntries(cfg MetricConfig) metricNewrelicOracleSgaLogBufferRedoEntries {
	m := metricNewrelicOracleSgaLogBufferRedoEntries{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaLogBufferSpaceWaits struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.log_buffer_space_waits metric with initial data.
func (m *metricNewrelicOracleSgaLogBufferSpaceWaits) init() {
	m.data.SetName("newrelic.oracle.sga.log_buffer_space_waits")
	m.data.SetDescription("Number of log buffer space waits")
	m.data.SetUnit("{waits}")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaLogBufferSpaceWaits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaLogBufferSpaceWaits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaLogBufferSpaceWaits) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaLogBufferSpaceWaits(cfg MetricConfig) metricNewrelicOracleSgaLogBufferSpaceWaits {
	m := metricNewrelicOracleSgaLogBufferSpaceWaits{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaRedoBuffersBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.redo_buffers_bytes metric with initial data.
func (m *metricNewrelicOracleSgaRedoBuffersBytes) init() {
	m.data.SetName("newrelic.oracle.sga.redo_buffers_bytes")
	m.data.SetDescription("SGA redo buffers size in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaRedoBuffersBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaRedoBuffersBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaRedoBuffersBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaRedoBuffersBytes(cfg MetricConfig) metricNewrelicOracleSgaRedoBuffersBytes {
	m := metricNewrelicOracleSgaRedoBuffersBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaSharedPoolDictCacheMissRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.shared_pool_dict_cache_miss_ratio metric with initial data.
func (m *metricNewrelicOracleSgaSharedPoolDictCacheMissRatio) init() {
	m.data.SetName("newrelic.oracle.sga.shared_pool_dict_cache_miss_ratio")
	m.data.SetDescription("Shared pool dictionary cache miss ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaSharedPoolDictCacheMissRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaSharedPoolDictCacheMissRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaSharedPoolDictCacheMissRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaSharedPoolDictCacheMissRatio(cfg MetricConfig) metricNewrelicOracleSgaSharedPoolDictCacheMissRatio {
	m := metricNewrelicOracleSgaSharedPoolDictCacheMissRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.shared_pool_library_cache_hit_ratio metric with initial data.
func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio) init() {
	m.data.SetName("newrelic.oracle.sga.shared_pool_library_cache_hit_ratio")
	m.data.SetDescription("Shared pool library cache hit ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio(cfg MetricConfig) metricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio {
	m := metricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.shared_pool_library_cache_reload_ratio metric with initial data.
func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio) init() {
	m.data.SetName("newrelic.oracle.sga.shared_pool_library_cache_reload_ratio")
	m.data.SetDescription("Shared pool library cache reload ratio")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio(cfg MetricConfig) metricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio {
	m := metricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.shared_pool_library_cache_shareable_memory_per_statement_bytes metric with initial data.
func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes) init() {
	m.data.SetName("newrelic.oracle.sga.shared_pool_library_cache_shareable_memory_per_statement_bytes")
	m.data.SetDescription("Shared pool library cache shareable memory per statement in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes(cfg MetricConfig) metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes {
	m := metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.shared_pool_library_cache_shareable_memory_per_user_bytes metric with initial data.
func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes) init() {
	m.data.SetName("newrelic.oracle.sga.shared_pool_library_cache_shareable_memory_per_user_bytes")
	m.data.SetDescription("Shared pool library cache shareable memory per user in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes(cfg MetricConfig) metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes {
	m := metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSgaUgaTotalMemoryBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sga.uga_total_memory_bytes metric with initial data.
func (m *metricNewrelicOracleSgaUgaTotalMemoryBytes) init() {
	m.data.SetName("newrelic.oracle.sga.uga_total_memory_bytes")
	m.data.SetDescription("UGA total memory in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSgaUgaTotalMemoryBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSgaUgaTotalMemoryBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSgaUgaTotalMemoryBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSgaUgaTotalMemoryBytes(cfg MetricConfig) metricNewrelicOracleSgaUgaTotalMemoryBytes {
	m := metricNewrelicOracleSgaUgaTotalMemoryBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSortsDiskBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sorts.disk_bytes metric with initial data.
func (m *metricNewrelicOracleSortsDiskBytes) init() {
	m.data.SetName("newrelic.oracle.sorts.disk_bytes")
	m.data.SetDescription("Sorts performed on disk in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSortsDiskBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSortsDiskBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSortsDiskBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSortsDiskBytes(cfg MetricConfig) metricNewrelicOracleSortsDiskBytes {
	m := metricNewrelicOracleSortsDiskBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleSortsMemoryBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.sorts.memory_bytes metric with initial data.
func (m *metricNewrelicOracleSortsMemoryBytes) init() {
	m.data.SetName("newrelic.oracle.sorts.memory_bytes")
	m.data.SetDescription("Sorts performed in memory in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricNewrelicOracleSortsMemoryBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleSortsMemoryBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleSortsMemoryBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleSortsMemoryBytes(cfg MetricConfig) metricNewrelicOracleSortsMemoryBytes {
	m := metricNewrelicOracleSortsMemoryBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleTablespaceIsOffline struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.tablespace.is_offline metric with initial data.
func (m *metricNewrelicOracleTablespaceIsOffline) init() {
	m.data.SetName("newrelic.oracle.tablespace.is_offline")
	m.data.SetDescription("Tablespace offline status (1 if offline, 0 if online)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicOracleTablespaceIsOffline) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("tablespace_name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleTablespaceIsOffline) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleTablespaceIsOffline) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleTablespaceIsOffline(cfg MetricConfig) metricNewrelicOracleTablespaceIsOffline {
	m := metricNewrelicOracleTablespaceIsOffline{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleTablespaceOfflineCdbDatafiles struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.tablespace.offline_cdb_datafiles metric with initial data.
func (m *metricNewrelicOracleTablespaceOfflineCdbDatafiles) init() {
	m.data.SetName("newrelic.oracle.tablespace.offline_cdb_datafiles")
	m.data.SetDescription("Number of offline CDB datafiles in tablespace")
	m.data.SetUnit("{datafiles}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicOracleTablespaceOfflineCdbDatafiles) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("tablespace_name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleTablespaceOfflineCdbDatafiles) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleTablespaceOfflineCdbDatafiles) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleTablespaceOfflineCdbDatafiles(cfg MetricConfig) metricNewrelicOracleTablespaceOfflineCdbDatafiles {
	m := metricNewrelicOracleTablespaceOfflineCdbDatafiles{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleTablespaceOfflinePdbDatafiles struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.tablespace.offline_pdb_datafiles metric with initial data.
func (m *metricNewrelicOracleTablespaceOfflinePdbDatafiles) init() {
	m.data.SetName("newrelic.oracle.tablespace.offline_pdb_datafiles")
	m.data.SetDescription("Number of offline PDB datafiles in tablespace")
	m.data.SetUnit("{datafiles}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicOracleTablespaceOfflinePdbDatafiles) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("tablespace_name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleTablespaceOfflinePdbDatafiles) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleTablespaceOfflinePdbDatafiles) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleTablespaceOfflinePdbDatafiles(cfg MetricConfig) metricNewrelicOracleTablespaceOfflinePdbDatafiles {
	m := metricNewrelicOracleTablespaceOfflinePdbDatafiles{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleTablespacePdbDatafilesNonWrite struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.tablespace.pdb_datafiles_non_write metric with initial data.
func (m *metricNewrelicOracleTablespacePdbDatafilesNonWrite) init() {
	m.data.SetName("newrelic.oracle.tablespace.pdb_datafiles_non_write")
	m.data.SetDescription("Number of PDB datafiles in non-write mode in tablespace")
	m.data.SetUnit("{datafiles}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicOracleTablespacePdbDatafilesNonWrite) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("tablespace_name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleTablespacePdbDatafilesNonWrite) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleTablespacePdbDatafilesNonWrite) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleTablespacePdbDatafilesNonWrite(cfg MetricConfig) metricNewrelicOracleTablespacePdbDatafilesNonWrite {
	m := metricNewrelicOracleTablespacePdbDatafilesNonWrite{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleTablespaceSpaceConsumedBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.tablespace.space_consumed_bytes metric with initial data.
func (m *metricNewrelicOracleTablespaceSpaceConsumedBytes) init() {
	m.data.SetName("newrelic.oracle.tablespace.space_consumed_bytes")
	m.data.SetDescription("Tablespace space consumed in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicOracleTablespaceSpaceConsumedBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("tablespace_name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleTablespaceSpaceConsumedBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleTablespaceSpaceConsumedBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleTablespaceSpaceConsumedBytes(cfg MetricConfig) metricNewrelicOracleTablespaceSpaceConsumedBytes {
	m := metricNewrelicOracleTablespaceSpaceConsumedBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleTablespaceSpaceReservedBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.tablespace.space_reserved_bytes metric with initial data.
func (m *metricNewrelicOracleTablespaceSpaceReservedBytes) init() {
	m.data.SetName("newrelic.oracle.tablespace.space_reserved_bytes")
	m.data.SetDescription("Tablespace space reserved in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicOracleTablespaceSpaceReservedBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("tablespace_name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleTablespaceSpaceReservedBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleTablespaceSpaceReservedBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleTablespaceSpaceReservedBytes(cfg MetricConfig) metricNewrelicOracleTablespaceSpaceReservedBytes {
	m := metricNewrelicOracleTablespaceSpaceReservedBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricNewrelicOracleTablespaceSpaceUsedPercentage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills newrelic.oracle.tablespace.space_used_percentage metric with initial data.
func (m *metricNewrelicOracleTablespaceSpaceUsedPercentage) init() {
	m.data.SetName("newrelic.oracle.tablespace.space_used_percentage")
	m.data.SetDescription("Tablespace space used percentage")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNewrelicOracleTablespaceSpaceUsedPercentage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, tablespaceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("tablespace_name", tablespaceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNewrelicOracleTablespaceSpaceUsedPercentage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNewrelicOracleTablespaceSpaceUsedPercentage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNewrelicOracleTablespaceSpaceUsedPercentage(cfg MetricConfig) metricNewrelicOracleTablespaceSpaceUsedPercentage {
	m := metricNewrelicOracleTablespaceSpaceUsedPercentage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                                                                        MetricsBuilderConfig // config of the metrics builder.
	startTime                                                                     pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                                                               int                  // maximum observed number of metrics per resource.
	metricsBuffer                                                                 pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                                                                     component.BuildInfo  // contains version information.
	resourceAttributeIncludeFilter                                                map[string]filter.Filter
	resourceAttributeExcludeFilter                                                map[string]filter.Filter
	metricNewrelicOracleDbActiveParallelSessions                                  metricNewrelicOracleDbActiveParallelSessions
	metricNewrelicOracleDbActiveSerialSessions                                    metricNewrelicOracleDbActiveSerialSessions
	metricNewrelicOracleDbAverageActiveSessions                                   metricNewrelicOracleDbAverageActiveSessions
	metricNewrelicOracleDbBackgroundCheckpointsPerSecond                          metricNewrelicOracleDbBackgroundCheckpointsPerSecond
	metricNewrelicOracleDbBackgroundCPUUsagePerSecond                             metricNewrelicOracleDbBackgroundCPUUsagePerSecond
	metricNewrelicOracleDbBackgroundTimePerSecond                                 metricNewrelicOracleDbBackgroundTimePerSecond
	metricNewrelicOracleDbBlockChangesPerSecond                                   metricNewrelicOracleDbBlockChangesPerSecond
	metricNewrelicOracleDbBlockChangesPerTransaction                              metricNewrelicOracleDbBlockChangesPerTransaction
	metricNewrelicOracleDbBlockChangesPerUserCall                                 metricNewrelicOracleDbBlockChangesPerUserCall
	metricNewrelicOracleDbBlockGetsPerSecond                                      metricNewrelicOracleDbBlockGetsPerSecond
	metricNewrelicOracleDbBlockGetsPerTransaction                                 metricNewrelicOracleDbBlockGetsPerTransaction
	metricNewrelicOracleDbBlockGetsPerUserCall                                    metricNewrelicOracleDbBlockGetsPerUserCall
	metricNewrelicOracleDbBranchNodeSplitsPerSecond                               metricNewrelicOracleDbBranchNodeSplitsPerSecond
	metricNewrelicOracleDbBranchNodeSplitsPerTransaction                          metricNewrelicOracleDbBranchNodeSplitsPerTransaction
	metricNewrelicOracleDbCapturedUserCalls                                       metricNewrelicOracleDbCapturedUserCalls
	metricNewrelicOracleDbConsistentReadChangesPerSecond                          metricNewrelicOracleDbConsistentReadChangesPerSecond
	metricNewrelicOracleDbConsistentReadChangesPerTransaction                     metricNewrelicOracleDbConsistentReadChangesPerTransaction
	metricNewrelicOracleDbConsistentReadGetsPerSecond                             metricNewrelicOracleDbConsistentReadGetsPerSecond
	metricNewrelicOracleDbConsistentReadGetsPerTransaction                        metricNewrelicOracleDbConsistentReadGetsPerTransaction
	metricNewrelicOracleDbCPUTimeRatio                                            metricNewrelicOracleDbCPUTimeRatio
	metricNewrelicOracleDbCPUUsagePerSecond                                       metricNewrelicOracleDbCPUUsagePerSecond
	metricNewrelicOracleDbCPUUsagePerTransaction                                  metricNewrelicOracleDbCPUUsagePerTransaction
	metricNewrelicOracleDbCrBlocksCreatedPerSecond                                metricNewrelicOracleDbCrBlocksCreatedPerSecond
	metricNewrelicOracleDbCrBlocksCreatedPerTransaction                           metricNewrelicOracleDbCrBlocksCreatedPerTransaction
	metricNewrelicOracleDbCrUndoRecordsAppliedPerSecond                           metricNewrelicOracleDbCrUndoRecordsAppliedPerSecond
	metricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction                      metricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction
	metricNewrelicOracleDbCurrentLogons                                           metricNewrelicOracleDbCurrentLogons
	metricNewrelicOracleDbCurrentOpenCursors                                      metricNewrelicOracleDbCurrentOpenCursors
	metricNewrelicOracleDbCursorCacheHitsPerAttempts                              metricNewrelicOracleDbCursorCacheHitsPerAttempts
	metricNewrelicOracleDbDatabaseCPUTimePerSecond                                metricNewrelicOracleDbDatabaseCPUTimePerSecond
	metricNewrelicOracleDbDbwrCheckpointsPerSecond                                metricNewrelicOracleDbDbwrCheckpointsPerSecond
	metricNewrelicOracleDbEnqueueDeadlocksPerSecond                               metricNewrelicOracleDbEnqueueDeadlocksPerSecond
	metricNewrelicOracleDbEnqueueDeadlocksPerTransaction                          metricNewrelicOracleDbEnqueueDeadlocksPerTransaction
	metricNewrelicOracleDbEnqueueRequestsPerSecond                                metricNewrelicOracleDbEnqueueRequestsPerSecond
	metricNewrelicOracleDbEnqueueRequestsPerTransaction                           metricNewrelicOracleDbEnqueueRequestsPerTransaction
	metricNewrelicOracleDbEnqueueTimeoutsPerSecond                                metricNewrelicOracleDbEnqueueTimeoutsPerSecond
	metricNewrelicOracleDbEnqueueTimeoutsPerTransaction                           metricNewrelicOracleDbEnqueueTimeoutsPerTransaction
	metricNewrelicOracleDbEnqueueWaitsPerSecond                                   metricNewrelicOracleDbEnqueueWaitsPerSecond
	metricNewrelicOracleDbEnqueueWaitsPerTransaction                              metricNewrelicOracleDbEnqueueWaitsPerTransaction
	metricNewrelicOracleDbExecuteWithoutParseRatio                                metricNewrelicOracleDbExecuteWithoutParseRatio
	metricNewrelicOracleDbExecutionsPerSecond                                     metricNewrelicOracleDbExecutionsPerSecond
	metricNewrelicOracleDbExecutionsPerTransaction                                metricNewrelicOracleDbExecutionsPerTransaction
	metricNewrelicOracleDbExecutionsPerUserCall                                   metricNewrelicOracleDbExecutionsPerUserCall
	metricNewrelicOracleDbFullIndexScansPerSecond                                 metricNewrelicOracleDbFullIndexScansPerSecond
	metricNewrelicOracleDbFullIndexScansPerTransaction                            metricNewrelicOracleDbFullIndexScansPerTransaction
	metricNewrelicOracleDbGcCrBlockReceivedPerSecond                              metricNewrelicOracleDbGcCrBlockReceivedPerSecond
	metricNewrelicOracleDbGcCrBlockReceivedPerTransaction                         metricNewrelicOracleDbGcCrBlockReceivedPerTransaction
	metricNewrelicOracleDbGcCurrentBlockReceivedPerSecond                         metricNewrelicOracleDbGcCurrentBlockReceivedPerSecond
	metricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction                    metricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction
	metricNewrelicOracleDbGlobalCacheAverageCrGetTime                             metricNewrelicOracleDbGlobalCacheAverageCrGetTime
	metricNewrelicOracleDbGlobalCacheAverageCurrentGetTime                        metricNewrelicOracleDbGlobalCacheAverageCurrentGetTime
	metricNewrelicOracleDbHardParseCountPerSecond                                 metricNewrelicOracleDbHardParseCountPerSecond
	metricNewrelicOracleDbHardParseCountPerTransaction                            metricNewrelicOracleDbHardParseCountPerTransaction
	metricNewrelicOracleDbHostCPUUsagePerSecond                                   metricNewrelicOracleDbHostCPUUsagePerSecond
	metricNewrelicOracleDbHostCPUUtilization                                      metricNewrelicOracleDbHostCPUUtilization
	metricNewrelicOracleDbLeafNodeSplitsPerSecond                                 metricNewrelicOracleDbLeafNodeSplitsPerSecond
	metricNewrelicOracleDbLeafNodeSplitsPerTransaction                            metricNewrelicOracleDbLeafNodeSplitsPerTransaction
	metricNewrelicOracleDbLibraryCacheHitRatio                                    metricNewrelicOracleDbLibraryCacheHitRatio
	metricNewrelicOracleDbLibraryCacheMissRatio                                   metricNewrelicOracleDbLibraryCacheMissRatio
	metricNewrelicOracleDbLogicalReadsPerSecond                                   metricNewrelicOracleDbLogicalReadsPerSecond
	metricNewrelicOracleDbLogicalReadsPerTransaction                              metricNewrelicOracleDbLogicalReadsPerTransaction
	metricNewrelicOracleDbLogonsPerSecond                                         metricNewrelicOracleDbLogonsPerSecond
	metricNewrelicOracleDbLogonsPerTransaction                                    metricNewrelicOracleDbLogonsPerTransaction
	metricNewrelicOracleDbLongTableScansPerSecond                                 metricNewrelicOracleDbLongTableScansPerSecond
	metricNewrelicOracleDbLongTableScansPerTransaction                            metricNewrelicOracleDbLongTableScansPerTransaction
	metricNewrelicOracleDbOpenCursorsPerSecond                                    metricNewrelicOracleDbOpenCursorsPerSecond
	metricNewrelicOracleDbOpenCursorsPerTransaction                               metricNewrelicOracleDbOpenCursorsPerTransaction
	metricNewrelicOracleDbOsLoad                                                  metricNewrelicOracleDbOsLoad
	metricNewrelicOracleDbParseFailureCountPerSecond                              metricNewrelicOracleDbParseFailureCountPerSecond
	metricNewrelicOracleDbParseFailureCountPerTransaction                         metricNewrelicOracleDbParseFailureCountPerTransaction
	metricNewrelicOracleDbPgaCacheHitPercentage                                   metricNewrelicOracleDbPgaCacheHitPercentage
	metricNewrelicOracleDbPhysicalReadBytesPerSecond                              metricNewrelicOracleDbPhysicalReadBytesPerSecond
	metricNewrelicOracleDbPhysicalReadIoRequestsPerSecond                         metricNewrelicOracleDbPhysicalReadIoRequestsPerSecond
	metricNewrelicOracleDbPhysicalReadsPerSecond                                  metricNewrelicOracleDbPhysicalReadsPerSecond
	metricNewrelicOracleDbPhysicalWriteBytesPerSecond                             metricNewrelicOracleDbPhysicalWriteBytesPerSecond
	metricNewrelicOracleDbPhysicalWritesPerSecond                                 metricNewrelicOracleDbPhysicalWritesPerSecond
	metricNewrelicOracleDbProcessLimitPercentage                                  metricNewrelicOracleDbProcessLimitPercentage
	metricNewrelicOracleDbRecursiveCallsPerSecond                                 metricNewrelicOracleDbRecursiveCallsPerSecond
	metricNewrelicOracleDbRecursiveCallsPerTransaction                            metricNewrelicOracleDbRecursiveCallsPerTransaction
	metricNewrelicOracleDbRedoWritesPerSecond                                     metricNewrelicOracleDbRedoWritesPerSecond
	metricNewrelicOracleDbRedoWritesPerTransaction                                metricNewrelicOracleDbRedoWritesPerTransaction
	metricNewrelicOracleDbResponseTimePerTransaction                              metricNewrelicOracleDbResponseTimePerTransaction
	metricNewrelicOracleDbRowCacheHitRatio                                        metricNewrelicOracleDbRowCacheHitRatio
	metricNewrelicOracleDbRowCacheMissRatio                                       metricNewrelicOracleDbRowCacheMissRatio
	metricNewrelicOracleDbRowsPerSort                                             metricNewrelicOracleDbRowsPerSort
	metricNewrelicOracleDbSessionCount                                            metricNewrelicOracleDbSessionCount
	metricNewrelicOracleDbSessionLimitPercentage                                  metricNewrelicOracleDbSessionLimitPercentage
	metricNewrelicOracleDbSharedPoolFreePercentage                                metricNewrelicOracleDbSharedPoolFreePercentage
	metricNewrelicOracleDbSoftParseRatio                                          metricNewrelicOracleDbSoftParseRatio
	metricNewrelicOracleDbSortsPerUserCall                                        metricNewrelicOracleDbSortsPerUserCall
	metricNewrelicOracleDbSQLServiceResponseTime                                  metricNewrelicOracleDbSQLServiceResponseTime
	metricNewrelicOracleDbStreamsPoolUsagePercentage                              metricNewrelicOracleDbStreamsPoolUsagePercentage
	metricNewrelicOracleDbTableScansPerUserCall                                   metricNewrelicOracleDbTableScansPerUserCall
	metricNewrelicOracleDbTotalIndexScansPerSecond                                metricNewrelicOracleDbTotalIndexScansPerSecond
	metricNewrelicOracleDbTotalIndexScansPerTransaction                           metricNewrelicOracleDbTotalIndexScansPerTransaction
	metricNewrelicOracleDbTotalParseCountPerSecond                                metricNewrelicOracleDbTotalParseCountPerSecond
	metricNewrelicOracleDbTotalParseCountPerTransaction                           metricNewrelicOracleDbTotalParseCountPerTransaction
	metricNewrelicOracleDbTotalTableScansPerSecond                                metricNewrelicOracleDbTotalTableScansPerSecond
	metricNewrelicOracleDbTotalTableScansPerTransaction                           metricNewrelicOracleDbTotalTableScansPerTransaction
	metricNewrelicOracleDbTransactionsPerLogon                                    metricNewrelicOracleDbTransactionsPerLogon
	metricNewrelicOracleDbUserCallsPerSecond                                      metricNewrelicOracleDbUserCallsPerSecond
	metricNewrelicOracleDbUserCallsPerTransaction                                 metricNewrelicOracleDbUserCallsPerTransaction
	metricNewrelicOracleDbUserCallsRatio                                          metricNewrelicOracleDbUserCallsRatio
	metricNewrelicOracleDbUserCommitsPerSecond                                    metricNewrelicOracleDbUserCommitsPerSecond
	metricNewrelicOracleDbUserCommitsPercentage                                   metricNewrelicOracleDbUserCommitsPercentage
	metricNewrelicOracleDbUserLimitPercentage                                     metricNewrelicOracleDbUserLimitPercentage
	metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond                 metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond
	metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction            metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction
	metricNewrelicOracleDbUserRollbacksPerSecond                                  metricNewrelicOracleDbUserRollbacksPerSecond
	metricNewrelicOracleDbUserRollbacksPercentage                                 metricNewrelicOracleDbUserRollbacksPercentage
	metricNewrelicOracleDbWaitTimeRatio                                           metricNewrelicOracleDbWaitTimeRatio
	metricNewrelicOracleDiskBlocksRead                                            metricNewrelicOracleDiskBlocksRead
	metricNewrelicOracleDiskBlocksWritten                                         metricNewrelicOracleDiskBlocksWritten
	metricNewrelicOracleDiskLogicalReadsPerUserCall                               metricNewrelicOracleDiskLogicalReadsPerUserCall
	metricNewrelicOracleDiskPhysicalLobsReadsPerSecond                            metricNewrelicOracleDiskPhysicalLobsReadsPerSecond
	metricNewrelicOracleDiskPhysicalLobsWritesPerSecond                           metricNewrelicOracleDiskPhysicalLobsWritesPerSecond
	metricNewrelicOracleDiskPhysicalReadBytesPerSecond                            metricNewrelicOracleDiskPhysicalReadBytesPerSecond
	metricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond                       metricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond
	metricNewrelicOracleDiskPhysicalReadsPerSecond                                metricNewrelicOracleDiskPhysicalReadsPerSecond
	metricNewrelicOracleDiskPhysicalWriteBytesPerSecond                           metricNewrelicOracleDiskPhysicalWriteBytesPerSecond
	metricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond                 metricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond
	metricNewrelicOracleDiskPhysicalWritesPerSecond                               metricNewrelicOracleDiskPhysicalWritesPerSecond
	metricNewrelicOracleDiskReadTimeMilliseconds                                  metricNewrelicOracleDiskReadTimeMilliseconds
	metricNewrelicOracleDiskReads                                                 metricNewrelicOracleDiskReads
	metricNewrelicOracleDiskSortPerSecond                                         metricNewrelicOracleDiskSortPerSecond
	metricNewrelicOracleDiskSortPerTransaction                                    metricNewrelicOracleDiskSortPerTransaction
	metricNewrelicOracleDiskTempSpaceUsedBytes                                    metricNewrelicOracleDiskTempSpaceUsedBytes
	metricNewrelicOracleDiskWriteTimeMilliseconds                                 metricNewrelicOracleDiskWriteTimeMilliseconds
	metricNewrelicOracleDiskWrites                                                metricNewrelicOracleDiskWrites
	metricNewrelicOracleLockedAccounts                                            metricNewrelicOracleLockedAccounts
	metricNewrelicOracleLongRunningQueries                                        metricNewrelicOracleLongRunningQueries
	metricNewrelicOracleMemoryBufferCacheHitRatio                                 metricNewrelicOracleMemoryBufferCacheHitRatio
	metricNewrelicOracleMemoryGlobalCacheBlocksCorrupted                          metricNewrelicOracleMemoryGlobalCacheBlocksCorrupted
	metricNewrelicOracleMemoryGlobalCacheBlocksLost                               metricNewrelicOracleMemoryGlobalCacheBlocksLost
	metricNewrelicOracleMemoryPgaAllocatedBytes                                   metricNewrelicOracleMemoryPgaAllocatedBytes
	metricNewrelicOracleMemoryPgaFreeableBytes                                    metricNewrelicOracleMemoryPgaFreeableBytes
	metricNewrelicOracleMemoryPgaInUseBytes                                       metricNewrelicOracleMemoryPgaInUseBytes
	metricNewrelicOracleMemoryPgaMaxSizeBytes                                     metricNewrelicOracleMemoryPgaMaxSizeBytes
	metricNewrelicOracleMemoryRedoAllocationHitRatio                              metricNewrelicOracleMemoryRedoAllocationHitRatio
	metricNewrelicOracleMemoryRedoGeneratedBytesPerSecond                         metricNewrelicOracleMemoryRedoGeneratedBytesPerSecond
	metricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction                    metricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction
	metricNewrelicOracleMemorySortsRatio                                          metricNewrelicOracleMemorySortsRatio
	metricNewrelicOracleNetworkIoMegabytesPerSecond                               metricNewrelicOracleNetworkIoMegabytesPerSecond
	metricNewrelicOracleNetworkIoRequestsPerSecond                                metricNewrelicOracleNetworkIoRequestsPerSecond
	metricNewrelicOracleNetworkTrafficBytesPerSecond                              metricNewrelicOracleNetworkTrafficBytesPerSecond
	metricNewrelicOracleQueryPhysicalLobsReadsPerTransaction                      metricNewrelicOracleQueryPhysicalLobsReadsPerTransaction
	metricNewrelicOracleQueryPhysicalLobsWritesPerTransaction                     metricNewrelicOracleQueryPhysicalLobsWritesPerTransaction
	metricNewrelicOracleQueryPhysicalReadsPerTransaction                          metricNewrelicOracleQueryPhysicalReadsPerTransaction
	metricNewrelicOracleQueryPhysicalWritesPerTransaction                         metricNewrelicOracleQueryPhysicalWritesPerTransaction
	metricNewrelicOracleQueryTransactionsPerSecond                                metricNewrelicOracleQueryTransactionsPerSecond
	metricNewrelicOracleRedoLogFileSwitch                                         metricNewrelicOracleRedoLogFileSwitch
	metricNewrelicOracleRedoLogFileSwitchArchivingNeeded                          metricNewrelicOracleRedoLogFileSwitchArchivingNeeded
	metricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete                     metricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete
	metricNewrelicOracleRedoLogWaits                                              metricNewrelicOracleRedoLogWaits
	metricNewrelicOracleRollbackSegmentsGets                                      metricNewrelicOracleRollbackSegmentsGets
	metricNewrelicOracleRollbackSegmentsRatioWait                                 metricNewrelicOracleRollbackSegmentsRatioWait
	metricNewrelicOracleRollbackSegmentsWaits                                     metricNewrelicOracleRollbackSegmentsWaits
	metricNewrelicOracleSgaBufferBusyWaits                                        metricNewrelicOracleSgaBufferBusyWaits
	metricNewrelicOracleSgaFixedSizeBytes                                         metricNewrelicOracleSgaFixedSizeBytes
	metricNewrelicOracleSgaFreeBufferInspected                                    metricNewrelicOracleSgaFreeBufferInspected
	metricNewrelicOracleSgaFreeBufferWaits                                        metricNewrelicOracleSgaFreeBufferWaits
	metricNewrelicOracleSgaHitRatio                                               metricNewrelicOracleSgaHitRatio
	metricNewrelicOracleSgaLogBufferAllocationRetriesRatio                        metricNewrelicOracleSgaLogBufferAllocationRetriesRatio
	metricNewrelicOracleSgaLogBufferRedoAllocationRetries                         metricNewrelicOracleSgaLogBufferRedoAllocationRetries
	metricNewrelicOracleSgaLogBufferRedoEntries                                   metricNewrelicOracleSgaLogBufferRedoEntries
	metricNewrelicOracleSgaLogBufferSpaceWaits                                    metricNewrelicOracleSgaLogBufferSpaceWaits
	metricNewrelicOracleSgaRedoBuffersBytes                                       metricNewrelicOracleSgaRedoBuffersBytes
	metricNewrelicOracleSgaSharedPoolDictCacheMissRatio                           metricNewrelicOracleSgaSharedPoolDictCacheMissRatio
	metricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio                         metricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio
	metricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio                      metricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio
	metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes
	metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes      metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes
	metricNewrelicOracleSgaUgaTotalMemoryBytes                                    metricNewrelicOracleSgaUgaTotalMemoryBytes
	metricNewrelicOracleSortsDiskBytes                                            metricNewrelicOracleSortsDiskBytes
	metricNewrelicOracleSortsMemoryBytes                                          metricNewrelicOracleSortsMemoryBytes
	metricNewrelicOracleTablespaceIsOffline                                       metricNewrelicOracleTablespaceIsOffline
	metricNewrelicOracleTablespaceOfflineCdbDatafiles                             metricNewrelicOracleTablespaceOfflineCdbDatafiles
	metricNewrelicOracleTablespaceOfflinePdbDatafiles                             metricNewrelicOracleTablespaceOfflinePdbDatafiles
	metricNewrelicOracleTablespacePdbDatafilesNonWrite                            metricNewrelicOracleTablespacePdbDatafilesNonWrite
	metricNewrelicOracleTablespaceSpaceConsumedBytes                              metricNewrelicOracleTablespaceSpaceConsumedBytes
	metricNewrelicOracleTablespaceSpaceReservedBytes                              metricNewrelicOracleTablespaceSpaceReservedBytes
	metricNewrelicOracleTablespaceSpaceUsedPercentage                             metricNewrelicOracleTablespaceSpaceUsedPercentage
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}
func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:        mbc,
		startTime:     pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer: pmetric.NewMetrics(),
		buildInfo:     settings.BuildInfo,
		metricNewrelicOracleDbActiveParallelSessions:                                  newMetricNewrelicOracleDbActiveParallelSessions(mbc.Metrics.NewrelicOracleDbActiveParallelSessions),
		metricNewrelicOracleDbActiveSerialSessions:                                    newMetricNewrelicOracleDbActiveSerialSessions(mbc.Metrics.NewrelicOracleDbActiveSerialSessions),
		metricNewrelicOracleDbAverageActiveSessions:                                   newMetricNewrelicOracleDbAverageActiveSessions(mbc.Metrics.NewrelicOracleDbAverageActiveSessions),
		metricNewrelicOracleDbBackgroundCheckpointsPerSecond:                          newMetricNewrelicOracleDbBackgroundCheckpointsPerSecond(mbc.Metrics.NewrelicOracleDbBackgroundCheckpointsPerSecond),
		metricNewrelicOracleDbBackgroundCPUUsagePerSecond:                             newMetricNewrelicOracleDbBackgroundCPUUsagePerSecond(mbc.Metrics.NewrelicOracleDbBackgroundCPUUsagePerSecond),
		metricNewrelicOracleDbBackgroundTimePerSecond:                                 newMetricNewrelicOracleDbBackgroundTimePerSecond(mbc.Metrics.NewrelicOracleDbBackgroundTimePerSecond),
		metricNewrelicOracleDbBlockChangesPerSecond:                                   newMetricNewrelicOracleDbBlockChangesPerSecond(mbc.Metrics.NewrelicOracleDbBlockChangesPerSecond),
		metricNewrelicOracleDbBlockChangesPerTransaction:                              newMetricNewrelicOracleDbBlockChangesPerTransaction(mbc.Metrics.NewrelicOracleDbBlockChangesPerTransaction),
		metricNewrelicOracleDbBlockChangesPerUserCall:                                 newMetricNewrelicOracleDbBlockChangesPerUserCall(mbc.Metrics.NewrelicOracleDbBlockChangesPerUserCall),
		metricNewrelicOracleDbBlockGetsPerSecond:                                      newMetricNewrelicOracleDbBlockGetsPerSecond(mbc.Metrics.NewrelicOracleDbBlockGetsPerSecond),
		metricNewrelicOracleDbBlockGetsPerTransaction:                                 newMetricNewrelicOracleDbBlockGetsPerTransaction(mbc.Metrics.NewrelicOracleDbBlockGetsPerTransaction),
		metricNewrelicOracleDbBlockGetsPerUserCall:                                    newMetricNewrelicOracleDbBlockGetsPerUserCall(mbc.Metrics.NewrelicOracleDbBlockGetsPerUserCall),
		metricNewrelicOracleDbBranchNodeSplitsPerSecond:                               newMetricNewrelicOracleDbBranchNodeSplitsPerSecond(mbc.Metrics.NewrelicOracleDbBranchNodeSplitsPerSecond),
		metricNewrelicOracleDbBranchNodeSplitsPerTransaction:                          newMetricNewrelicOracleDbBranchNodeSplitsPerTransaction(mbc.Metrics.NewrelicOracleDbBranchNodeSplitsPerTransaction),
		metricNewrelicOracleDbCapturedUserCalls:                                       newMetricNewrelicOracleDbCapturedUserCalls(mbc.Metrics.NewrelicOracleDbCapturedUserCalls),
		metricNewrelicOracleDbConsistentReadChangesPerSecond:                          newMetricNewrelicOracleDbConsistentReadChangesPerSecond(mbc.Metrics.NewrelicOracleDbConsistentReadChangesPerSecond),
		metricNewrelicOracleDbConsistentReadChangesPerTransaction:                     newMetricNewrelicOracleDbConsistentReadChangesPerTransaction(mbc.Metrics.NewrelicOracleDbConsistentReadChangesPerTransaction),
		metricNewrelicOracleDbConsistentReadGetsPerSecond:                             newMetricNewrelicOracleDbConsistentReadGetsPerSecond(mbc.Metrics.NewrelicOracleDbConsistentReadGetsPerSecond),
		metricNewrelicOracleDbConsistentReadGetsPerTransaction:                        newMetricNewrelicOracleDbConsistentReadGetsPerTransaction(mbc.Metrics.NewrelicOracleDbConsistentReadGetsPerTransaction),
		metricNewrelicOracleDbCPUTimeRatio:                                            newMetricNewrelicOracleDbCPUTimeRatio(mbc.Metrics.NewrelicOracleDbCPUTimeRatio),
		metricNewrelicOracleDbCPUUsagePerSecond:                                       newMetricNewrelicOracleDbCPUUsagePerSecond(mbc.Metrics.NewrelicOracleDbCPUUsagePerSecond),
		metricNewrelicOracleDbCPUUsagePerTransaction:                                  newMetricNewrelicOracleDbCPUUsagePerTransaction(mbc.Metrics.NewrelicOracleDbCPUUsagePerTransaction),
		metricNewrelicOracleDbCrBlocksCreatedPerSecond:                                newMetricNewrelicOracleDbCrBlocksCreatedPerSecond(mbc.Metrics.NewrelicOracleDbCrBlocksCreatedPerSecond),
		metricNewrelicOracleDbCrBlocksCreatedPerTransaction:                           newMetricNewrelicOracleDbCrBlocksCreatedPerTransaction(mbc.Metrics.NewrelicOracleDbCrBlocksCreatedPerTransaction),
		metricNewrelicOracleDbCrUndoRecordsAppliedPerSecond:                           newMetricNewrelicOracleDbCrUndoRecordsAppliedPerSecond(mbc.Metrics.NewrelicOracleDbCrUndoRecordsAppliedPerSecond),
		metricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction:                      newMetricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction(mbc.Metrics.NewrelicOracleDbCrUndoRecordsAppliedPerTransaction),
		metricNewrelicOracleDbCurrentLogons:                                           newMetricNewrelicOracleDbCurrentLogons(mbc.Metrics.NewrelicOracleDbCurrentLogons),
		metricNewrelicOracleDbCurrentOpenCursors:                                      newMetricNewrelicOracleDbCurrentOpenCursors(mbc.Metrics.NewrelicOracleDbCurrentOpenCursors),
		metricNewrelicOracleDbCursorCacheHitsPerAttempts:                              newMetricNewrelicOracleDbCursorCacheHitsPerAttempts(mbc.Metrics.NewrelicOracleDbCursorCacheHitsPerAttempts),
		metricNewrelicOracleDbDatabaseCPUTimePerSecond:                                newMetricNewrelicOracleDbDatabaseCPUTimePerSecond(mbc.Metrics.NewrelicOracleDbDatabaseCPUTimePerSecond),
		metricNewrelicOracleDbDbwrCheckpointsPerSecond:                                newMetricNewrelicOracleDbDbwrCheckpointsPerSecond(mbc.Metrics.NewrelicOracleDbDbwrCheckpointsPerSecond),
		metricNewrelicOracleDbEnqueueDeadlocksPerSecond:                               newMetricNewrelicOracleDbEnqueueDeadlocksPerSecond(mbc.Metrics.NewrelicOracleDbEnqueueDeadlocksPerSecond),
		metricNewrelicOracleDbEnqueueDeadlocksPerTransaction:                          newMetricNewrelicOracleDbEnqueueDeadlocksPerTransaction(mbc.Metrics.NewrelicOracleDbEnqueueDeadlocksPerTransaction),
		metricNewrelicOracleDbEnqueueRequestsPerSecond:                                newMetricNewrelicOracleDbEnqueueRequestsPerSecond(mbc.Metrics.NewrelicOracleDbEnqueueRequestsPerSecond),
		metricNewrelicOracleDbEnqueueRequestsPerTransaction:                           newMetricNewrelicOracleDbEnqueueRequestsPerTransaction(mbc.Metrics.NewrelicOracleDbEnqueueRequestsPerTransaction),
		metricNewrelicOracleDbEnqueueTimeoutsPerSecond:                                newMetricNewrelicOracleDbEnqueueTimeoutsPerSecond(mbc.Metrics.NewrelicOracleDbEnqueueTimeoutsPerSecond),
		metricNewrelicOracleDbEnqueueTimeoutsPerTransaction:                           newMetricNewrelicOracleDbEnqueueTimeoutsPerTransaction(mbc.Metrics.NewrelicOracleDbEnqueueTimeoutsPerTransaction),
		metricNewrelicOracleDbEnqueueWaitsPerSecond:                                   newMetricNewrelicOracleDbEnqueueWaitsPerSecond(mbc.Metrics.NewrelicOracleDbEnqueueWaitsPerSecond),
		metricNewrelicOracleDbEnqueueWaitsPerTransaction:                              newMetricNewrelicOracleDbEnqueueWaitsPerTransaction(mbc.Metrics.NewrelicOracleDbEnqueueWaitsPerTransaction),
		metricNewrelicOracleDbExecuteWithoutParseRatio:                                newMetricNewrelicOracleDbExecuteWithoutParseRatio(mbc.Metrics.NewrelicOracleDbExecuteWithoutParseRatio),
		metricNewrelicOracleDbExecutionsPerSecond:                                     newMetricNewrelicOracleDbExecutionsPerSecond(mbc.Metrics.NewrelicOracleDbExecutionsPerSecond),
		metricNewrelicOracleDbExecutionsPerTransaction:                                newMetricNewrelicOracleDbExecutionsPerTransaction(mbc.Metrics.NewrelicOracleDbExecutionsPerTransaction),
		metricNewrelicOracleDbExecutionsPerUserCall:                                   newMetricNewrelicOracleDbExecutionsPerUserCall(mbc.Metrics.NewrelicOracleDbExecutionsPerUserCall),
		metricNewrelicOracleDbFullIndexScansPerSecond:                                 newMetricNewrelicOracleDbFullIndexScansPerSecond(mbc.Metrics.NewrelicOracleDbFullIndexScansPerSecond),
		metricNewrelicOracleDbFullIndexScansPerTransaction:                            newMetricNewrelicOracleDbFullIndexScansPerTransaction(mbc.Metrics.NewrelicOracleDbFullIndexScansPerTransaction),
		metricNewrelicOracleDbGcCrBlockReceivedPerSecond:                              newMetricNewrelicOracleDbGcCrBlockReceivedPerSecond(mbc.Metrics.NewrelicOracleDbGcCrBlockReceivedPerSecond),
		metricNewrelicOracleDbGcCrBlockReceivedPerTransaction:                         newMetricNewrelicOracleDbGcCrBlockReceivedPerTransaction(mbc.Metrics.NewrelicOracleDbGcCrBlockReceivedPerTransaction),
		metricNewrelicOracleDbGcCurrentBlockReceivedPerSecond:                         newMetricNewrelicOracleDbGcCurrentBlockReceivedPerSecond(mbc.Metrics.NewrelicOracleDbGcCurrentBlockReceivedPerSecond),
		metricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction:                    newMetricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction(mbc.Metrics.NewrelicOracleDbGcCurrentBlockReceivedPerTransaction),
		metricNewrelicOracleDbGlobalCacheAverageCrGetTime:                             newMetricNewrelicOracleDbGlobalCacheAverageCrGetTime(mbc.Metrics.NewrelicOracleDbGlobalCacheAverageCrGetTime),
		metricNewrelicOracleDbGlobalCacheAverageCurrentGetTime:                        newMetricNewrelicOracleDbGlobalCacheAverageCurrentGetTime(mbc.Metrics.NewrelicOracleDbGlobalCacheAverageCurrentGetTime),
		metricNewrelicOracleDbHardParseCountPerSecond:                                 newMetricNewrelicOracleDbHardParseCountPerSecond(mbc.Metrics.NewrelicOracleDbHardParseCountPerSecond),
		metricNewrelicOracleDbHardParseCountPerTransaction:                            newMetricNewrelicOracleDbHardParseCountPerTransaction(mbc.Metrics.NewrelicOracleDbHardParseCountPerTransaction),
		metricNewrelicOracleDbHostCPUUsagePerSecond:                                   newMetricNewrelicOracleDbHostCPUUsagePerSecond(mbc.Metrics.NewrelicOracleDbHostCPUUsagePerSecond),
		metricNewrelicOracleDbHostCPUUtilization:                                      newMetricNewrelicOracleDbHostCPUUtilization(mbc.Metrics.NewrelicOracleDbHostCPUUtilization),
		metricNewrelicOracleDbLeafNodeSplitsPerSecond:                                 newMetricNewrelicOracleDbLeafNodeSplitsPerSecond(mbc.Metrics.NewrelicOracleDbLeafNodeSplitsPerSecond),
		metricNewrelicOracleDbLeafNodeSplitsPerTransaction:                            newMetricNewrelicOracleDbLeafNodeSplitsPerTransaction(mbc.Metrics.NewrelicOracleDbLeafNodeSplitsPerTransaction),
		metricNewrelicOracleDbLibraryCacheHitRatio:                                    newMetricNewrelicOracleDbLibraryCacheHitRatio(mbc.Metrics.NewrelicOracleDbLibraryCacheHitRatio),
		metricNewrelicOracleDbLibraryCacheMissRatio:                                   newMetricNewrelicOracleDbLibraryCacheMissRatio(mbc.Metrics.NewrelicOracleDbLibraryCacheMissRatio),
		metricNewrelicOracleDbLogicalReadsPerSecond:                                   newMetricNewrelicOracleDbLogicalReadsPerSecond(mbc.Metrics.NewrelicOracleDbLogicalReadsPerSecond),
		metricNewrelicOracleDbLogicalReadsPerTransaction:                              newMetricNewrelicOracleDbLogicalReadsPerTransaction(mbc.Metrics.NewrelicOracleDbLogicalReadsPerTransaction),
		metricNewrelicOracleDbLogonsPerSecond:                                         newMetricNewrelicOracleDbLogonsPerSecond(mbc.Metrics.NewrelicOracleDbLogonsPerSecond),
		metricNewrelicOracleDbLogonsPerTransaction:                                    newMetricNewrelicOracleDbLogonsPerTransaction(mbc.Metrics.NewrelicOracleDbLogonsPerTransaction),
		metricNewrelicOracleDbLongTableScansPerSecond:                                 newMetricNewrelicOracleDbLongTableScansPerSecond(mbc.Metrics.NewrelicOracleDbLongTableScansPerSecond),
		metricNewrelicOracleDbLongTableScansPerTransaction:                            newMetricNewrelicOracleDbLongTableScansPerTransaction(mbc.Metrics.NewrelicOracleDbLongTableScansPerTransaction),
		metricNewrelicOracleDbOpenCursorsPerSecond:                                    newMetricNewrelicOracleDbOpenCursorsPerSecond(mbc.Metrics.NewrelicOracleDbOpenCursorsPerSecond),
		metricNewrelicOracleDbOpenCursorsPerTransaction:                               newMetricNewrelicOracleDbOpenCursorsPerTransaction(mbc.Metrics.NewrelicOracleDbOpenCursorsPerTransaction),
		metricNewrelicOracleDbOsLoad:                                                  newMetricNewrelicOracleDbOsLoad(mbc.Metrics.NewrelicOracleDbOsLoad),
		metricNewrelicOracleDbParseFailureCountPerSecond:                              newMetricNewrelicOracleDbParseFailureCountPerSecond(mbc.Metrics.NewrelicOracleDbParseFailureCountPerSecond),
		metricNewrelicOracleDbParseFailureCountPerTransaction:                         newMetricNewrelicOracleDbParseFailureCountPerTransaction(mbc.Metrics.NewrelicOracleDbParseFailureCountPerTransaction),
		metricNewrelicOracleDbPgaCacheHitPercentage:                                   newMetricNewrelicOracleDbPgaCacheHitPercentage(mbc.Metrics.NewrelicOracleDbPgaCacheHitPercentage),
		metricNewrelicOracleDbPhysicalReadBytesPerSecond:                              newMetricNewrelicOracleDbPhysicalReadBytesPerSecond(mbc.Metrics.NewrelicOracleDbPhysicalReadBytesPerSecond),
		metricNewrelicOracleDbPhysicalReadIoRequestsPerSecond:                         newMetricNewrelicOracleDbPhysicalReadIoRequestsPerSecond(mbc.Metrics.NewrelicOracleDbPhysicalReadIoRequestsPerSecond),
		metricNewrelicOracleDbPhysicalReadsPerSecond:                                  newMetricNewrelicOracleDbPhysicalReadsPerSecond(mbc.Metrics.NewrelicOracleDbPhysicalReadsPerSecond),
		metricNewrelicOracleDbPhysicalWriteBytesPerSecond:                             newMetricNewrelicOracleDbPhysicalWriteBytesPerSecond(mbc.Metrics.NewrelicOracleDbPhysicalWriteBytesPerSecond),
		metricNewrelicOracleDbPhysicalWritesPerSecond:                                 newMetricNewrelicOracleDbPhysicalWritesPerSecond(mbc.Metrics.NewrelicOracleDbPhysicalWritesPerSecond),
		metricNewrelicOracleDbProcessLimitPercentage:                                  newMetricNewrelicOracleDbProcessLimitPercentage(mbc.Metrics.NewrelicOracleDbProcessLimitPercentage),
		metricNewrelicOracleDbRecursiveCallsPerSecond:                                 newMetricNewrelicOracleDbRecursiveCallsPerSecond(mbc.Metrics.NewrelicOracleDbRecursiveCallsPerSecond),
		metricNewrelicOracleDbRecursiveCallsPerTransaction:                            newMetricNewrelicOracleDbRecursiveCallsPerTransaction(mbc.Metrics.NewrelicOracleDbRecursiveCallsPerTransaction),
		metricNewrelicOracleDbRedoWritesPerSecond:                                     newMetricNewrelicOracleDbRedoWritesPerSecond(mbc.Metrics.NewrelicOracleDbRedoWritesPerSecond),
		metricNewrelicOracleDbRedoWritesPerTransaction:                                newMetricNewrelicOracleDbRedoWritesPerTransaction(mbc.Metrics.NewrelicOracleDbRedoWritesPerTransaction),
		metricNewrelicOracleDbResponseTimePerTransaction:                              newMetricNewrelicOracleDbResponseTimePerTransaction(mbc.Metrics.NewrelicOracleDbResponseTimePerTransaction),
		metricNewrelicOracleDbRowCacheHitRatio:                                        newMetricNewrelicOracleDbRowCacheHitRatio(mbc.Metrics.NewrelicOracleDbRowCacheHitRatio),
		metricNewrelicOracleDbRowCacheMissRatio:                                       newMetricNewrelicOracleDbRowCacheMissRatio(mbc.Metrics.NewrelicOracleDbRowCacheMissRatio),
		metricNewrelicOracleDbRowsPerSort:                                             newMetricNewrelicOracleDbRowsPerSort(mbc.Metrics.NewrelicOracleDbRowsPerSort),
		metricNewrelicOracleDbSessionCount:                                            newMetricNewrelicOracleDbSessionCount(mbc.Metrics.NewrelicOracleDbSessionCount),
		metricNewrelicOracleDbSessionLimitPercentage:                                  newMetricNewrelicOracleDbSessionLimitPercentage(mbc.Metrics.NewrelicOracleDbSessionLimitPercentage),
		metricNewrelicOracleDbSharedPoolFreePercentage:                                newMetricNewrelicOracleDbSharedPoolFreePercentage(mbc.Metrics.NewrelicOracleDbSharedPoolFreePercentage),
		metricNewrelicOracleDbSoftParseRatio:                                          newMetricNewrelicOracleDbSoftParseRatio(mbc.Metrics.NewrelicOracleDbSoftParseRatio),
		metricNewrelicOracleDbSortsPerUserCall:                                        newMetricNewrelicOracleDbSortsPerUserCall(mbc.Metrics.NewrelicOracleDbSortsPerUserCall),
		metricNewrelicOracleDbSQLServiceResponseTime:                                  newMetricNewrelicOracleDbSQLServiceResponseTime(mbc.Metrics.NewrelicOracleDbSQLServiceResponseTime),
		metricNewrelicOracleDbStreamsPoolUsagePercentage:                              newMetricNewrelicOracleDbStreamsPoolUsagePercentage(mbc.Metrics.NewrelicOracleDbStreamsPoolUsagePercentage),
		metricNewrelicOracleDbTableScansPerUserCall:                                   newMetricNewrelicOracleDbTableScansPerUserCall(mbc.Metrics.NewrelicOracleDbTableScansPerUserCall),
		metricNewrelicOracleDbTotalIndexScansPerSecond:                                newMetricNewrelicOracleDbTotalIndexScansPerSecond(mbc.Metrics.NewrelicOracleDbTotalIndexScansPerSecond),
		metricNewrelicOracleDbTotalIndexScansPerTransaction:                           newMetricNewrelicOracleDbTotalIndexScansPerTransaction(mbc.Metrics.NewrelicOracleDbTotalIndexScansPerTransaction),
		metricNewrelicOracleDbTotalParseCountPerSecond:                                newMetricNewrelicOracleDbTotalParseCountPerSecond(mbc.Metrics.NewrelicOracleDbTotalParseCountPerSecond),
		metricNewrelicOracleDbTotalParseCountPerTransaction:                           newMetricNewrelicOracleDbTotalParseCountPerTransaction(mbc.Metrics.NewrelicOracleDbTotalParseCountPerTransaction),
		metricNewrelicOracleDbTotalTableScansPerSecond:                                newMetricNewrelicOracleDbTotalTableScansPerSecond(mbc.Metrics.NewrelicOracleDbTotalTableScansPerSecond),
		metricNewrelicOracleDbTotalTableScansPerTransaction:                           newMetricNewrelicOracleDbTotalTableScansPerTransaction(mbc.Metrics.NewrelicOracleDbTotalTableScansPerTransaction),
		metricNewrelicOracleDbTransactionsPerLogon:                                    newMetricNewrelicOracleDbTransactionsPerLogon(mbc.Metrics.NewrelicOracleDbTransactionsPerLogon),
		metricNewrelicOracleDbUserCallsPerSecond:                                      newMetricNewrelicOracleDbUserCallsPerSecond(mbc.Metrics.NewrelicOracleDbUserCallsPerSecond),
		metricNewrelicOracleDbUserCallsPerTransaction:                                 newMetricNewrelicOracleDbUserCallsPerTransaction(mbc.Metrics.NewrelicOracleDbUserCallsPerTransaction),
		metricNewrelicOracleDbUserCallsRatio:                                          newMetricNewrelicOracleDbUserCallsRatio(mbc.Metrics.NewrelicOracleDbUserCallsRatio),
		metricNewrelicOracleDbUserCommitsPerSecond:                                    newMetricNewrelicOracleDbUserCommitsPerSecond(mbc.Metrics.NewrelicOracleDbUserCommitsPerSecond),
		metricNewrelicOracleDbUserCommitsPercentage:                                   newMetricNewrelicOracleDbUserCommitsPercentage(mbc.Metrics.NewrelicOracleDbUserCommitsPercentage),
		metricNewrelicOracleDbUserLimitPercentage:                                     newMetricNewrelicOracleDbUserLimitPercentage(mbc.Metrics.NewrelicOracleDbUserLimitPercentage),
		metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond:                 newMetricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond(mbc.Metrics.NewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond),
		metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction:            newMetricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction(mbc.Metrics.NewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction),
		metricNewrelicOracleDbUserRollbacksPerSecond:                                  newMetricNewrelicOracleDbUserRollbacksPerSecond(mbc.Metrics.NewrelicOracleDbUserRollbacksPerSecond),
		metricNewrelicOracleDbUserRollbacksPercentage:                                 newMetricNewrelicOracleDbUserRollbacksPercentage(mbc.Metrics.NewrelicOracleDbUserRollbacksPercentage),
		metricNewrelicOracleDbWaitTimeRatio:                                           newMetricNewrelicOracleDbWaitTimeRatio(mbc.Metrics.NewrelicOracleDbWaitTimeRatio),
		metricNewrelicOracleDiskBlocksRead:                                            newMetricNewrelicOracleDiskBlocksRead(mbc.Metrics.NewrelicOracleDiskBlocksRead),
		metricNewrelicOracleDiskBlocksWritten:                                         newMetricNewrelicOracleDiskBlocksWritten(mbc.Metrics.NewrelicOracleDiskBlocksWritten),
		metricNewrelicOracleDiskLogicalReadsPerUserCall:                               newMetricNewrelicOracleDiskLogicalReadsPerUserCall(mbc.Metrics.NewrelicOracleDiskLogicalReadsPerUserCall),
		metricNewrelicOracleDiskPhysicalLobsReadsPerSecond:                            newMetricNewrelicOracleDiskPhysicalLobsReadsPerSecond(mbc.Metrics.NewrelicOracleDiskPhysicalLobsReadsPerSecond),
		metricNewrelicOracleDiskPhysicalLobsWritesPerSecond:                           newMetricNewrelicOracleDiskPhysicalLobsWritesPerSecond(mbc.Metrics.NewrelicOracleDiskPhysicalLobsWritesPerSecond),
		metricNewrelicOracleDiskPhysicalReadBytesPerSecond:                            newMetricNewrelicOracleDiskPhysicalReadBytesPerSecond(mbc.Metrics.NewrelicOracleDiskPhysicalReadBytesPerSecond),
		metricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond:                       newMetricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond(mbc.Metrics.NewrelicOracleDiskPhysicalReadIoRequestsPerSecond),
		metricNewrelicOracleDiskPhysicalReadsPerSecond:                                newMetricNewrelicOracleDiskPhysicalReadsPerSecond(mbc.Metrics.NewrelicOracleDiskPhysicalReadsPerSecond),
		metricNewrelicOracleDiskPhysicalWriteBytesPerSecond:                           newMetricNewrelicOracleDiskPhysicalWriteBytesPerSecond(mbc.Metrics.NewrelicOracleDiskPhysicalWriteBytesPerSecond),
		metricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond:                 newMetricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond(mbc.Metrics.NewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond),
		metricNewrelicOracleDiskPhysicalWritesPerSecond:                               newMetricNewrelicOracleDiskPhysicalWritesPerSecond(mbc.Metrics.NewrelicOracleDiskPhysicalWritesPerSecond),
		metricNewrelicOracleDiskReadTimeMilliseconds:                                  newMetricNewrelicOracleDiskReadTimeMilliseconds(mbc.Metrics.NewrelicOracleDiskReadTimeMilliseconds),
		metricNewrelicOracleDiskReads:                                                 newMetricNewrelicOracleDiskReads(mbc.Metrics.NewrelicOracleDiskReads),
		metricNewrelicOracleDiskSortPerSecond:                                         newMetricNewrelicOracleDiskSortPerSecond(mbc.Metrics.NewrelicOracleDiskSortPerSecond),
		metricNewrelicOracleDiskSortPerTransaction:                                    newMetricNewrelicOracleDiskSortPerTransaction(mbc.Metrics.NewrelicOracleDiskSortPerTransaction),
		metricNewrelicOracleDiskTempSpaceUsedBytes:                                    newMetricNewrelicOracleDiskTempSpaceUsedBytes(mbc.Metrics.NewrelicOracleDiskTempSpaceUsedBytes),
		metricNewrelicOracleDiskWriteTimeMilliseconds:                                 newMetricNewrelicOracleDiskWriteTimeMilliseconds(mbc.Metrics.NewrelicOracleDiskWriteTimeMilliseconds),
		metricNewrelicOracleDiskWrites:                                                newMetricNewrelicOracleDiskWrites(mbc.Metrics.NewrelicOracleDiskWrites),
		metricNewrelicOracleLockedAccounts:                                            newMetricNewrelicOracleLockedAccounts(mbc.Metrics.NewrelicOracleLockedAccounts),
		metricNewrelicOracleLongRunningQueries:                                        newMetricNewrelicOracleLongRunningQueries(mbc.Metrics.NewrelicOracleLongRunningQueries),
		metricNewrelicOracleMemoryBufferCacheHitRatio:                                 newMetricNewrelicOracleMemoryBufferCacheHitRatio(mbc.Metrics.NewrelicOracleMemoryBufferCacheHitRatio),
		metricNewrelicOracleMemoryGlobalCacheBlocksCorrupted:                          newMetricNewrelicOracleMemoryGlobalCacheBlocksCorrupted(mbc.Metrics.NewrelicOracleMemoryGlobalCacheBlocksCorrupted),
		metricNewrelicOracleMemoryGlobalCacheBlocksLost:                               newMetricNewrelicOracleMemoryGlobalCacheBlocksLost(mbc.Metrics.NewrelicOracleMemoryGlobalCacheBlocksLost),
		metricNewrelicOracleMemoryPgaAllocatedBytes:                                   newMetricNewrelicOracleMemoryPgaAllocatedBytes(mbc.Metrics.NewrelicOracleMemoryPgaAllocatedBytes),
		metricNewrelicOracleMemoryPgaFreeableBytes:                                    newMetricNewrelicOracleMemoryPgaFreeableBytes(mbc.Metrics.NewrelicOracleMemoryPgaFreeableBytes),
		metricNewrelicOracleMemoryPgaInUseBytes:                                       newMetricNewrelicOracleMemoryPgaInUseBytes(mbc.Metrics.NewrelicOracleMemoryPgaInUseBytes),
		metricNewrelicOracleMemoryPgaMaxSizeBytes:                                     newMetricNewrelicOracleMemoryPgaMaxSizeBytes(mbc.Metrics.NewrelicOracleMemoryPgaMaxSizeBytes),
		metricNewrelicOracleMemoryRedoAllocationHitRatio:                              newMetricNewrelicOracleMemoryRedoAllocationHitRatio(mbc.Metrics.NewrelicOracleMemoryRedoAllocationHitRatio),
		metricNewrelicOracleMemoryRedoGeneratedBytesPerSecond:                         newMetricNewrelicOracleMemoryRedoGeneratedBytesPerSecond(mbc.Metrics.NewrelicOracleMemoryRedoGeneratedBytesPerSecond),
		metricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction:                    newMetricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction(mbc.Metrics.NewrelicOracleMemoryRedoGeneratedBytesPerTransaction),
		metricNewrelicOracleMemorySortsRatio:                                          newMetricNewrelicOracleMemorySortsRatio(mbc.Metrics.NewrelicOracleMemorySortsRatio),
		metricNewrelicOracleNetworkIoMegabytesPerSecond:                               newMetricNewrelicOracleNetworkIoMegabytesPerSecond(mbc.Metrics.NewrelicOracleNetworkIoMegabytesPerSecond),
		metricNewrelicOracleNetworkIoRequestsPerSecond:                                newMetricNewrelicOracleNetworkIoRequestsPerSecond(mbc.Metrics.NewrelicOracleNetworkIoRequestsPerSecond),
		metricNewrelicOracleNetworkTrafficBytesPerSecond:                              newMetricNewrelicOracleNetworkTrafficBytesPerSecond(mbc.Metrics.NewrelicOracleNetworkTrafficBytesPerSecond),
		metricNewrelicOracleQueryPhysicalLobsReadsPerTransaction:                      newMetricNewrelicOracleQueryPhysicalLobsReadsPerTransaction(mbc.Metrics.NewrelicOracleQueryPhysicalLobsReadsPerTransaction),
		metricNewrelicOracleQueryPhysicalLobsWritesPerTransaction:                     newMetricNewrelicOracleQueryPhysicalLobsWritesPerTransaction(mbc.Metrics.NewrelicOracleQueryPhysicalLobsWritesPerTransaction),
		metricNewrelicOracleQueryPhysicalReadsPerTransaction:                          newMetricNewrelicOracleQueryPhysicalReadsPerTransaction(mbc.Metrics.NewrelicOracleQueryPhysicalReadsPerTransaction),
		metricNewrelicOracleQueryPhysicalWritesPerTransaction:                         newMetricNewrelicOracleQueryPhysicalWritesPerTransaction(mbc.Metrics.NewrelicOracleQueryPhysicalWritesPerTransaction),
		metricNewrelicOracleQueryTransactionsPerSecond:                                newMetricNewrelicOracleQueryTransactionsPerSecond(mbc.Metrics.NewrelicOracleQueryTransactionsPerSecond),
		metricNewrelicOracleRedoLogFileSwitch:                                         newMetricNewrelicOracleRedoLogFileSwitch(mbc.Metrics.NewrelicOracleRedoLogFileSwitch),
		metricNewrelicOracleRedoLogFileSwitchArchivingNeeded:                          newMetricNewrelicOracleRedoLogFileSwitchArchivingNeeded(mbc.Metrics.NewrelicOracleRedoLogFileSwitchArchivingNeeded),
		metricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete:                     newMetricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete(mbc.Metrics.NewrelicOracleRedoLogFileSwitchCheckpointIncomplete),
		metricNewrelicOracleRedoLogWaits:                                              newMetricNewrelicOracleRedoLogWaits(mbc.Metrics.NewrelicOracleRedoLogWaits),
		metricNewrelicOracleRollbackSegmentsGets:                                      newMetricNewrelicOracleRollbackSegmentsGets(mbc.Metrics.NewrelicOracleRollbackSegmentsGets),
		metricNewrelicOracleRollbackSegmentsRatioWait:                                 newMetricNewrelicOracleRollbackSegmentsRatioWait(mbc.Metrics.NewrelicOracleRollbackSegmentsRatioWait),
		metricNewrelicOracleRollbackSegmentsWaits:                                     newMetricNewrelicOracleRollbackSegmentsWaits(mbc.Metrics.NewrelicOracleRollbackSegmentsWaits),
		metricNewrelicOracleSgaBufferBusyWaits:                                        newMetricNewrelicOracleSgaBufferBusyWaits(mbc.Metrics.NewrelicOracleSgaBufferBusyWaits),
		metricNewrelicOracleSgaFixedSizeBytes:                                         newMetricNewrelicOracleSgaFixedSizeBytes(mbc.Metrics.NewrelicOracleSgaFixedSizeBytes),
		metricNewrelicOracleSgaFreeBufferInspected:                                    newMetricNewrelicOracleSgaFreeBufferInspected(mbc.Metrics.NewrelicOracleSgaFreeBufferInspected),
		metricNewrelicOracleSgaFreeBufferWaits:                                        newMetricNewrelicOracleSgaFreeBufferWaits(mbc.Metrics.NewrelicOracleSgaFreeBufferWaits),
		metricNewrelicOracleSgaHitRatio:                                               newMetricNewrelicOracleSgaHitRatio(mbc.Metrics.NewrelicOracleSgaHitRatio),
		metricNewrelicOracleSgaLogBufferAllocationRetriesRatio:                        newMetricNewrelicOracleSgaLogBufferAllocationRetriesRatio(mbc.Metrics.NewrelicOracleSgaLogBufferAllocationRetriesRatio),
		metricNewrelicOracleSgaLogBufferRedoAllocationRetries:                         newMetricNewrelicOracleSgaLogBufferRedoAllocationRetries(mbc.Metrics.NewrelicOracleSgaLogBufferRedoAllocationRetries),
		metricNewrelicOracleSgaLogBufferRedoEntries:                                   newMetricNewrelicOracleSgaLogBufferRedoEntries(mbc.Metrics.NewrelicOracleSgaLogBufferRedoEntries),
		metricNewrelicOracleSgaLogBufferSpaceWaits:                                    newMetricNewrelicOracleSgaLogBufferSpaceWaits(mbc.Metrics.NewrelicOracleSgaLogBufferSpaceWaits),
		metricNewrelicOracleSgaRedoBuffersBytes:                                       newMetricNewrelicOracleSgaRedoBuffersBytes(mbc.Metrics.NewrelicOracleSgaRedoBuffersBytes),
		metricNewrelicOracleSgaSharedPoolDictCacheMissRatio:                           newMetricNewrelicOracleSgaSharedPoolDictCacheMissRatio(mbc.Metrics.NewrelicOracleSgaSharedPoolDictCacheMissRatio),
		metricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio:                         newMetricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio(mbc.Metrics.NewrelicOracleSgaSharedPoolLibraryCacheHitRatio),
		metricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio:                      newMetricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio(mbc.Metrics.NewrelicOracleSgaSharedPoolLibraryCacheReloadRatio),
		metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes: newMetricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes(mbc.Metrics.NewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes),
		metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes:      newMetricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes(mbc.Metrics.NewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes),
		metricNewrelicOracleSgaUgaTotalMemoryBytes:                                    newMetricNewrelicOracleSgaUgaTotalMemoryBytes(mbc.Metrics.NewrelicOracleSgaUgaTotalMemoryBytes),
		metricNewrelicOracleSortsDiskBytes:                                            newMetricNewrelicOracleSortsDiskBytes(mbc.Metrics.NewrelicOracleSortsDiskBytes),
		metricNewrelicOracleSortsMemoryBytes:                                          newMetricNewrelicOracleSortsMemoryBytes(mbc.Metrics.NewrelicOracleSortsMemoryBytes),
		metricNewrelicOracleTablespaceIsOffline:                                       newMetricNewrelicOracleTablespaceIsOffline(mbc.Metrics.NewrelicOracleTablespaceIsOffline),
		metricNewrelicOracleTablespaceOfflineCdbDatafiles:                             newMetricNewrelicOracleTablespaceOfflineCdbDatafiles(mbc.Metrics.NewrelicOracleTablespaceOfflineCdbDatafiles),
		metricNewrelicOracleTablespaceOfflinePdbDatafiles:                             newMetricNewrelicOracleTablespaceOfflinePdbDatafiles(mbc.Metrics.NewrelicOracleTablespaceOfflinePdbDatafiles),
		metricNewrelicOracleTablespacePdbDatafilesNonWrite:                            newMetricNewrelicOracleTablespacePdbDatafilesNonWrite(mbc.Metrics.NewrelicOracleTablespacePdbDatafilesNonWrite),
		metricNewrelicOracleTablespaceSpaceConsumedBytes:                              newMetricNewrelicOracleTablespaceSpaceConsumedBytes(mbc.Metrics.NewrelicOracleTablespaceSpaceConsumedBytes),
		metricNewrelicOracleTablespaceSpaceReservedBytes:                              newMetricNewrelicOracleTablespaceSpaceReservedBytes(mbc.Metrics.NewrelicOracleTablespaceSpaceReservedBytes),
		metricNewrelicOracleTablespaceSpaceUsedPercentage:                             newMetricNewrelicOracleTablespaceSpaceUsedPercentage(mbc.Metrics.NewrelicOracleTablespaceSpaceUsedPercentage),
		resourceAttributeIncludeFilter:                                                make(map[string]filter.Filter),
		resourceAttributeExcludeFilter:                                                make(map[string]filter.Filter),
	}
	if mbc.ResourceAttributes.HostName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["host.name"] = filter.CreateFilter(mbc.ResourceAttributes.HostName.MetricsInclude)
	}
	if mbc.ResourceAttributes.HostName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["host.name"] = filter.CreateFilter(mbc.ResourceAttributes.HostName.MetricsExclude)
	}
	if mbc.ResourceAttributes.NewrelicOracleDbID.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["newrelic.oracle.db.id"] = filter.CreateFilter(mbc.ResourceAttributes.NewrelicOracleDbID.MetricsInclude)
	}
	if mbc.ResourceAttributes.NewrelicOracleDbID.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["newrelic.oracle.db.id"] = filter.CreateFilter(mbc.ResourceAttributes.NewrelicOracleDbID.MetricsExclude)
	}
	if mbc.ResourceAttributes.NewrelicOracleGlobalName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["newrelic.oracle.global.name"] = filter.CreateFilter(mbc.ResourceAttributes.NewrelicOracleGlobalName.MetricsInclude)
	}
	if mbc.ResourceAttributes.NewrelicOracleGlobalName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["newrelic.oracle.global.name"] = filter.CreateFilter(mbc.ResourceAttributes.NewrelicOracleGlobalName.MetricsExclude)
	}
	if mbc.ResourceAttributes.NewrelicOracleInstanceID.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["newrelic.oracle.instance.id"] = filter.CreateFilter(mbc.ResourceAttributes.NewrelicOracleInstanceID.MetricsInclude)
	}
	if mbc.ResourceAttributes.NewrelicOracleInstanceID.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["newrelic.oracle.instance.id"] = filter.CreateFilter(mbc.ResourceAttributes.NewrelicOracleInstanceID.MetricsExclude)
	}
	if mbc.ResourceAttributes.NewrelicOracleInstanceName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["newrelic.oracle.instance.name"] = filter.CreateFilter(mbc.ResourceAttributes.NewrelicOracleInstanceName.MetricsInclude)
	}
	if mbc.ResourceAttributes.NewrelicOracleInstanceName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["newrelic.oracle.instance.name"] = filter.CreateFilter(mbc.ResourceAttributes.NewrelicOracleInstanceName.MetricsExclude)
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricNewrelicOracleDbActiveParallelSessions.emit(ils.Metrics())
	mb.metricNewrelicOracleDbActiveSerialSessions.emit(ils.Metrics())
	mb.metricNewrelicOracleDbAverageActiveSessions.emit(ils.Metrics())
	mb.metricNewrelicOracleDbBackgroundCheckpointsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbBackgroundCPUUsagePerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbBackgroundTimePerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbBlockChangesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbBlockChangesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbBlockChangesPerUserCall.emit(ils.Metrics())
	mb.metricNewrelicOracleDbBlockGetsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbBlockGetsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbBlockGetsPerUserCall.emit(ils.Metrics())
	mb.metricNewrelicOracleDbBranchNodeSplitsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbBranchNodeSplitsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbCapturedUserCalls.emit(ils.Metrics())
	mb.metricNewrelicOracleDbConsistentReadChangesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbConsistentReadChangesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbConsistentReadGetsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbConsistentReadGetsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbCPUTimeRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleDbCPUUsagePerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbCPUUsagePerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbCrBlocksCreatedPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbCrBlocksCreatedPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbCrUndoRecordsAppliedPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbCurrentLogons.emit(ils.Metrics())
	mb.metricNewrelicOracleDbCurrentOpenCursors.emit(ils.Metrics())
	mb.metricNewrelicOracleDbCursorCacheHitsPerAttempts.emit(ils.Metrics())
	mb.metricNewrelicOracleDbDatabaseCPUTimePerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbDbwrCheckpointsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbEnqueueDeadlocksPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbEnqueueDeadlocksPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbEnqueueRequestsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbEnqueueRequestsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbEnqueueTimeoutsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbEnqueueTimeoutsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbEnqueueWaitsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbEnqueueWaitsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbExecuteWithoutParseRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleDbExecutionsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbExecutionsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbExecutionsPerUserCall.emit(ils.Metrics())
	mb.metricNewrelicOracleDbFullIndexScansPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbFullIndexScansPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbGcCrBlockReceivedPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbGcCrBlockReceivedPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbGcCurrentBlockReceivedPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbGlobalCacheAverageCrGetTime.emit(ils.Metrics())
	mb.metricNewrelicOracleDbGlobalCacheAverageCurrentGetTime.emit(ils.Metrics())
	mb.metricNewrelicOracleDbHardParseCountPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbHardParseCountPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbHostCPUUsagePerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbHostCPUUtilization.emit(ils.Metrics())
	mb.metricNewrelicOracleDbLeafNodeSplitsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbLeafNodeSplitsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbLibraryCacheHitRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleDbLibraryCacheMissRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleDbLogicalReadsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbLogicalReadsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbLogonsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbLogonsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbLongTableScansPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbLongTableScansPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbOpenCursorsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbOpenCursorsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbOsLoad.emit(ils.Metrics())
	mb.metricNewrelicOracleDbParseFailureCountPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbParseFailureCountPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbPgaCacheHitPercentage.emit(ils.Metrics())
	mb.metricNewrelicOracleDbPhysicalReadBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbPhysicalReadIoRequestsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbPhysicalReadsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbPhysicalWriteBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbPhysicalWritesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbProcessLimitPercentage.emit(ils.Metrics())
	mb.metricNewrelicOracleDbRecursiveCallsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbRecursiveCallsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbRedoWritesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbRedoWritesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbResponseTimePerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbRowCacheHitRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleDbRowCacheMissRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleDbRowsPerSort.emit(ils.Metrics())
	mb.metricNewrelicOracleDbSessionCount.emit(ils.Metrics())
	mb.metricNewrelicOracleDbSessionLimitPercentage.emit(ils.Metrics())
	mb.metricNewrelicOracleDbSharedPoolFreePercentage.emit(ils.Metrics())
	mb.metricNewrelicOracleDbSoftParseRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleDbSortsPerUserCall.emit(ils.Metrics())
	mb.metricNewrelicOracleDbSQLServiceResponseTime.emit(ils.Metrics())
	mb.metricNewrelicOracleDbStreamsPoolUsagePercentage.emit(ils.Metrics())
	mb.metricNewrelicOracleDbTableScansPerUserCall.emit(ils.Metrics())
	mb.metricNewrelicOracleDbTotalIndexScansPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbTotalIndexScansPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbTotalParseCountPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbTotalParseCountPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbTotalTableScansPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbTotalTableScansPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbTransactionsPerLogon.emit(ils.Metrics())
	mb.metricNewrelicOracleDbUserCallsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbUserCallsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbUserCallsRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleDbUserCommitsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbUserCommitsPercentage.emit(ils.Metrics())
	mb.metricNewrelicOracleDbUserLimitPercentage.emit(ils.Metrics())
	mb.metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDbUserRollbacksPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDbUserRollbacksPercentage.emit(ils.Metrics())
	mb.metricNewrelicOracleDbWaitTimeRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskBlocksRead.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskBlocksWritten.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskLogicalReadsPerUserCall.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskPhysicalLobsReadsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskPhysicalLobsWritesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskPhysicalReadBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskPhysicalReadsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskPhysicalWriteBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskPhysicalWritesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskReadTimeMilliseconds.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskReads.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskSortPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskSortPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskTempSpaceUsedBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskWriteTimeMilliseconds.emit(ils.Metrics())
	mb.metricNewrelicOracleDiskWrites.emit(ils.Metrics())
	mb.metricNewrelicOracleLockedAccounts.emit(ils.Metrics())
	mb.metricNewrelicOracleLongRunningQueries.emit(ils.Metrics())
	mb.metricNewrelicOracleMemoryBufferCacheHitRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleMemoryGlobalCacheBlocksCorrupted.emit(ils.Metrics())
	mb.metricNewrelicOracleMemoryGlobalCacheBlocksLost.emit(ils.Metrics())
	mb.metricNewrelicOracleMemoryPgaAllocatedBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleMemoryPgaFreeableBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleMemoryPgaInUseBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleMemoryPgaMaxSizeBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleMemoryRedoAllocationHitRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleMemoryRedoGeneratedBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleMemorySortsRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleNetworkIoMegabytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleNetworkIoRequestsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleNetworkTrafficBytesPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleQueryPhysicalLobsReadsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleQueryPhysicalLobsWritesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleQueryPhysicalReadsPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleQueryPhysicalWritesPerTransaction.emit(ils.Metrics())
	mb.metricNewrelicOracleQueryTransactionsPerSecond.emit(ils.Metrics())
	mb.metricNewrelicOracleRedoLogFileSwitch.emit(ils.Metrics())
	mb.metricNewrelicOracleRedoLogFileSwitchArchivingNeeded.emit(ils.Metrics())
	mb.metricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete.emit(ils.Metrics())
	mb.metricNewrelicOracleRedoLogWaits.emit(ils.Metrics())
	mb.metricNewrelicOracleRollbackSegmentsGets.emit(ils.Metrics())
	mb.metricNewrelicOracleRollbackSegmentsRatioWait.emit(ils.Metrics())
	mb.metricNewrelicOracleRollbackSegmentsWaits.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaBufferBusyWaits.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaFixedSizeBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaFreeBufferInspected.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaFreeBufferWaits.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaHitRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaLogBufferAllocationRetriesRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaLogBufferRedoAllocationRetries.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaLogBufferRedoEntries.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaLogBufferSpaceWaits.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaRedoBuffersBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaSharedPoolDictCacheMissRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleSgaUgaTotalMemoryBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleSortsDiskBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleSortsMemoryBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleTablespaceIsOffline.emit(ils.Metrics())
	mb.metricNewrelicOracleTablespaceOfflineCdbDatafiles.emit(ils.Metrics())
	mb.metricNewrelicOracleTablespaceOfflinePdbDatafiles.emit(ils.Metrics())
	mb.metricNewrelicOracleTablespacePdbDatafilesNonWrite.emit(ils.Metrics())
	mb.metricNewrelicOracleTablespaceSpaceConsumedBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleTablespaceSpaceReservedBytes.emit(ils.Metrics())
	mb.metricNewrelicOracleTablespaceSpaceUsedPercentage.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}
	for attr, filter := range mb.resourceAttributeIncludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && !filter.Matches(val.AsString()) {
			return
		}
	}
	for attr, filter := range mb.resourceAttributeExcludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && filter.Matches(val.AsString()) {
			return
		}
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordNewrelicOracleDbActiveParallelSessionsDataPoint adds a data point to newrelic.oracle.db.active_parallel_sessions metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbActiveParallelSessionsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleDbActiveParallelSessions.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbActiveSerialSessionsDataPoint adds a data point to newrelic.oracle.db.active_serial_sessions metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbActiveSerialSessionsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleDbActiveSerialSessions.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbAverageActiveSessionsDataPoint adds a data point to newrelic.oracle.db.average_active_sessions metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbAverageActiveSessionsDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbAverageActiveSessions.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbBackgroundCheckpointsPerSecondDataPoint adds a data point to newrelic.oracle.db.background_checkpoints_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbBackgroundCheckpointsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbBackgroundCheckpointsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbBackgroundCPUUsagePerSecondDataPoint adds a data point to newrelic.oracle.db.background_cpu_usage_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbBackgroundCPUUsagePerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbBackgroundCPUUsagePerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbBackgroundTimePerSecondDataPoint adds a data point to newrelic.oracle.db.background_time_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbBackgroundTimePerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbBackgroundTimePerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbBlockChangesPerSecondDataPoint adds a data point to newrelic.oracle.db.block_changes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbBlockChangesPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbBlockChangesPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbBlockChangesPerTransactionDataPoint adds a data point to newrelic.oracle.db.block_changes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbBlockChangesPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbBlockChangesPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbBlockChangesPerUserCallDataPoint adds a data point to newrelic.oracle.db.block_changes_per_user_call metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbBlockChangesPerUserCallDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbBlockChangesPerUserCall.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbBlockGetsPerSecondDataPoint adds a data point to newrelic.oracle.db.block_gets_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbBlockGetsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbBlockGetsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbBlockGetsPerTransactionDataPoint adds a data point to newrelic.oracle.db.block_gets_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbBlockGetsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbBlockGetsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbBlockGetsPerUserCallDataPoint adds a data point to newrelic.oracle.db.block_gets_per_user_call metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbBlockGetsPerUserCallDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbBlockGetsPerUserCall.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbBranchNodeSplitsPerSecondDataPoint adds a data point to newrelic.oracle.db.branch_node_splits_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbBranchNodeSplitsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbBranchNodeSplitsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbBranchNodeSplitsPerTransactionDataPoint adds a data point to newrelic.oracle.db.branch_node_splits_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbBranchNodeSplitsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbBranchNodeSplitsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbCapturedUserCallsDataPoint adds a data point to newrelic.oracle.db.captured_user_calls metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbCapturedUserCallsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleDbCapturedUserCalls.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbConsistentReadChangesPerSecondDataPoint adds a data point to newrelic.oracle.db.consistent_read_changes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbConsistentReadChangesPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbConsistentReadChangesPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbConsistentReadChangesPerTransactionDataPoint adds a data point to newrelic.oracle.db.consistent_read_changes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbConsistentReadChangesPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbConsistentReadChangesPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbConsistentReadGetsPerSecondDataPoint adds a data point to newrelic.oracle.db.consistent_read_gets_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbConsistentReadGetsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbConsistentReadGetsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbConsistentReadGetsPerTransactionDataPoint adds a data point to newrelic.oracle.db.consistent_read_gets_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbConsistentReadGetsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbConsistentReadGetsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbCPUTimeRatioDataPoint adds a data point to newrelic.oracle.db.cpu_time_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbCPUTimeRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbCPUTimeRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbCPUUsagePerSecondDataPoint adds a data point to newrelic.oracle.db.cpu_usage_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbCPUUsagePerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbCPUUsagePerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbCPUUsagePerTransactionDataPoint adds a data point to newrelic.oracle.db.cpu_usage_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbCPUUsagePerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbCPUUsagePerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbCrBlocksCreatedPerSecondDataPoint adds a data point to newrelic.oracle.db.cr_blocks_created_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbCrBlocksCreatedPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbCrBlocksCreatedPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbCrBlocksCreatedPerTransactionDataPoint adds a data point to newrelic.oracle.db.cr_blocks_created_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbCrBlocksCreatedPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbCrBlocksCreatedPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbCrUndoRecordsAppliedPerSecondDataPoint adds a data point to newrelic.oracle.db.cr_undo_records_applied_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbCrUndoRecordsAppliedPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbCrUndoRecordsAppliedPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbCrUndoRecordsAppliedPerTransactionDataPoint adds a data point to newrelic.oracle.db.cr_undo_records_applied_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbCrUndoRecordsAppliedPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbCrUndoRecordsAppliedPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbCurrentLogonsDataPoint adds a data point to newrelic.oracle.db.current_logons metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbCurrentLogonsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleDbCurrentLogons.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbCurrentOpenCursorsDataPoint adds a data point to newrelic.oracle.db.current_open_cursors metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbCurrentOpenCursorsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleDbCurrentOpenCursors.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbCursorCacheHitsPerAttemptsDataPoint adds a data point to newrelic.oracle.db.cursor_cache_hits_per_attempts metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbCursorCacheHitsPerAttemptsDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbCursorCacheHitsPerAttempts.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbDatabaseCPUTimePerSecondDataPoint adds a data point to newrelic.oracle.db.database_cpu_time_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbDatabaseCPUTimePerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbDatabaseCPUTimePerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbDbwrCheckpointsPerSecondDataPoint adds a data point to newrelic.oracle.db.dbwr_checkpoints_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbDbwrCheckpointsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbDbwrCheckpointsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbEnqueueDeadlocksPerSecondDataPoint adds a data point to newrelic.oracle.db.enqueue_deadlocks_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbEnqueueDeadlocksPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbEnqueueDeadlocksPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbEnqueueDeadlocksPerTransactionDataPoint adds a data point to newrelic.oracle.db.enqueue_deadlocks_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbEnqueueDeadlocksPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbEnqueueDeadlocksPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbEnqueueRequestsPerSecondDataPoint adds a data point to newrelic.oracle.db.enqueue_requests_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbEnqueueRequestsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbEnqueueRequestsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbEnqueueRequestsPerTransactionDataPoint adds a data point to newrelic.oracle.db.enqueue_requests_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbEnqueueRequestsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbEnqueueRequestsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbEnqueueTimeoutsPerSecondDataPoint adds a data point to newrelic.oracle.db.enqueue_timeouts_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbEnqueueTimeoutsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbEnqueueTimeoutsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbEnqueueTimeoutsPerTransactionDataPoint adds a data point to newrelic.oracle.db.enqueue_timeouts_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbEnqueueTimeoutsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbEnqueueTimeoutsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbEnqueueWaitsPerSecondDataPoint adds a data point to newrelic.oracle.db.enqueue_waits_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbEnqueueWaitsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbEnqueueWaitsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbEnqueueWaitsPerTransactionDataPoint adds a data point to newrelic.oracle.db.enqueue_waits_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbEnqueueWaitsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbEnqueueWaitsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbExecuteWithoutParseRatioDataPoint adds a data point to newrelic.oracle.db.execute_without_parse_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbExecuteWithoutParseRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbExecuteWithoutParseRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbExecutionsPerSecondDataPoint adds a data point to newrelic.oracle.db.executions_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbExecutionsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbExecutionsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbExecutionsPerTransactionDataPoint adds a data point to newrelic.oracle.db.executions_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbExecutionsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbExecutionsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbExecutionsPerUserCallDataPoint adds a data point to newrelic.oracle.db.executions_per_user_call metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbExecutionsPerUserCallDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbExecutionsPerUserCall.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbFullIndexScansPerSecondDataPoint adds a data point to newrelic.oracle.db.full_index_scans_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbFullIndexScansPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbFullIndexScansPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbFullIndexScansPerTransactionDataPoint adds a data point to newrelic.oracle.db.full_index_scans_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbFullIndexScansPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbFullIndexScansPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbGcCrBlockReceivedPerSecondDataPoint adds a data point to newrelic.oracle.db.gc_cr_block_received_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbGcCrBlockReceivedPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbGcCrBlockReceivedPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbGcCrBlockReceivedPerTransactionDataPoint adds a data point to newrelic.oracle.db.gc_cr_block_received_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbGcCrBlockReceivedPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbGcCrBlockReceivedPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbGcCurrentBlockReceivedPerSecondDataPoint adds a data point to newrelic.oracle.db.gc_current_block_received_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbGcCurrentBlockReceivedPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbGcCurrentBlockReceivedPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbGcCurrentBlockReceivedPerTransactionDataPoint adds a data point to newrelic.oracle.db.gc_current_block_received_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbGcCurrentBlockReceivedPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbGcCurrentBlockReceivedPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbGlobalCacheAverageCrGetTimeDataPoint adds a data point to newrelic.oracle.db.global_cache_average_cr_get_time metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbGlobalCacheAverageCrGetTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbGlobalCacheAverageCrGetTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbGlobalCacheAverageCurrentGetTimeDataPoint adds a data point to newrelic.oracle.db.global_cache_average_current_get_time metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbGlobalCacheAverageCurrentGetTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbGlobalCacheAverageCurrentGetTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbHardParseCountPerSecondDataPoint adds a data point to newrelic.oracle.db.hard_parse_count_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbHardParseCountPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbHardParseCountPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbHardParseCountPerTransactionDataPoint adds a data point to newrelic.oracle.db.hard_parse_count_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbHardParseCountPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbHardParseCountPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbHostCPUUsagePerSecondDataPoint adds a data point to newrelic.oracle.db.host_cpu_usage_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbHostCPUUsagePerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbHostCPUUsagePerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbHostCPUUtilizationDataPoint adds a data point to newrelic.oracle.db.host_cpu_utilization metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbHostCPUUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbHostCPUUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbLeafNodeSplitsPerSecondDataPoint adds a data point to newrelic.oracle.db.leaf_node_splits_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbLeafNodeSplitsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbLeafNodeSplitsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbLeafNodeSplitsPerTransactionDataPoint adds a data point to newrelic.oracle.db.leaf_node_splits_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbLeafNodeSplitsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbLeafNodeSplitsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbLibraryCacheHitRatioDataPoint adds a data point to newrelic.oracle.db.library_cache_hit_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbLibraryCacheHitRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbLibraryCacheHitRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbLibraryCacheMissRatioDataPoint adds a data point to newrelic.oracle.db.library_cache_miss_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbLibraryCacheMissRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbLibraryCacheMissRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbLogicalReadsPerSecondDataPoint adds a data point to newrelic.oracle.db.logical_reads_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbLogicalReadsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbLogicalReadsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbLogicalReadsPerTransactionDataPoint adds a data point to newrelic.oracle.db.logical_reads_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbLogicalReadsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbLogicalReadsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbLogonsPerSecondDataPoint adds a data point to newrelic.oracle.db.logons_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbLogonsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbLogonsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbLogonsPerTransactionDataPoint adds a data point to newrelic.oracle.db.logons_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbLogonsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbLogonsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbLongTableScansPerSecondDataPoint adds a data point to newrelic.oracle.db.long_table_scans_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbLongTableScansPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbLongTableScansPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbLongTableScansPerTransactionDataPoint adds a data point to newrelic.oracle.db.long_table_scans_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbLongTableScansPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbLongTableScansPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbOpenCursorsPerSecondDataPoint adds a data point to newrelic.oracle.db.open_cursors_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbOpenCursorsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbOpenCursorsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbOpenCursorsPerTransactionDataPoint adds a data point to newrelic.oracle.db.open_cursors_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbOpenCursorsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbOpenCursorsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbOsLoadDataPoint adds a data point to newrelic.oracle.db.os_load metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbOsLoadDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbOsLoad.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbParseFailureCountPerSecondDataPoint adds a data point to newrelic.oracle.db.parse_failure_count_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbParseFailureCountPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbParseFailureCountPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbParseFailureCountPerTransactionDataPoint adds a data point to newrelic.oracle.db.parse_failure_count_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbParseFailureCountPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbParseFailureCountPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbPgaCacheHitPercentageDataPoint adds a data point to newrelic.oracle.db.pga_cache_hit_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbPgaCacheHitPercentageDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbPgaCacheHitPercentage.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbPhysicalReadBytesPerSecondDataPoint adds a data point to newrelic.oracle.db.physical_read_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbPhysicalReadBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbPhysicalReadBytesPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbPhysicalReadIoRequestsPerSecondDataPoint adds a data point to newrelic.oracle.db.physical_read_io_requests_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbPhysicalReadIoRequestsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbPhysicalReadIoRequestsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbPhysicalReadsPerSecondDataPoint adds a data point to newrelic.oracle.db.physical_reads_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbPhysicalReadsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbPhysicalReadsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbPhysicalWriteBytesPerSecondDataPoint adds a data point to newrelic.oracle.db.physical_write_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbPhysicalWriteBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbPhysicalWriteBytesPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbPhysicalWritesPerSecondDataPoint adds a data point to newrelic.oracle.db.physical_writes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbPhysicalWritesPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbPhysicalWritesPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbProcessLimitPercentageDataPoint adds a data point to newrelic.oracle.db.process_limit_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbProcessLimitPercentageDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbProcessLimitPercentage.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbRecursiveCallsPerSecondDataPoint adds a data point to newrelic.oracle.db.recursive_calls_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbRecursiveCallsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbRecursiveCallsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbRecursiveCallsPerTransactionDataPoint adds a data point to newrelic.oracle.db.recursive_calls_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbRecursiveCallsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbRecursiveCallsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbRedoWritesPerSecondDataPoint adds a data point to newrelic.oracle.db.redo_writes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbRedoWritesPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbRedoWritesPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbRedoWritesPerTransactionDataPoint adds a data point to newrelic.oracle.db.redo_writes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbRedoWritesPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbRedoWritesPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbResponseTimePerTransactionDataPoint adds a data point to newrelic.oracle.db.response_time_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbResponseTimePerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbResponseTimePerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbRowCacheHitRatioDataPoint adds a data point to newrelic.oracle.db.row_cache_hit_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbRowCacheHitRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbRowCacheHitRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbRowCacheMissRatioDataPoint adds a data point to newrelic.oracle.db.row_cache_miss_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbRowCacheMissRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbRowCacheMissRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbRowsPerSortDataPoint adds a data point to newrelic.oracle.db.rows_per_sort metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbRowsPerSortDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbRowsPerSort.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbSessionCountDataPoint adds a data point to newrelic.oracle.db.session_count metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbSessionCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleDbSessionCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbSessionLimitPercentageDataPoint adds a data point to newrelic.oracle.db.session_limit_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbSessionLimitPercentageDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbSessionLimitPercentage.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbSharedPoolFreePercentageDataPoint adds a data point to newrelic.oracle.db.shared_pool_free_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbSharedPoolFreePercentageDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbSharedPoolFreePercentage.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbSoftParseRatioDataPoint adds a data point to newrelic.oracle.db.soft_parse_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbSoftParseRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbSoftParseRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbSortsPerUserCallDataPoint adds a data point to newrelic.oracle.db.sorts_per_user_call metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbSortsPerUserCallDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbSortsPerUserCall.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbSQLServiceResponseTimeDataPoint adds a data point to newrelic.oracle.db.sql_service_response_time metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbSQLServiceResponseTimeDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbSQLServiceResponseTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbStreamsPoolUsagePercentageDataPoint adds a data point to newrelic.oracle.db.streams_pool_usage_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbStreamsPoolUsagePercentageDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbStreamsPoolUsagePercentage.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbTableScansPerUserCallDataPoint adds a data point to newrelic.oracle.db.table_scans_per_user_call metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbTableScansPerUserCallDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbTableScansPerUserCall.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbTotalIndexScansPerSecondDataPoint adds a data point to newrelic.oracle.db.total_index_scans_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbTotalIndexScansPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbTotalIndexScansPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbTotalIndexScansPerTransactionDataPoint adds a data point to newrelic.oracle.db.total_index_scans_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbTotalIndexScansPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbTotalIndexScansPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbTotalParseCountPerSecondDataPoint adds a data point to newrelic.oracle.db.total_parse_count_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbTotalParseCountPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbTotalParseCountPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbTotalParseCountPerTransactionDataPoint adds a data point to newrelic.oracle.db.total_parse_count_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbTotalParseCountPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbTotalParseCountPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbTotalTableScansPerSecondDataPoint adds a data point to newrelic.oracle.db.total_table_scans_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbTotalTableScansPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbTotalTableScansPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbTotalTableScansPerTransactionDataPoint adds a data point to newrelic.oracle.db.total_table_scans_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbTotalTableScansPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbTotalTableScansPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbTransactionsPerLogonDataPoint adds a data point to newrelic.oracle.db.transactions_per_logon metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbTransactionsPerLogonDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbTransactionsPerLogon.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbUserCallsPerSecondDataPoint adds a data point to newrelic.oracle.db.user_calls_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbUserCallsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbUserCallsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbUserCallsPerTransactionDataPoint adds a data point to newrelic.oracle.db.user_calls_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbUserCallsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbUserCallsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbUserCallsRatioDataPoint adds a data point to newrelic.oracle.db.user_calls_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbUserCallsRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbUserCallsRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbUserCommitsPerSecondDataPoint adds a data point to newrelic.oracle.db.user_commits_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbUserCommitsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbUserCommitsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbUserCommitsPercentageDataPoint adds a data point to newrelic.oracle.db.user_commits_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbUserCommitsPercentageDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbUserCommitsPercentage.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbUserLimitPercentageDataPoint adds a data point to newrelic.oracle.db.user_limit_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbUserLimitPercentageDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbUserLimitPercentage.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecondDataPoint adds a data point to newrelic.oracle.db.user_rollback_undo_records_applied_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransactionDataPoint adds a data point to newrelic.oracle.db.user_rollback_undo_records_applied_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbUserRollbackUndoRecordsAppliedPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbUserRollbacksPerSecondDataPoint adds a data point to newrelic.oracle.db.user_rollbacks_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbUserRollbacksPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbUserRollbacksPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbUserRollbacksPercentageDataPoint adds a data point to newrelic.oracle.db.user_rollbacks_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbUserRollbacksPercentageDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbUserRollbacksPercentage.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDbWaitTimeRatioDataPoint adds a data point to newrelic.oracle.db.wait_time_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDbWaitTimeRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDbWaitTimeRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskBlocksReadDataPoint adds a data point to newrelic.oracle.disk.blocks_read metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskBlocksReadDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleDiskBlocksRead.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskBlocksWrittenDataPoint adds a data point to newrelic.oracle.disk.blocks_written metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskBlocksWrittenDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleDiskBlocksWritten.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskLogicalReadsPerUserCallDataPoint adds a data point to newrelic.oracle.disk.logical_reads_per_user_call metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskLogicalReadsPerUserCallDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDiskLogicalReadsPerUserCall.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskPhysicalLobsReadsPerSecondDataPoint adds a data point to newrelic.oracle.disk.physical_lobs_reads_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskPhysicalLobsReadsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDiskPhysicalLobsReadsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskPhysicalLobsWritesPerSecondDataPoint adds a data point to newrelic.oracle.disk.physical_lobs_writes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskPhysicalLobsWritesPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDiskPhysicalLobsWritesPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskPhysicalReadBytesPerSecondDataPoint adds a data point to newrelic.oracle.disk.physical_read_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskPhysicalReadBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDiskPhysicalReadBytesPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskPhysicalReadIoRequestsPerSecondDataPoint adds a data point to newrelic.oracle.disk.physical_read_io_requests_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskPhysicalReadIoRequestsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDiskPhysicalReadIoRequestsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskPhysicalReadsPerSecondDataPoint adds a data point to newrelic.oracle.disk.physical_reads_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskPhysicalReadsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDiskPhysicalReadsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskPhysicalWriteBytesPerSecondDataPoint adds a data point to newrelic.oracle.disk.physical_write_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskPhysicalWriteBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDiskPhysicalWriteBytesPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecondDataPoint adds a data point to newrelic.oracle.disk.physical_write_total_io_requests_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDiskPhysicalWriteTotalIoRequestsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskPhysicalWritesPerSecondDataPoint adds a data point to newrelic.oracle.disk.physical_writes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskPhysicalWritesPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDiskPhysicalWritesPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskReadTimeMillisecondsDataPoint adds a data point to newrelic.oracle.disk.read_time_milliseconds metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskReadTimeMillisecondsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleDiskReadTimeMilliseconds.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskReadsDataPoint adds a data point to newrelic.oracle.disk.reads metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskReadsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleDiskReads.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskSortPerSecondDataPoint adds a data point to newrelic.oracle.disk.sort_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskSortPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDiskSortPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskSortPerTransactionDataPoint adds a data point to newrelic.oracle.disk.sort_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskSortPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleDiskSortPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskTempSpaceUsedBytesDataPoint adds a data point to newrelic.oracle.disk.temp_space_used_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskTempSpaceUsedBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleDiskTempSpaceUsedBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskWriteTimeMillisecondsDataPoint adds a data point to newrelic.oracle.disk.write_time_milliseconds metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskWriteTimeMillisecondsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleDiskWriteTimeMilliseconds.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleDiskWritesDataPoint adds a data point to newrelic.oracle.disk.writes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleDiskWritesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleDiskWrites.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleLockedAccountsDataPoint adds a data point to newrelic.oracle.locked_accounts metric.
func (mb *MetricsBuilder) RecordNewrelicOracleLockedAccountsDataPoint(ts pcommon.Timestamp, val int64, instanceIDAttributeValue string) {
	mb.metricNewrelicOracleLockedAccounts.recordDataPoint(mb.startTime, ts, val, instanceIDAttributeValue)
}

// RecordNewrelicOracleLongRunningQueriesDataPoint adds a data point to newrelic.oracle.long_running_queries metric.
func (mb *MetricsBuilder) RecordNewrelicOracleLongRunningQueriesDataPoint(ts pcommon.Timestamp, val int64, instanceIDAttributeValue string) {
	mb.metricNewrelicOracleLongRunningQueries.recordDataPoint(mb.startTime, ts, val, instanceIDAttributeValue)
}

// RecordNewrelicOracleMemoryBufferCacheHitRatioDataPoint adds a data point to newrelic.oracle.memory.buffer_cache_hit_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleMemoryBufferCacheHitRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleMemoryBufferCacheHitRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleMemoryGlobalCacheBlocksCorruptedDataPoint adds a data point to newrelic.oracle.memory.global_cache_blocks_corrupted metric.
func (mb *MetricsBuilder) RecordNewrelicOracleMemoryGlobalCacheBlocksCorruptedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleMemoryGlobalCacheBlocksCorrupted.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleMemoryGlobalCacheBlocksLostDataPoint adds a data point to newrelic.oracle.memory.global_cache_blocks_lost metric.
func (mb *MetricsBuilder) RecordNewrelicOracleMemoryGlobalCacheBlocksLostDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleMemoryGlobalCacheBlocksLost.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleMemoryPgaAllocatedBytesDataPoint adds a data point to newrelic.oracle.memory.pga_allocated_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleMemoryPgaAllocatedBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleMemoryPgaAllocatedBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleMemoryPgaFreeableBytesDataPoint adds a data point to newrelic.oracle.memory.pga_freeable_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleMemoryPgaFreeableBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleMemoryPgaFreeableBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleMemoryPgaInUseBytesDataPoint adds a data point to newrelic.oracle.memory.pga_in_use_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleMemoryPgaInUseBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleMemoryPgaInUseBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleMemoryPgaMaxSizeBytesDataPoint adds a data point to newrelic.oracle.memory.pga_max_size_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleMemoryPgaMaxSizeBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleMemoryPgaMaxSizeBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleMemoryRedoAllocationHitRatioDataPoint adds a data point to newrelic.oracle.memory.redo_allocation_hit_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleMemoryRedoAllocationHitRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleMemoryRedoAllocationHitRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleMemoryRedoGeneratedBytesPerSecondDataPoint adds a data point to newrelic.oracle.memory.redo_generated_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleMemoryRedoGeneratedBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleMemoryRedoGeneratedBytesPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleMemoryRedoGeneratedBytesPerTransactionDataPoint adds a data point to newrelic.oracle.memory.redo_generated_bytes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleMemoryRedoGeneratedBytesPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleMemoryRedoGeneratedBytesPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleMemorySortsRatioDataPoint adds a data point to newrelic.oracle.memory.sorts_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleMemorySortsRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleMemorySortsRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleNetworkIoMegabytesPerSecondDataPoint adds a data point to newrelic.oracle.network.io_megabytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleNetworkIoMegabytesPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleNetworkIoMegabytesPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleNetworkIoRequestsPerSecondDataPoint adds a data point to newrelic.oracle.network.io_requests_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleNetworkIoRequestsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleNetworkIoRequestsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleNetworkTrafficBytesPerSecondDataPoint adds a data point to newrelic.oracle.network.traffic_bytes_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleNetworkTrafficBytesPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleNetworkTrafficBytesPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleQueryPhysicalLobsReadsPerTransactionDataPoint adds a data point to newrelic.oracle.query.physical_lobs_reads_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleQueryPhysicalLobsReadsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleQueryPhysicalLobsReadsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleQueryPhysicalLobsWritesPerTransactionDataPoint adds a data point to newrelic.oracle.query.physical_lobs_writes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleQueryPhysicalLobsWritesPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleQueryPhysicalLobsWritesPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleQueryPhysicalReadsPerTransactionDataPoint adds a data point to newrelic.oracle.query.physical_reads_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleQueryPhysicalReadsPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleQueryPhysicalReadsPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleQueryPhysicalWritesPerTransactionDataPoint adds a data point to newrelic.oracle.query.physical_writes_per_transaction metric.
func (mb *MetricsBuilder) RecordNewrelicOracleQueryPhysicalWritesPerTransactionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleQueryPhysicalWritesPerTransaction.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleQueryTransactionsPerSecondDataPoint adds a data point to newrelic.oracle.query.transactions_per_second metric.
func (mb *MetricsBuilder) RecordNewrelicOracleQueryTransactionsPerSecondDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleQueryTransactionsPerSecond.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleRedoLogFileSwitchDataPoint adds a data point to newrelic.oracle.redo_log.file_switch metric.
func (mb *MetricsBuilder) RecordNewrelicOracleRedoLogFileSwitchDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleRedoLogFileSwitch.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleRedoLogFileSwitchArchivingNeededDataPoint adds a data point to newrelic.oracle.redo_log.file_switch_archiving_needed metric.
func (mb *MetricsBuilder) RecordNewrelicOracleRedoLogFileSwitchArchivingNeededDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleRedoLogFileSwitchArchivingNeeded.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleRedoLogFileSwitchCheckpointIncompleteDataPoint adds a data point to newrelic.oracle.redo_log.file_switch_checkpoint_incomplete metric.
func (mb *MetricsBuilder) RecordNewrelicOracleRedoLogFileSwitchCheckpointIncompleteDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleRedoLogFileSwitchCheckpointIncomplete.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleRedoLogWaitsDataPoint adds a data point to newrelic.oracle.redo_log.waits metric.
func (mb *MetricsBuilder) RecordNewrelicOracleRedoLogWaitsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleRedoLogWaits.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleRollbackSegmentsGetsDataPoint adds a data point to newrelic.oracle.rollback_segments.gets metric.
func (mb *MetricsBuilder) RecordNewrelicOracleRollbackSegmentsGetsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleRollbackSegmentsGets.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleRollbackSegmentsRatioWaitDataPoint adds a data point to newrelic.oracle.rollback_segments.ratio_wait metric.
func (mb *MetricsBuilder) RecordNewrelicOracleRollbackSegmentsRatioWaitDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleRollbackSegmentsRatioWait.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleRollbackSegmentsWaitsDataPoint adds a data point to newrelic.oracle.rollback_segments.waits metric.
func (mb *MetricsBuilder) RecordNewrelicOracleRollbackSegmentsWaitsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleRollbackSegmentsWaits.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaBufferBusyWaitsDataPoint adds a data point to newrelic.oracle.sga.buffer_busy_waits metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaBufferBusyWaitsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleSgaBufferBusyWaits.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaFixedSizeBytesDataPoint adds a data point to newrelic.oracle.sga.fixed_size_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaFixedSizeBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleSgaFixedSizeBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaFreeBufferInspectedDataPoint adds a data point to newrelic.oracle.sga.free_buffer_inspected metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaFreeBufferInspectedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleSgaFreeBufferInspected.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaFreeBufferWaitsDataPoint adds a data point to newrelic.oracle.sga.free_buffer_waits metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaFreeBufferWaitsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleSgaFreeBufferWaits.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaHitRatioDataPoint adds a data point to newrelic.oracle.sga.hit_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaHitRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleSgaHitRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaLogBufferAllocationRetriesRatioDataPoint adds a data point to newrelic.oracle.sga.log_buffer_allocation_retries_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaLogBufferAllocationRetriesRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleSgaLogBufferAllocationRetriesRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaLogBufferRedoAllocationRetriesDataPoint adds a data point to newrelic.oracle.sga.log_buffer_redo_allocation_retries metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaLogBufferRedoAllocationRetriesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleSgaLogBufferRedoAllocationRetries.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaLogBufferRedoEntriesDataPoint adds a data point to newrelic.oracle.sga.log_buffer_redo_entries metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaLogBufferRedoEntriesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleSgaLogBufferRedoEntries.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaLogBufferSpaceWaitsDataPoint adds a data point to newrelic.oracle.sga.log_buffer_space_waits metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaLogBufferSpaceWaitsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleSgaLogBufferSpaceWaits.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaRedoBuffersBytesDataPoint adds a data point to newrelic.oracle.sga.redo_buffers_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaRedoBuffersBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleSgaRedoBuffersBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaSharedPoolDictCacheMissRatioDataPoint adds a data point to newrelic.oracle.sga.shared_pool_dict_cache_miss_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaSharedPoolDictCacheMissRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleSgaSharedPoolDictCacheMissRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaSharedPoolLibraryCacheHitRatioDataPoint adds a data point to newrelic.oracle.sga.shared_pool_library_cache_hit_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaSharedPoolLibraryCacheHitRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleSgaSharedPoolLibraryCacheHitRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaSharedPoolLibraryCacheReloadRatioDataPoint adds a data point to newrelic.oracle.sga.shared_pool_library_cache_reload_ratio metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaSharedPoolLibraryCacheReloadRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricNewrelicOracleSgaSharedPoolLibraryCacheReloadRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytesDataPoint adds a data point to newrelic.oracle.sga.shared_pool_library_cache_shareable_memory_per_statement_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerStatementBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytesDataPoint adds a data point to newrelic.oracle.sga.shared_pool_library_cache_shareable_memory_per_user_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleSgaSharedPoolLibraryCacheShareableMemoryPerUserBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSgaUgaTotalMemoryBytesDataPoint adds a data point to newrelic.oracle.sga.uga_total_memory_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSgaUgaTotalMemoryBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleSgaUgaTotalMemoryBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSortsDiskBytesDataPoint adds a data point to newrelic.oracle.sorts.disk_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSortsDiskBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleSortsDiskBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleSortsMemoryBytesDataPoint adds a data point to newrelic.oracle.sorts.memory_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleSortsMemoryBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricNewrelicOracleSortsMemoryBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordNewrelicOracleTablespaceIsOfflineDataPoint adds a data point to newrelic.oracle.tablespace.is_offline metric.
func (mb *MetricsBuilder) RecordNewrelicOracleTablespaceIsOfflineDataPoint(ts pcommon.Timestamp, val int64, tablespaceNameAttributeValue string) {
	mb.metricNewrelicOracleTablespaceIsOffline.recordDataPoint(mb.startTime, ts, val, tablespaceNameAttributeValue)
}

// RecordNewrelicOracleTablespaceOfflineCdbDatafilesDataPoint adds a data point to newrelic.oracle.tablespace.offline_cdb_datafiles metric.
func (mb *MetricsBuilder) RecordNewrelicOracleTablespaceOfflineCdbDatafilesDataPoint(ts pcommon.Timestamp, val int64, tablespaceNameAttributeValue string) {
	mb.metricNewrelicOracleTablespaceOfflineCdbDatafiles.recordDataPoint(mb.startTime, ts, val, tablespaceNameAttributeValue)
}

// RecordNewrelicOracleTablespaceOfflinePdbDatafilesDataPoint adds a data point to newrelic.oracle.tablespace.offline_pdb_datafiles metric.
func (mb *MetricsBuilder) RecordNewrelicOracleTablespaceOfflinePdbDatafilesDataPoint(ts pcommon.Timestamp, val int64, tablespaceNameAttributeValue string) {
	mb.metricNewrelicOracleTablespaceOfflinePdbDatafiles.recordDataPoint(mb.startTime, ts, val, tablespaceNameAttributeValue)
}

// RecordNewrelicOracleTablespacePdbDatafilesNonWriteDataPoint adds a data point to newrelic.oracle.tablespace.pdb_datafiles_non_write metric.
func (mb *MetricsBuilder) RecordNewrelicOracleTablespacePdbDatafilesNonWriteDataPoint(ts pcommon.Timestamp, val int64, tablespaceNameAttributeValue string) {
	mb.metricNewrelicOracleTablespacePdbDatafilesNonWrite.recordDataPoint(mb.startTime, ts, val, tablespaceNameAttributeValue)
}

// RecordNewrelicOracleTablespaceSpaceConsumedBytesDataPoint adds a data point to newrelic.oracle.tablespace.space_consumed_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleTablespaceSpaceConsumedBytesDataPoint(ts pcommon.Timestamp, val int64, tablespaceNameAttributeValue string) {
	mb.metricNewrelicOracleTablespaceSpaceConsumedBytes.recordDataPoint(mb.startTime, ts, val, tablespaceNameAttributeValue)
}

// RecordNewrelicOracleTablespaceSpaceReservedBytesDataPoint adds a data point to newrelic.oracle.tablespace.space_reserved_bytes metric.
func (mb *MetricsBuilder) RecordNewrelicOracleTablespaceSpaceReservedBytesDataPoint(ts pcommon.Timestamp, val int64, tablespaceNameAttributeValue string) {
	mb.metricNewrelicOracleTablespaceSpaceReservedBytes.recordDataPoint(mb.startTime, ts, val, tablespaceNameAttributeValue)
}

// RecordNewrelicOracleTablespaceSpaceUsedPercentageDataPoint adds a data point to newrelic.oracle.tablespace.space_used_percentage metric.
func (mb *MetricsBuilder) RecordNewrelicOracleTablespaceSpaceUsedPercentageDataPoint(ts pcommon.Timestamp, val float64, tablespaceNameAttributeValue string) {
	mb.metricNewrelicOracleTablespaceSpaceUsedPercentage.recordDataPoint(mb.startTime, ts, val, tablespaceNameAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
