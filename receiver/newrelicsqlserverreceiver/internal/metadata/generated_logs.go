// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"context"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/filter"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/plog"
	"go.opentelemetry.io/collector/receiver"
	"go.opentelemetry.io/otel/trace"
)

type eventSqlserverActiveQueryExecutionPlan struct {
	data   plog.LogRecordSlice // data buffer for generated log records.
	config EventConfig         // event config provided by user.
}

func (e *eventSqlserverActiveQueryExecutionPlan) recordEvent(ctx context.Context, timestamp pcommon.Timestamp, newrelicEventTypeAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, startTimeAttributeValue string, nodeIDAttributeValue int64, parentNodeIDAttributeValue int64, inputTypeAttributeValue string, physicalOpAttributeValue string, logicalOpAttributeValue string, queryTextAttributeValue string, schemaNameAttributeValue string, tableNameAttributeValue string, indexNameAttributeValue string, referencedColumnsAttributeValue string, estimateRowsAttributeValue float64, estimateIoAttributeValue float64, estimateCPUAttributeValue float64, avgRowSizeAttributeValue float64, totalSubtreeCostAttributeValue float64, estimatedOperatorCostAttributeValue float64, estimatedExecutionModeAttributeValue string, grantedMemoryKbAttributeValue int64, spillOccurredAttributeValue bool, noJoinPredicateAttributeValue bool, totalWorkerTimeAttributeValue float64, totalElapsedTimeAttributeValue float64, totalLogicalReadsAttributeValue int64, totalLogicalWritesAttributeValue int64, executionCountAttributeValue int64, avgElapsedTimeMsAttributeValue float64, lastExecutionTimeAttributeValue string) {
	if !e.config.Enabled {
		return
	}
	dp := e.data.AppendEmpty()
	dp.SetEventName("sqlserver.active_query_execution_plan")
	dp.SetTimestamp(timestamp)

	if span := trace.SpanContextFromContext(ctx); span.IsValid() {
		dp.SetTraceID(pcommon.TraceID(span.TraceID()))
		dp.SetSpanID(pcommon.SpanID(span.SpanID()))
	}
	dp.Attributes().PutStr("newrelic_event_type", newrelicEventTypeAttributeValue)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("start_time", startTimeAttributeValue)
	dp.Attributes().PutInt("node_id", nodeIDAttributeValue)
	dp.Attributes().PutInt("parent_node_id", parentNodeIDAttributeValue)
	dp.Attributes().PutStr("input_type", inputTypeAttributeValue)
	dp.Attributes().PutStr("physical_op", physicalOpAttributeValue)
	dp.Attributes().PutStr("logical_op", logicalOpAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("table_name", tableNameAttributeValue)
	dp.Attributes().PutStr("index_name", indexNameAttributeValue)
	dp.Attributes().PutStr("referenced_columns", referencedColumnsAttributeValue)
	dp.Attributes().PutDouble("estimate_rows", estimateRowsAttributeValue)
	dp.Attributes().PutDouble("estimate_io", estimateIoAttributeValue)
	dp.Attributes().PutDouble("estimate_cpu", estimateCPUAttributeValue)
	dp.Attributes().PutDouble("avg_row_size", avgRowSizeAttributeValue)
	dp.Attributes().PutDouble("total_subtree_cost", totalSubtreeCostAttributeValue)
	dp.Attributes().PutDouble("estimated_operator_cost", estimatedOperatorCostAttributeValue)
	dp.Attributes().PutStr("estimated_execution_mode", estimatedExecutionModeAttributeValue)
	dp.Attributes().PutInt("granted_memory_kb", grantedMemoryKbAttributeValue)
	dp.Attributes().PutBool("spill_occurred", spillOccurredAttributeValue)
	dp.Attributes().PutBool("no_join_predicate", noJoinPredicateAttributeValue)
	dp.Attributes().PutDouble("total_worker_time", totalWorkerTimeAttributeValue)
	dp.Attributes().PutDouble("total_elapsed_time", totalElapsedTimeAttributeValue)
	dp.Attributes().PutInt("total_logical_reads", totalLogicalReadsAttributeValue)
	dp.Attributes().PutInt("total_logical_writes", totalLogicalWritesAttributeValue)
	dp.Attributes().PutInt("execution_count", executionCountAttributeValue)
	dp.Attributes().PutDouble("avg_elapsed_time_ms", avgElapsedTimeMsAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)

}

// emit appends recorded event data to a events slice and prepares it for recording another set of log records.
func (e *eventSqlserverActiveQueryExecutionPlan) emit(lrs plog.LogRecordSlice) {
	if e.config.Enabled && e.data.Len() > 0 {
		e.data.MoveAndAppendTo(lrs)
	}
}

func newEventSqlserverActiveQueryExecutionPlan(cfg EventConfig) eventSqlserverActiveQueryExecutionPlan {
	e := eventSqlserverActiveQueryExecutionPlan{config: cfg}
	if cfg.Enabled {
		e.data = plog.NewLogRecordSlice()
	}
	return e
}

// LogsBuilder provides an interface for scrapers to report logs while taking care of all the transformations
// required to produce log representation defined in metadata and user config.
type LogsBuilder struct {
	config                                 LogsBuilderConfig // config of the logs builder.
	logsBuffer                             plog.Logs
	logRecordsBuffer                       plog.LogRecordSlice
	buildInfo                              component.BuildInfo // contains version information.
	resourceAttributeIncludeFilter         map[string]filter.Filter
	resourceAttributeExcludeFilter         map[string]filter.Filter
	eventSqlserverActiveQueryExecutionPlan eventSqlserverActiveQueryExecutionPlan
}

// LogBuilderOption applies changes to default logs builder.
type LogBuilderOption interface {
	apply(*LogsBuilder)
}

func NewLogsBuilder(lbc LogsBuilderConfig, settings receiver.Settings) *LogsBuilder {
	lb := &LogsBuilder{
		config:                                 lbc,
		logsBuffer:                             plog.NewLogs(),
		logRecordsBuffer:                       plog.NewLogRecordSlice(),
		buildInfo:                              settings.BuildInfo,
		eventSqlserverActiveQueryExecutionPlan: newEventSqlserverActiveQueryExecutionPlan(lbc.Events.SqlserverActiveQueryExecutionPlan),
		resourceAttributeIncludeFilter:         make(map[string]filter.Filter),
		resourceAttributeExcludeFilter:         make(map[string]filter.Filter),
	}
	if lbc.ResourceAttributes.DatabaseName.EventsInclude != nil {
		lb.resourceAttributeIncludeFilter["database_name"] = filter.CreateFilter(lbc.ResourceAttributes.DatabaseName.EventsInclude)
	}
	if lbc.ResourceAttributes.DatabaseName.EventsExclude != nil {
		lb.resourceAttributeExcludeFilter["database_name"] = filter.CreateFilter(lbc.ResourceAttributes.DatabaseName.EventsExclude)
	}
	if lbc.ResourceAttributes.DbSystem.EventsInclude != nil {
		lb.resourceAttributeIncludeFilter["db.system"] = filter.CreateFilter(lbc.ResourceAttributes.DbSystem.EventsInclude)
	}
	if lbc.ResourceAttributes.DbSystem.EventsExclude != nil {
		lb.resourceAttributeExcludeFilter["db.system"] = filter.CreateFilter(lbc.ResourceAttributes.DbSystem.EventsExclude)
	}
	if lbc.ResourceAttributes.EngineEdition.EventsInclude != nil {
		lb.resourceAttributeIncludeFilter["engine_edition"] = filter.CreateFilter(lbc.ResourceAttributes.EngineEdition.EventsInclude)
	}
	if lbc.ResourceAttributes.EngineEdition.EventsExclude != nil {
		lb.resourceAttributeExcludeFilter["engine_edition"] = filter.CreateFilter(lbc.ResourceAttributes.EngineEdition.EventsExclude)
	}
	if lbc.ResourceAttributes.ServerAddress.EventsInclude != nil {
		lb.resourceAttributeIncludeFilter["server.address"] = filter.CreateFilter(lbc.ResourceAttributes.ServerAddress.EventsInclude)
	}
	if lbc.ResourceAttributes.ServerAddress.EventsExclude != nil {
		lb.resourceAttributeExcludeFilter["server.address"] = filter.CreateFilter(lbc.ResourceAttributes.ServerAddress.EventsExclude)
	}
	if lbc.ResourceAttributes.ServerPort.EventsInclude != nil {
		lb.resourceAttributeIncludeFilter["server.port"] = filter.CreateFilter(lbc.ResourceAttributes.ServerPort.EventsInclude)
	}
	if lbc.ResourceAttributes.ServerPort.EventsExclude != nil {
		lb.resourceAttributeExcludeFilter["server.port"] = filter.CreateFilter(lbc.ResourceAttributes.ServerPort.EventsExclude)
	}

	return lb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted logs.
func (lb *LogsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(lb.config.ResourceAttributes)
}

// ResourceLogsOption applies changes to provided resource logs.
type ResourceLogsOption interface {
	apply(plog.ResourceLogs)
}

type resourceLogsOptionFunc func(plog.ResourceLogs)

func (rlof resourceLogsOptionFunc) apply(rl plog.ResourceLogs) {
	rlof(rl)
}

// WithLogsResource sets the provided resource on the emitted ResourceLogs.
// It's recommended to use ResourceBuilder to create the resource.
func WithLogsResource(res pcommon.Resource) ResourceLogsOption {
	return resourceLogsOptionFunc(func(rl plog.ResourceLogs) {
		res.CopyTo(rl.Resource())
	})
}

// AppendLogRecord adds a log record to the logs builder.
func (lb *LogsBuilder) AppendLogRecord(lr plog.LogRecord) {
	lr.MoveTo(lb.logRecordsBuffer.AppendEmpty())
}

// EmitForResource saves all the generated logs under a new resource and updates the internal state to be ready for
// recording another set of log records as part of another resource. This function can be helpful when one scraper
// needs to emit logs from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceLogsOption arguments.
func (lb *LogsBuilder) EmitForResource(options ...ResourceLogsOption) {
	rl := plog.NewResourceLogs()
	ils := rl.ScopeLogs().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(lb.buildInfo.Version)
	lb.eventSqlserverActiveQueryExecutionPlan.emit(ils.LogRecords())

	for _, op := range options {
		op.apply(rl)
	}

	if lb.logRecordsBuffer.Len() > 0 {
		lb.logRecordsBuffer.MoveAndAppendTo(ils.LogRecords())
		lb.logRecordsBuffer = plog.NewLogRecordSlice()
	}

	for attr, filter := range lb.resourceAttributeIncludeFilter {
		if val, ok := rl.Resource().Attributes().Get(attr); ok && !filter.Matches(val.AsString()) {
			return
		}
	}
	for attr, filter := range lb.resourceAttributeExcludeFilter {
		if val, ok := rl.Resource().Attributes().Get(attr); ok && filter.Matches(val.AsString()) {
			return
		}
	}

	if ils.LogRecords().Len() > 0 {
		rl.MoveTo(lb.logsBuffer.ResourceLogs().AppendEmpty())
	}
}

// Emit returns all the logs accumulated by the logs builder and updates the internal state to be ready for
// recording another set of logs. This function will be responsible for applying all the transformations required to
// produce logs representation defined in metadata and user config.
func (lb *LogsBuilder) Emit(options ...ResourceLogsOption) plog.Logs {
	lb.EmitForResource(options...)
	logs := lb.logsBuffer
	lb.logsBuffer = plog.NewLogs()
	return logs
}

// RecordSqlserverActiveQueryExecutionPlanEvent adds a log record of sqlserver.active_query_execution_plan event.
func (lb *LogsBuilder) RecordSqlserverActiveQueryExecutionPlanEvent(ctx context.Context, timestamp pcommon.Timestamp, newrelicEventTypeAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, startTimeAttributeValue string, nodeIDAttributeValue int64, parentNodeIDAttributeValue int64, inputTypeAttributeValue string, physicalOpAttributeValue string, logicalOpAttributeValue string, queryTextAttributeValue string, schemaNameAttributeValue string, tableNameAttributeValue string, indexNameAttributeValue string, referencedColumnsAttributeValue string, estimateRowsAttributeValue float64, estimateIoAttributeValue float64, estimateCPUAttributeValue float64, avgRowSizeAttributeValue float64, totalSubtreeCostAttributeValue float64, estimatedOperatorCostAttributeValue float64, estimatedExecutionModeAttributeValue string, grantedMemoryKbAttributeValue int64, spillOccurredAttributeValue bool, noJoinPredicateAttributeValue bool, totalWorkerTimeAttributeValue float64, totalElapsedTimeAttributeValue float64, totalLogicalReadsAttributeValue int64, totalLogicalWritesAttributeValue int64, executionCountAttributeValue int64, avgElapsedTimeMsAttributeValue float64, lastExecutionTimeAttributeValue string) {
	lb.eventSqlserverActiveQueryExecutionPlan.recordEvent(ctx, timestamp, newrelicEventTypeAttributeValue, queryIDAttributeValue, planHandleAttributeValue, sessionIDAttributeValue, requestIDAttributeValue, databaseNameAttributeValue, startTimeAttributeValue, nodeIDAttributeValue, parentNodeIDAttributeValue, inputTypeAttributeValue, physicalOpAttributeValue, logicalOpAttributeValue, queryTextAttributeValue, schemaNameAttributeValue, tableNameAttributeValue, indexNameAttributeValue, referencedColumnsAttributeValue, estimateRowsAttributeValue, estimateIoAttributeValue, estimateCPUAttributeValue, avgRowSizeAttributeValue, totalSubtreeCostAttributeValue, estimatedOperatorCostAttributeValue, estimatedExecutionModeAttributeValue, grantedMemoryKbAttributeValue, spillOccurredAttributeValue, noJoinPredicateAttributeValue, totalWorkerTimeAttributeValue, totalElapsedTimeAttributeValue, totalLogicalReadsAttributeValue, totalLogicalWritesAttributeValue, executionCountAttributeValue, avgElapsedTimeMsAttributeValue, lastExecutionTimeAttributeValue)
}
