// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/filter"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

var MetricsInfo = metricsInfo{
	ActiveConnections: metricInfo{
		Name: "activeConnections",
	},
	InstanceBackgroundProcessesCount: metricInfo{
		Name: "instance.backgroundProcessesCount",
	},
	InstanceBlockedProcessesCount: metricInfo{
		Name: "instance.blockedProcessesCount",
	},
	InstanceDiskInBytes: metricInfo{
		Name: "instance.diskInBytes",
	},
	InstanceDormantProcessesCount: metricInfo{
		Name: "instance.dormantProcessesCount",
	},
	InstancePreconnectProcessesCount: metricInfo{
		Name: "instance.preconnectProcessesCount",
	},
	InstanceRunnableProcessesCount: metricInfo{
		Name: "instance.runnableProcessesCount",
	},
	InstanceRunnableTasks: metricInfo{
		Name: "instance.runnableTasks",
	},
	InstanceRunningProcessesCount: metricInfo{
		Name: "instance.runningProcessesCount",
	},
	InstanceSleepingProcessesCount: metricInfo{
		Name: "instance.sleepingProcessesCount",
	},
	InstanceSuspendedProcessesCount: metricInfo{
		Name: "instance.suspendedProcessesCount",
	},
	SqlserverAccessPageSplitsPerSec: metricInfo{
		Name: "sqlserver.access.page_splits_per_sec",
	},
	SqlserverActivequeryCPUTimeMs: metricInfo{
		Name: "sqlserver.activequery.cpu_time_ms",
	},
	SqlserverActivequeryElapsedTimeMs: metricInfo{
		Name: "sqlserver.activequery.elapsed_time_ms",
	},
	SqlserverActivequeryGrantedQueryMemoryPages: metricInfo{
		Name: "sqlserver.activequery.granted_query_memory_pages",
	},
	SqlserverActivequeryLogicalReads: metricInfo{
		Name: "sqlserver.activequery.logical_reads",
	},
	SqlserverActivequeryReads: metricInfo{
		Name: "sqlserver.activequery.reads",
	},
	SqlserverActivequeryRowCount: metricInfo{
		Name: "sqlserver.activequery.row_count",
	},
	SqlserverActivequeryWaitTimeSeconds: metricInfo{
		Name: "sqlserver.activequery.wait_time_seconds",
	},
	SqlserverActivequeryWrites: metricInfo{
		Name: "sqlserver.activequery.writes",
	},
	SqlserverBufferCacheHitRatio: metricInfo{
		Name: "sqlserver.buffer.cache_hit_ratio",
	},
	SqlserverBufferCheckpointPagesPerSec: metricInfo{
		Name: "sqlserver.buffer.checkpoint_pages_per_sec",
	},
	SqlserverBufferPageLifeExpectancy: metricInfo{
		Name: "sqlserver.buffer.page_life_expectancy",
	},
	SqlserverBufferPoolHitPercent: metricInfo{
		Name: "sqlserver.bufferPoolHitPercent",
	},
	SqlserverBufferpoolBatchRequestsPerSec: metricInfo{
		Name: "sqlserver.bufferpool.batch_requests_per_sec",
	},
	SqlserverBufferpoolPageLifeExpectancyMs: metricInfo{
		Name: "sqlserver.bufferpool.page_life_expectancy_ms",
	},
	SqlserverConnectionsUser: metricInfo{
		Name: "sqlserver.connections.user",
	},
	SqlserverDatabaseBufferpoolSizePerDatabaseInBytes: metricInfo{
		Name: "sqlserver.database.bufferpool.sizePerDatabaseInBytes",
	},
	SqlserverDatabaseIoStallInMilliseconds: metricInfo{
		Name: "sqlserver.database.io.stallInMilliseconds",
	},
	SqlserverDatabaseLogBytesFlushesPerSec: metricInfo{
		Name: "sqlserver.database.log.bytesFlushesPerSec",
	},
	SqlserverDatabaseLogFlushWaitsPerSec: metricInfo{
		Name: "sqlserver.database.log.flushWaitsPerSec",
	},
	SqlserverDatabaseLogFlushesPerSec: metricInfo{
		Name: "sqlserver.database.log.flushesPerSec",
	},
	SqlserverDatabaseLogTransactionGrowth: metricInfo{
		Name: "sqlserver.database.log.transactionGrowth",
	},
	SqlserverDatabaseLogUsedSpaceMB: metricInfo{
		Name: "sqlserver.database.log.usedSpaceMB",
	},
	SqlserverDatabaseMaxDiskSizeInBytes: metricInfo{
		Name: "sqlserver.database.maxDiskSizeInBytes",
	},
	SqlserverDatabasePageFileAvailable: metricInfo{
		Name: "sqlserver.database.pageFileAvailable",
	},
	SqlserverDatabasePageFileTotal: metricInfo{
		Name: "sqlserver.database.pageFileTotal",
	},
	SqlserverDatabasePrincipalCreateDate: metricInfo{
		Name: "sqlserver.database.principal.createDate",
	},
	SqlserverDatabasePrincipalsApplicationRoles: metricInfo{
		Name: "sqlserver.database.principals.applicationRoles",
	},
	SqlserverDatabasePrincipalsOld: metricInfo{
		Name: "sqlserver.database.principals.old",
	},
	SqlserverDatabasePrincipalsOrphanedUsers: metricInfo{
		Name: "sqlserver.database.principals.orphanedUsers",
	},
	SqlserverDatabasePrincipalsRecentlyCreated: metricInfo{
		Name: "sqlserver.database.principals.recentlyCreated",
	},
	SqlserverDatabasePrincipalsRoles: metricInfo{
		Name: "sqlserver.database.principals.roles",
	},
	SqlserverDatabasePrincipalsSQLUsers: metricInfo{
		Name: "sqlserver.database.principals.sqlUsers",
	},
	SqlserverDatabasePrincipalsTotal: metricInfo{
		Name: "sqlserver.database.principals.total",
	},
	SqlserverDatabasePrincipalsUsers: metricInfo{
		Name: "sqlserver.database.principals.users",
	},
	SqlserverDatabasePrincipalsWindowsUsers: metricInfo{
		Name: "sqlserver.database.principals.windowsUsers",
	},
	SqlserverDatabaseRoleMembersApplicationRoles: metricInfo{
		Name: "sqlserver.database.role.members.applicationRoles",
	},
	SqlserverDatabaseRoleMembersCrossRole: metricInfo{
		Name: "sqlserver.database.role.members.crossRole",
	},
	SqlserverDatabaseRoleMembersHighPrivilege: metricInfo{
		Name: "sqlserver.database.role.members.highPrivilege",
	},
	SqlserverDatabaseRoleMembersUnique: metricInfo{
		Name: "sqlserver.database.role.members.unique",
	},
	SqlserverDatabaseRoleMembershipActive: metricInfo{
		Name: "sqlserver.database.role.membership.active",
	},
	SqlserverDatabaseRoleMembershipsActive: metricInfo{
		Name: "sqlserver.database.role.memberships.active",
	},
	SqlserverDatabaseRoleMembershipsCustom: metricInfo{
		Name: "sqlserver.database.role.memberships.custom",
	},
	SqlserverDatabaseRoleMembershipsNested: metricInfo{
		Name: "sqlserver.database.role.memberships.nested",
	},
	SqlserverDatabaseRoleMembershipsTotal: metricInfo{
		Name: "sqlserver.database.role.memberships.total",
	},
	SqlserverDatabaseRoleMembershipsUsers: metricInfo{
		Name: "sqlserver.database.role.memberships.users",
	},
	SqlserverDatabaseRoleNestingLevel: metricInfo{
		Name: "sqlserver.database.role.nesting.level",
	},
	SqlserverDatabaseRolePermissionMemberCount: metricInfo{
		Name: "sqlserver.database.role.permission.memberCount",
	},
	SqlserverDatabaseRolePermissionRiskLevel: metricInfo{
		Name: "sqlserver.database.role.permission.riskLevel",
	},
	SqlserverDatabaseRolePermissionsInherited: metricInfo{
		Name: "sqlserver.database.role.permissions.inherited",
	},
	SqlserverDatabaseRoleRolesEmpty: metricInfo{
		Name: "sqlserver.database.role.roles.empty",
	},
	SqlserverDatabaseRoleRolesWithMembers: metricInfo{
		Name: "sqlserver.database.role.roles.withMembers",
	},
	SqlserverDatabaseSizeDataSizeMB: metricInfo{
		Name: "sqlserver.database.size.dataSizeMB",
	},
	SqlserverDatabaseSizeTotalSizeMB: metricInfo{
		Name: "sqlserver.database.size.totalSizeMB",
	},
	SqlserverDatabaseTransactionsActive: metricInfo{
		Name: "sqlserver.database.transactions.active",
	},
	SqlserverFailoverClusterAgClusterType: metricInfo{
		Name: "sqlserver.failover_cluster.ag_cluster_type",
	},
	SqlserverFailoverClusterAgFailureConditionLevel: metricInfo{
		Name: "sqlserver.failover_cluster.ag_failure_condition_level",
	},
	SqlserverFailoverClusterAgHealthCheckTimeout: metricInfo{
		Name: "sqlserver.failover_cluster.ag_health_check_timeout",
	},
	SqlserverFailoverClusterAgReplicaRole: metricInfo{
		Name: "sqlserver.failover_cluster.ag_replica_role",
	},
	SqlserverFailoverClusterAgSynchronizationHealth: metricInfo{
		Name: "sqlserver.failover_cluster.ag_synchronization_health",
	},
	SqlserverFailoverClusterFlowControlTimeMs: metricInfo{
		Name: "sqlserver.failover_cluster.flow_control_time_ms",
	},
	SqlserverFailoverClusterLogBytesReceivedPerSec: metricInfo{
		Name: "sqlserver.failover_cluster.log_bytes_received_per_sec",
	},
	SqlserverFailoverClusterLogSendQueueKb: metricInfo{
		Name: "sqlserver.failover_cluster.log_send_queue_kb",
	},
	SqlserverFailoverClusterRedoQueueKb: metricInfo{
		Name: "sqlserver.failover_cluster.redo_queue_kb",
	},
	SqlserverFailoverClusterRedoRateKbSec: metricInfo{
		Name: "sqlserver.failover_cluster.redo_rate_kb_sec",
	},
	SqlserverFailoverClusterTransactionDelayMs: metricInfo{
		Name: "sqlserver.failover_cluster.transaction_delay_ms",
	},
	SqlserverIndividualQueryTotalCPUMs: metricInfo{
		Name: "sqlserver.individual_query.total_cpu_ms",
	},
	SqlserverIndividualQueryTotalElapsedMs: metricInfo{
		Name: "sqlserver.individual_query.total_elapsed_ms",
	},
	SqlserverInstanceBufferPoolSize: metricInfo{
		Name: "sqlserver.instance.buffer_pool_size",
	},
	SqlserverInstanceCompilationsPerBatch: metricInfo{
		Name: "sqlserver.instance.compilations_per_batch",
	},
	SqlserverInstanceForcedParameterizationsPerSec: metricInfo{
		Name: "sqlserver.instance.forced_parameterizations_per_sec",
	},
	SqlserverInstanceFullScansRate: metricInfo{
		Name: "sqlserver.instance.full_scans_rate",
	},
	SqlserverInstanceLockTimeoutsRate: metricInfo{
		Name: "sqlserver.instance.lock_timeouts_rate",
	},
	SqlserverInstanceMemoryAvailable: metricInfo{
		Name: "sqlserver.instance.memoryAvailable",
	},
	SqlserverInstanceMemoryTotal: metricInfo{
		Name: "sqlserver.instance.memoryTotal",
	},
	SqlserverInstanceMemoryUtilization: metricInfo{
		Name: "sqlserver.instance.memoryUtilization",
	},
	SqlserverInstancePageSplitsPerBatch: metricInfo{
		Name: "sqlserver.instance.page_splits_per_batch",
	},
	SqlserverInstanceTargetMemoryKb: metricInfo{
		Name: "sqlserver.instance.target_memory_kb",
	},
	SqlserverInstanceTransactionsPerSec: metricInfo{
		Name: "sqlserver.instance.transactions_per_sec",
	},
	SqlserverLockModeBulkUpdate: metricInfo{
		Name: "sqlserver.lock.mode.bulk_update",
	},
	SqlserverLockModeExclusive: metricInfo{
		Name: "sqlserver.lock.mode.exclusive",
	},
	SqlserverLockModeIntent: metricInfo{
		Name: "sqlserver.lock.mode.intent",
	},
	SqlserverLockModeSchema: metricInfo{
		Name: "sqlserver.lock.mode.schema",
	},
	SqlserverLockModeShared: metricInfo{
		Name: "sqlserver.lock.mode.shared",
	},
	SqlserverLockModeSharedIntentExclusive: metricInfo{
		Name: "sqlserver.lock.mode.shared_intent_exclusive",
	},
	SqlserverLockModeTotal: metricInfo{
		Name: "sqlserver.lock.mode.total",
	},
	SqlserverLockModeUpdate: metricInfo{
		Name: "sqlserver.lock.mode.update",
	},
	SqlserverLockResourceAllocationUnit: metricInfo{
		Name: "sqlserver.lock.resource.allocation_unit",
	},
	SqlserverLockResourceApplication: metricInfo{
		Name: "sqlserver.lock.resource.application",
	},
	SqlserverLockResourceDatabaseLevel: metricInfo{
		Name: "sqlserver.lock.resource.database_level",
	},
	SqlserverLockResourceExtent: metricInfo{
		Name: "sqlserver.lock.resource.extent",
	},
	SqlserverLockResourceFile: metricInfo{
		Name: "sqlserver.lock.resource.file",
	},
	SqlserverLockResourceHobt: metricInfo{
		Name: "sqlserver.lock.resource.hobt",
	},
	SqlserverLockResourceKey: metricInfo{
		Name: "sqlserver.lock.resource.key",
	},
	SqlserverLockResourceMetadata: metricInfo{
		Name: "sqlserver.lock.resource.metadata",
	},
	SqlserverLockResourcePage: metricInfo{
		Name: "sqlserver.lock.resource.page",
	},
	SqlserverLockResourceRow: metricInfo{
		Name: "sqlserver.lock.resource.row",
	},
	SqlserverLockResourceTable: metricInfo{
		Name: "sqlserver.lock.resource.table",
	},
	SqlserverLockResourceTotal: metricInfo{
		Name: "sqlserver.lock.resource.total",
	},
	SqlserverLockedObject: metricInfo{
		Name: "sqlserver.locked_object",
	},
	SqlserverMemoryTarget: metricInfo{
		Name: "sqlserver.memory.target",
	},
	SqlserverMemoryTotal: metricInfo{
		Name: "sqlserver.memory.total",
	},
	SqlserverPlanAvgElapsedTimeMs: metricInfo{
		Name: "sqlserver.plan.avg_elapsed_time_ms",
	},
	SqlserverPlanAvgLogicalReads: metricInfo{
		Name: "sqlserver.plan.avg_logical_reads",
	},
	SqlserverPlanAvgLogicalWrites: metricInfo{
		Name: "sqlserver.plan.avg_logical_writes",
	},
	SqlserverPlanAvgWorkerTimeMs: metricInfo{
		Name: "sqlserver.plan.avg_worker_time_ms",
	},
	SqlserverPlanExecutionCount: metricInfo{
		Name: "sqlserver.plan.execution_count",
	},
	SqlserverPlanLastDop: metricInfo{
		Name: "sqlserver.plan.last_dop",
	},
	SqlserverPlanLastGrantKb: metricInfo{
		Name: "sqlserver.plan.last_grant_kb",
	},
	SqlserverPlanLastSpills: metricInfo{
		Name: "sqlserver.plan.last_spills",
	},
	SqlserverPlanMaxElapsedTimeMs: metricInfo{
		Name: "sqlserver.plan.max_elapsed_time_ms",
	},
	SqlserverPlanMinElapsedTimeMs: metricInfo{
		Name: "sqlserver.plan.min_elapsed_time_ms",
	},
	SqlserverPlanTotalElapsedTimeMs: metricInfo{
		Name: "sqlserver.plan.total_elapsed_time_ms",
	},
	SqlserverSecurityServerPrincipalsCount: metricInfo{
		Name: "sqlserver.security.server_principals_count",
	},
	SqlserverSecurityServerRoleMembersCount: metricInfo{
		Name: "sqlserver.security.server_role_members_count",
	},
	SqlserverSlowqueryAvgDiskReads: metricInfo{
		Name: "sqlserver.slowquery.avg_disk_reads",
	},
	SqlserverSlowqueryAvgDiskWrites: metricInfo{
		Name: "sqlserver.slowquery.avg_disk_writes",
	},
	SqlserverSlowqueryAvgRowsProcessed: metricInfo{
		Name: "sqlserver.slowquery.avg_rows_processed",
	},
	SqlserverSlowqueryHistoricalAvgCPUTimeMs: metricInfo{
		Name: "sqlserver.slowquery.historical_avg_cpu_time_ms",
	},
	SqlserverSlowqueryHistoricalAvgElapsedTimeMs: metricInfo{
		Name: "sqlserver.slowquery.historical_avg_elapsed_time_ms",
	},
	SqlserverSlowqueryHistoricalExecutionCount: metricInfo{
		Name: "sqlserver.slowquery.historical_execution_count",
	},
	SqlserverSlowqueryIntervalAvgElapsedTimeMs: metricInfo{
		Name: "sqlserver.slowquery.interval_avg_elapsed_time_ms",
	},
	SqlserverSlowqueryIntervalExecutionCount: metricInfo{
		Name: "sqlserver.slowquery.interval_execution_count",
	},
	SqlserverSlowqueryLastDop: metricInfo{
		Name: "sqlserver.slowquery.last_dop",
	},
	SqlserverSlowqueryLastElapsedTimeMs: metricInfo{
		Name: "sqlserver.slowquery.last_elapsed_time_ms",
	},
	SqlserverSlowqueryLastGrantKb: metricInfo{
		Name: "sqlserver.slowquery.last_grant_kb",
	},
	SqlserverSlowqueryLastSpills: metricInfo{
		Name: "sqlserver.slowquery.last_spills",
	},
	SqlserverSlowqueryLastUsedGrantKb: metricInfo{
		Name: "sqlserver.slowquery.last_used_grant_kb",
	},
	SqlserverSlowqueryMaxElapsedTimeMs: metricInfo{
		Name: "sqlserver.slowquery.max_elapsed_time_ms",
	},
	SqlserverSlowqueryMaxSpills: metricInfo{
		Name: "sqlserver.slowquery.max_spills",
	},
	SqlserverSlowqueryMinElapsedTimeMs: metricInfo{
		Name: "sqlserver.slowquery.min_elapsed_time_ms",
	},
	SqlserverSlowqueryQueryText: metricInfo{
		Name: "sqlserver.slowquery.query_text",
	},
	SqlserverStatsConnections: metricInfo{
		Name: "sqlserver.stats.connections",
	},
	SqlserverStatsDeadlocksPerSec: metricInfo{
		Name: "sqlserver.stats.deadlocks_per_sec",
	},
	SqlserverStatsKillConnectionErrorsPerSec: metricInfo{
		Name: "sqlserver.stats.kill_connection_errors_per_sec",
	},
	SqlserverStatsLockWaitsPerSec: metricInfo{
		Name: "sqlserver.stats.lock_waits_per_sec",
	},
	SqlserverStatsSQLCompilationsPerSec: metricInfo{
		Name: "sqlserver.stats.sql_compilations_per_sec",
	},
	SqlserverStatsSQLRecompilationsPerSec: metricInfo{
		Name: "sqlserver.stats.sql_recompilations_per_sec",
	},
	SqlserverStatsUserErrorsPerSec: metricInfo{
		Name: "sqlserver.stats.user_errors_per_sec",
	},
	SqlserverTempdbAllocationWaitsMs: metricInfo{
		Name: "sqlserver.tempdb.allocation_waits_ms",
	},
	SqlserverTempdbCurrentWaiters: metricInfo{
		Name: "sqlserver.tempdb.current_waiters",
	},
	SqlserverTempdbDataFileCount: metricInfo{
		Name: "sqlserver.tempdb.data_file_count",
	},
	SqlserverTempdbPagelatchWaitsMs: metricInfo{
		Name: "sqlserver.tempdb.pagelatch_waits_ms",
	},
	SqlserverTempdbTotalSizeMb: metricInfo{
		Name: "sqlserver.tempdb.total_size_mb",
	},
	SqlserverThreadpoolCurrentTasks: metricInfo{
		Name: "sqlserver.threadpool.current_tasks",
	},
	SqlserverThreadpoolMaxWorkers: metricInfo{
		Name: "sqlserver.threadpool.max_workers",
	},
	SqlserverThreadpoolRunnableTasks: metricInfo{
		Name: "sqlserver.threadpool.runnable_tasks",
	},
	SqlserverThreadpoolRunningWorkers: metricInfo{
		Name: "sqlserver.threadpool.running_workers",
	},
	SqlserverThreadpoolUtilizationPercent: metricInfo{
		Name: "sqlserver.threadpool.utilization_percent",
	},
	SqlserverThreadpoolWaitingTasks: metricInfo{
		Name: "sqlserver.threadpool.waiting_tasks",
	},
	SqlserverThreadpoolWorkQueueCount: metricInfo{
		Name: "sqlserver.threadpool.work_queue_count",
	},
	SqlserverUserConnectionsAuthenticationChurnRate: metricInfo{
		Name: "sqlserver.user_connections.authentication.churn_rate",
	},
	SqlserverUserConnectionsAuthenticationFailedLoginEvents: metricInfo{
		Name: "sqlserver.user_connections.authentication.failed_login_events",
	},
	SqlserverUserConnectionsAuthenticationLoginsPerSec: metricInfo{
		Name: "sqlserver.user_connections.authentication.logins_per_sec",
	},
	SqlserverUserConnectionsAuthenticationLogoutsPerSec: metricInfo{
		Name: "sqlserver.user_connections.authentication.logouts_per_sec",
	},
	SqlserverUserConnectionsAuthenticationRate: metricInfo{
		Name: "sqlserver.user_connections.authentication.rate",
	},
	SqlserverUserConnectionsAuthenticationRecentFailedLogins: metricInfo{
		Name: "sqlserver.user_connections.authentication.recent_failed_logins",
	},
	SqlserverUserConnectionsAuthenticationTotalActivity: metricInfo{
		Name: "sqlserver.user_connections.authentication.total_activity",
	},
	SqlserverUserConnectionsAuthenticationTotalFailedLogins: metricInfo{
		Name: "sqlserver.user_connections.authentication.total_failed_logins",
	},
	SqlserverUserConnectionsAuthenticationUniqueFailedSources: metricInfo{
		Name: "sqlserver.user_connections.authentication.unique_failed_sources",
	},
	SqlserverUserConnectionsAuthenticationUniqueFailedUsers: metricInfo{
		Name: "sqlserver.user_connections.authentication.unique_failed_users",
	},
	SqlserverUserConnectionsClientCount: metricInfo{
		Name: "sqlserver.user_connections.client.count",
	},
	SqlserverUserConnectionsClientHostsMultiProgram: metricInfo{
		Name: "sqlserver.user_connections.client.hosts_multi_program",
	},
	SqlserverUserConnectionsClientProgramsMultiHost: metricInfo{
		Name: "sqlserver.user_connections.client.programs_multi_host",
	},
	SqlserverUserConnectionsClientTopHostConnections: metricInfo{
		Name: "sqlserver.user_connections.client.top_host_connections",
	},
	SqlserverUserConnectionsClientTopProgramConnections: metricInfo{
		Name: "sqlserver.user_connections.client.top_program_connections",
	},
	SqlserverUserConnectionsClientUniqueHosts: metricInfo{
		Name: "sqlserver.user_connections.client.unique_hosts",
	},
	SqlserverUserConnectionsClientUniquePrograms: metricInfo{
		Name: "sqlserver.user_connections.client.unique_programs",
	},
	SqlserverUserConnectionsDormant: metricInfo{
		Name: "sqlserver.user_connections.dormant",
	},
	SqlserverUserConnectionsRunnable: metricInfo{
		Name: "sqlserver.user_connections.runnable",
	},
	SqlserverUserConnectionsRunning: metricInfo{
		Name: "sqlserver.user_connections.running",
	},
	SqlserverUserConnectionsSleeping: metricInfo{
		Name: "sqlserver.user_connections.sleeping",
	},
	SqlserverUserConnectionsStatusCount: metricInfo{
		Name: "sqlserver.user_connections.status.count",
	},
	SqlserverUserConnectionsSuspended: metricInfo{
		Name: "sqlserver.user_connections.suspended",
	},
	SqlserverUserConnectionsTotal: metricInfo{
		Name: "sqlserver.user_connections.total",
	},
	SqlserverUserConnectionsUtilizationActiveRatio: metricInfo{
		Name: "sqlserver.user_connections.utilization.active_ratio",
	},
	SqlserverUserConnectionsUtilizationEfficiency: metricInfo{
		Name: "sqlserver.user_connections.utilization.efficiency",
	},
	SqlserverUserConnectionsUtilizationIdleRatio: metricInfo{
		Name: "sqlserver.user_connections.utilization.idle_ratio",
	},
	SqlserverUserConnectionsUtilizationWaitingRatio: metricInfo{
		Name: "sqlserver.user_connections.utilization.waiting_ratio",
	},
	SqlserverWaitStatsLatchWaitTimeMs: metricInfo{
		Name: "sqlserver.wait_stats.latch.wait_time_ms",
	},
	SqlserverWaitStatsLatchWaitingTasksCount: metricInfo{
		Name: "sqlserver.wait_stats.latch.waiting_tasks_count",
	},
	SqlserverWaitStatsWaitTimeMs: metricInfo{
		Name: "sqlserver.wait_stats.wait_time_ms",
	},
	SqlserverWaitStatsWaitingTasksCount: metricInfo{
		Name: "sqlserver.wait_stats.waiting_tasks_count",
	},
}

type metricsInfo struct {
	ActiveConnections                                         metricInfo
	InstanceBackgroundProcessesCount                          metricInfo
	InstanceBlockedProcessesCount                             metricInfo
	InstanceDiskInBytes                                       metricInfo
	InstanceDormantProcessesCount                             metricInfo
	InstancePreconnectProcessesCount                          metricInfo
	InstanceRunnableProcessesCount                            metricInfo
	InstanceRunnableTasks                                     metricInfo
	InstanceRunningProcessesCount                             metricInfo
	InstanceSleepingProcessesCount                            metricInfo
	InstanceSuspendedProcessesCount                           metricInfo
	SqlserverAccessPageSplitsPerSec                           metricInfo
	SqlserverActivequeryCPUTimeMs                             metricInfo
	SqlserverActivequeryElapsedTimeMs                         metricInfo
	SqlserverActivequeryGrantedQueryMemoryPages               metricInfo
	SqlserverActivequeryLogicalReads                          metricInfo
	SqlserverActivequeryReads                                 metricInfo
	SqlserverActivequeryRowCount                              metricInfo
	SqlserverActivequeryWaitTimeSeconds                       metricInfo
	SqlserverActivequeryWrites                                metricInfo
	SqlserverBufferCacheHitRatio                              metricInfo
	SqlserverBufferCheckpointPagesPerSec                      metricInfo
	SqlserverBufferPageLifeExpectancy                         metricInfo
	SqlserverBufferPoolHitPercent                             metricInfo
	SqlserverBufferpoolBatchRequestsPerSec                    metricInfo
	SqlserverBufferpoolPageLifeExpectancyMs                   metricInfo
	SqlserverConnectionsUser                                  metricInfo
	SqlserverDatabaseBufferpoolSizePerDatabaseInBytes         metricInfo
	SqlserverDatabaseIoStallInMilliseconds                    metricInfo
	SqlserverDatabaseLogBytesFlushesPerSec                    metricInfo
	SqlserverDatabaseLogFlushWaitsPerSec                      metricInfo
	SqlserverDatabaseLogFlushesPerSec                         metricInfo
	SqlserverDatabaseLogTransactionGrowth                     metricInfo
	SqlserverDatabaseLogUsedSpaceMB                           metricInfo
	SqlserverDatabaseMaxDiskSizeInBytes                       metricInfo
	SqlserverDatabasePageFileAvailable                        metricInfo
	SqlserverDatabasePageFileTotal                            metricInfo
	SqlserverDatabasePrincipalCreateDate                      metricInfo
	SqlserverDatabasePrincipalsApplicationRoles               metricInfo
	SqlserverDatabasePrincipalsOld                            metricInfo
	SqlserverDatabasePrincipalsOrphanedUsers                  metricInfo
	SqlserverDatabasePrincipalsRecentlyCreated                metricInfo
	SqlserverDatabasePrincipalsRoles                          metricInfo
	SqlserverDatabasePrincipalsSQLUsers                       metricInfo
	SqlserverDatabasePrincipalsTotal                          metricInfo
	SqlserverDatabasePrincipalsUsers                          metricInfo
	SqlserverDatabasePrincipalsWindowsUsers                   metricInfo
	SqlserverDatabaseRoleMembersApplicationRoles              metricInfo
	SqlserverDatabaseRoleMembersCrossRole                     metricInfo
	SqlserverDatabaseRoleMembersHighPrivilege                 metricInfo
	SqlserverDatabaseRoleMembersUnique                        metricInfo
	SqlserverDatabaseRoleMembershipActive                     metricInfo
	SqlserverDatabaseRoleMembershipsActive                    metricInfo
	SqlserverDatabaseRoleMembershipsCustom                    metricInfo
	SqlserverDatabaseRoleMembershipsNested                    metricInfo
	SqlserverDatabaseRoleMembershipsTotal                     metricInfo
	SqlserverDatabaseRoleMembershipsUsers                     metricInfo
	SqlserverDatabaseRoleNestingLevel                         metricInfo
	SqlserverDatabaseRolePermissionMemberCount                metricInfo
	SqlserverDatabaseRolePermissionRiskLevel                  metricInfo
	SqlserverDatabaseRolePermissionsInherited                 metricInfo
	SqlserverDatabaseRoleRolesEmpty                           metricInfo
	SqlserverDatabaseRoleRolesWithMembers                     metricInfo
	SqlserverDatabaseSizeDataSizeMB                           metricInfo
	SqlserverDatabaseSizeTotalSizeMB                          metricInfo
	SqlserverDatabaseTransactionsActive                       metricInfo
	SqlserverFailoverClusterAgClusterType                     metricInfo
	SqlserverFailoverClusterAgFailureConditionLevel           metricInfo
	SqlserverFailoverClusterAgHealthCheckTimeout              metricInfo
	SqlserverFailoverClusterAgReplicaRole                     metricInfo
	SqlserverFailoverClusterAgSynchronizationHealth           metricInfo
	SqlserverFailoverClusterFlowControlTimeMs                 metricInfo
	SqlserverFailoverClusterLogBytesReceivedPerSec            metricInfo
	SqlserverFailoverClusterLogSendQueueKb                    metricInfo
	SqlserverFailoverClusterRedoQueueKb                       metricInfo
	SqlserverFailoverClusterRedoRateKbSec                     metricInfo
	SqlserverFailoverClusterTransactionDelayMs                metricInfo
	SqlserverIndividualQueryTotalCPUMs                        metricInfo
	SqlserverIndividualQueryTotalElapsedMs                    metricInfo
	SqlserverInstanceBufferPoolSize                           metricInfo
	SqlserverInstanceCompilationsPerBatch                     metricInfo
	SqlserverInstanceForcedParameterizationsPerSec            metricInfo
	SqlserverInstanceFullScansRate                            metricInfo
	SqlserverInstanceLockTimeoutsRate                         metricInfo
	SqlserverInstanceMemoryAvailable                          metricInfo
	SqlserverInstanceMemoryTotal                              metricInfo
	SqlserverInstanceMemoryUtilization                        metricInfo
	SqlserverInstancePageSplitsPerBatch                       metricInfo
	SqlserverInstanceTargetMemoryKb                           metricInfo
	SqlserverInstanceTransactionsPerSec                       metricInfo
	SqlserverLockModeBulkUpdate                               metricInfo
	SqlserverLockModeExclusive                                metricInfo
	SqlserverLockModeIntent                                   metricInfo
	SqlserverLockModeSchema                                   metricInfo
	SqlserverLockModeShared                                   metricInfo
	SqlserverLockModeSharedIntentExclusive                    metricInfo
	SqlserverLockModeTotal                                    metricInfo
	SqlserverLockModeUpdate                                   metricInfo
	SqlserverLockResourceAllocationUnit                       metricInfo
	SqlserverLockResourceApplication                          metricInfo
	SqlserverLockResourceDatabaseLevel                        metricInfo
	SqlserverLockResourceExtent                               metricInfo
	SqlserverLockResourceFile                                 metricInfo
	SqlserverLockResourceHobt                                 metricInfo
	SqlserverLockResourceKey                                  metricInfo
	SqlserverLockResourceMetadata                             metricInfo
	SqlserverLockResourcePage                                 metricInfo
	SqlserverLockResourceRow                                  metricInfo
	SqlserverLockResourceTable                                metricInfo
	SqlserverLockResourceTotal                                metricInfo
	SqlserverLockedObject                                     metricInfo
	SqlserverMemoryTarget                                     metricInfo
	SqlserverMemoryTotal                                      metricInfo
	SqlserverPlanAvgElapsedTimeMs                             metricInfo
	SqlserverPlanAvgLogicalReads                              metricInfo
	SqlserverPlanAvgLogicalWrites                             metricInfo
	SqlserverPlanAvgWorkerTimeMs                              metricInfo
	SqlserverPlanExecutionCount                               metricInfo
	SqlserverPlanLastDop                                      metricInfo
	SqlserverPlanLastGrantKb                                  metricInfo
	SqlserverPlanLastSpills                                   metricInfo
	SqlserverPlanMaxElapsedTimeMs                             metricInfo
	SqlserverPlanMinElapsedTimeMs                             metricInfo
	SqlserverPlanTotalElapsedTimeMs                           metricInfo
	SqlserverSecurityServerPrincipalsCount                    metricInfo
	SqlserverSecurityServerRoleMembersCount                   metricInfo
	SqlserverSlowqueryAvgDiskReads                            metricInfo
	SqlserverSlowqueryAvgDiskWrites                           metricInfo
	SqlserverSlowqueryAvgRowsProcessed                        metricInfo
	SqlserverSlowqueryHistoricalAvgCPUTimeMs                  metricInfo
	SqlserverSlowqueryHistoricalAvgElapsedTimeMs              metricInfo
	SqlserverSlowqueryHistoricalExecutionCount                metricInfo
	SqlserverSlowqueryIntervalAvgElapsedTimeMs                metricInfo
	SqlserverSlowqueryIntervalExecutionCount                  metricInfo
	SqlserverSlowqueryLastDop                                 metricInfo
	SqlserverSlowqueryLastElapsedTimeMs                       metricInfo
	SqlserverSlowqueryLastGrantKb                             metricInfo
	SqlserverSlowqueryLastSpills                              metricInfo
	SqlserverSlowqueryLastUsedGrantKb                         metricInfo
	SqlserverSlowqueryMaxElapsedTimeMs                        metricInfo
	SqlserverSlowqueryMaxSpills                               metricInfo
	SqlserverSlowqueryMinElapsedTimeMs                        metricInfo
	SqlserverSlowqueryQueryText                               metricInfo
	SqlserverStatsConnections                                 metricInfo
	SqlserverStatsDeadlocksPerSec                             metricInfo
	SqlserverStatsKillConnectionErrorsPerSec                  metricInfo
	SqlserverStatsLockWaitsPerSec                             metricInfo
	SqlserverStatsSQLCompilationsPerSec                       metricInfo
	SqlserverStatsSQLRecompilationsPerSec                     metricInfo
	SqlserverStatsUserErrorsPerSec                            metricInfo
	SqlserverTempdbAllocationWaitsMs                          metricInfo
	SqlserverTempdbCurrentWaiters                             metricInfo
	SqlserverTempdbDataFileCount                              metricInfo
	SqlserverTempdbPagelatchWaitsMs                           metricInfo
	SqlserverTempdbTotalSizeMb                                metricInfo
	SqlserverThreadpoolCurrentTasks                           metricInfo
	SqlserverThreadpoolMaxWorkers                             metricInfo
	SqlserverThreadpoolRunnableTasks                          metricInfo
	SqlserverThreadpoolRunningWorkers                         metricInfo
	SqlserverThreadpoolUtilizationPercent                     metricInfo
	SqlserverThreadpoolWaitingTasks                           metricInfo
	SqlserverThreadpoolWorkQueueCount                         metricInfo
	SqlserverUserConnectionsAuthenticationChurnRate           metricInfo
	SqlserverUserConnectionsAuthenticationFailedLoginEvents   metricInfo
	SqlserverUserConnectionsAuthenticationLoginsPerSec        metricInfo
	SqlserverUserConnectionsAuthenticationLogoutsPerSec       metricInfo
	SqlserverUserConnectionsAuthenticationRate                metricInfo
	SqlserverUserConnectionsAuthenticationRecentFailedLogins  metricInfo
	SqlserverUserConnectionsAuthenticationTotalActivity       metricInfo
	SqlserverUserConnectionsAuthenticationTotalFailedLogins   metricInfo
	SqlserverUserConnectionsAuthenticationUniqueFailedSources metricInfo
	SqlserverUserConnectionsAuthenticationUniqueFailedUsers   metricInfo
	SqlserverUserConnectionsClientCount                       metricInfo
	SqlserverUserConnectionsClientHostsMultiProgram           metricInfo
	SqlserverUserConnectionsClientProgramsMultiHost           metricInfo
	SqlserverUserConnectionsClientTopHostConnections          metricInfo
	SqlserverUserConnectionsClientTopProgramConnections       metricInfo
	SqlserverUserConnectionsClientUniqueHosts                 metricInfo
	SqlserverUserConnectionsClientUniquePrograms              metricInfo
	SqlserverUserConnectionsDormant                           metricInfo
	SqlserverUserConnectionsRunnable                          metricInfo
	SqlserverUserConnectionsRunning                           metricInfo
	SqlserverUserConnectionsSleeping                          metricInfo
	SqlserverUserConnectionsStatusCount                       metricInfo
	SqlserverUserConnectionsSuspended                         metricInfo
	SqlserverUserConnectionsTotal                             metricInfo
	SqlserverUserConnectionsUtilizationActiveRatio            metricInfo
	SqlserverUserConnectionsUtilizationEfficiency             metricInfo
	SqlserverUserConnectionsUtilizationIdleRatio              metricInfo
	SqlserverUserConnectionsUtilizationWaitingRatio           metricInfo
	SqlserverWaitStatsLatchWaitTimeMs                         metricInfo
	SqlserverWaitStatsLatchWaitingTasksCount                  metricInfo
	SqlserverWaitStatsWaitTimeMs                              metricInfo
	SqlserverWaitStatsWaitingTasksCount                       metricInfo
}

type metricInfo struct {
	Name string
}

type metricActiveConnections struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills activeConnections metric with initial data.
func (m *metricActiveConnections) init() {
	m.data.SetName("activeConnections")
	m.data.SetDescription("Number of active connections")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricActiveConnections) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActiveConnections) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActiveConnections) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActiveConnections(cfg MetricConfig) metricActiveConnections {
	m := metricActiveConnections{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricInstanceBackgroundProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills instance.backgroundProcessesCount metric with initial data.
func (m *metricInstanceBackgroundProcessesCount) init() {
	m.data.SetName("instance.backgroundProcessesCount")
	m.data.SetDescription("Number of background processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricInstanceBackgroundProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricInstanceBackgroundProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricInstanceBackgroundProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricInstanceBackgroundProcessesCount(cfg MetricConfig) metricInstanceBackgroundProcessesCount {
	m := metricInstanceBackgroundProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricInstanceBlockedProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills instance.blockedProcessesCount metric with initial data.
func (m *metricInstanceBlockedProcessesCount) init() {
	m.data.SetName("instance.blockedProcessesCount")
	m.data.SetDescription("Number of blocked processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricInstanceBlockedProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricInstanceBlockedProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricInstanceBlockedProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricInstanceBlockedProcessesCount(cfg MetricConfig) metricInstanceBlockedProcessesCount {
	m := metricInstanceBlockedProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricInstanceDiskInBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills instance.diskInBytes metric with initial data.
func (m *metricInstanceDiskInBytes) init() {
	m.data.SetName("instance.diskInBytes")
	m.data.SetDescription("Total disk space in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricInstanceDiskInBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricInstanceDiskInBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricInstanceDiskInBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricInstanceDiskInBytes(cfg MetricConfig) metricInstanceDiskInBytes {
	m := metricInstanceDiskInBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricInstanceDormantProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills instance.dormantProcessesCount metric with initial data.
func (m *metricInstanceDormantProcessesCount) init() {
	m.data.SetName("instance.dormantProcessesCount")
	m.data.SetDescription("Number of dormant processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricInstanceDormantProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricInstanceDormantProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricInstanceDormantProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricInstanceDormantProcessesCount(cfg MetricConfig) metricInstanceDormantProcessesCount {
	m := metricInstanceDormantProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricInstancePreconnectProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills instance.preconnectProcessesCount metric with initial data.
func (m *metricInstancePreconnectProcessesCount) init() {
	m.data.SetName("instance.preconnectProcessesCount")
	m.data.SetDescription("Number of preconnect processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricInstancePreconnectProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricInstancePreconnectProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricInstancePreconnectProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricInstancePreconnectProcessesCount(cfg MetricConfig) metricInstancePreconnectProcessesCount {
	m := metricInstancePreconnectProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricInstanceRunnableProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills instance.runnableProcessesCount metric with initial data.
func (m *metricInstanceRunnableProcessesCount) init() {
	m.data.SetName("instance.runnableProcessesCount")
	m.data.SetDescription("Number of runnable processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricInstanceRunnableProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricInstanceRunnableProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricInstanceRunnableProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricInstanceRunnableProcessesCount(cfg MetricConfig) metricInstanceRunnableProcessesCount {
	m := metricInstanceRunnableProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricInstanceRunnableTasks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills instance.runnableTasks metric with initial data.
func (m *metricInstanceRunnableTasks) init() {
	m.data.SetName("instance.runnableTasks")
	m.data.SetDescription("Number of runnable tasks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricInstanceRunnableTasks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricInstanceRunnableTasks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricInstanceRunnableTasks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricInstanceRunnableTasks(cfg MetricConfig) metricInstanceRunnableTasks {
	m := metricInstanceRunnableTasks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricInstanceRunningProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills instance.runningProcessesCount metric with initial data.
func (m *metricInstanceRunningProcessesCount) init() {
	m.data.SetName("instance.runningProcessesCount")
	m.data.SetDescription("Number of running processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricInstanceRunningProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricInstanceRunningProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricInstanceRunningProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricInstanceRunningProcessesCount(cfg MetricConfig) metricInstanceRunningProcessesCount {
	m := metricInstanceRunningProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricInstanceSleepingProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills instance.sleepingProcessesCount metric with initial data.
func (m *metricInstanceSleepingProcessesCount) init() {
	m.data.SetName("instance.sleepingProcessesCount")
	m.data.SetDescription("Number of sleeping processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricInstanceSleepingProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricInstanceSleepingProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricInstanceSleepingProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricInstanceSleepingProcessesCount(cfg MetricConfig) metricInstanceSleepingProcessesCount {
	m := metricInstanceSleepingProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricInstanceSuspendedProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills instance.suspendedProcessesCount metric with initial data.
func (m *metricInstanceSuspendedProcessesCount) init() {
	m.data.SetName("instance.suspendedProcessesCount")
	m.data.SetDescription("Number of suspended processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricInstanceSuspendedProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricInstanceSuspendedProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricInstanceSuspendedProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricInstanceSuspendedProcessesCount(cfg MetricConfig) metricInstanceSuspendedProcessesCount {
	m := metricInstanceSuspendedProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverAccessPageSplitsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.access.page_splits_per_sec metric with initial data.
func (m *metricSqlserverAccessPageSplitsPerSec) init() {
	m.data.SetName("sqlserver.access.page_splits_per_sec")
	m.data.SetDescription("Page splits per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverAccessPageSplitsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverAccessPageSplitsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverAccessPageSplitsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverAccessPageSplitsPerSec(cfg MetricConfig) metricSqlserverAccessPageSplitsPerSec {
	m := metricSqlserverAccessPageSplitsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryCPUTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.cpu_time_ms metric with initial data.
func (m *metricSqlserverActivequeryCPUTimeMs) init() {
	m.data.SetName("sqlserver.activequery.cpu_time_ms")
	m.data.SetDescription("CPU time for currently executing query")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverActivequeryCPUTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("login_name", loginNameAttributeValue)
	dp.Attributes().PutStr("host_name", hostNameAttributeValue)
	dp.Attributes().PutStr("program_name", programNameAttributeValue)
	dp.Attributes().PutStr("request_command", requestCommandAttributeValue)
	dp.Attributes().PutStr("request_status", requestStatusAttributeValue)
	dp.Attributes().PutStr("session_status", sessionStatusAttributeValue)
	dp.Attributes().PutStr("client_interface_name", clientInterfaceNameAttributeValue)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
	dp.Attributes().PutStr("wait_type_description", waitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_type_category", waitTypeCategoryAttributeValue)
	dp.Attributes().PutStr("wait_resource", waitResourceAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_name", waitResourceObjectNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_database_name", waitResourceDatabaseNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_type", waitResourceTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_description", waitResourceDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_resource_schema_name", waitResourceSchemaNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_table_name", waitResourceTableNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_type", waitResourceObjectTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_name", waitResourceIndexNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_type", waitResourceIndexTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type", lastWaitTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type_description", lastWaitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
	dp.Attributes().PutInt("transaction_id", transactionIDAttributeValue)
	dp.Attributes().PutInt("open_transaction_count", openTransactionCountAttributeValue)
	dp.Attributes().PutInt("transaction_isolation_level", transactionIsolationLevelAttributeValue)
	dp.Attributes().PutInt("degree_of_parallelism", degreeOfParallelismAttributeValue)
	dp.Attributes().PutInt("parallel_worker_count", parallelWorkerCountAttributeValue)
	dp.Attributes().PutInt("blocking_session_id", blockingSessionIDAttributeValue)
	dp.Attributes().PutStr("blocking_login_name", blockingLoginNameAttributeValue)
	dp.Attributes().PutStr("blocking_host_name", blockingHostNameAttributeValue)
	dp.Attributes().PutStr("blocking_program_name", blockingProgramNameAttributeValue)
	dp.Attributes().PutStr("blocking_status", blockingStatusAttributeValue)
	dp.Attributes().PutInt("blocking_isolation_level", blockingIsolationLevelAttributeValue)
	dp.Attributes().PutInt("blocking_open_transaction_count", blockingOpenTransactionCountAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryCPUTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryCPUTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryCPUTimeMs(cfg MetricConfig) metricSqlserverActivequeryCPUTimeMs {
	m := metricSqlserverActivequeryCPUTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.elapsed_time_ms metric with initial data.
func (m *metricSqlserverActivequeryElapsedTimeMs) init() {
	m.data.SetName("sqlserver.activequery.elapsed_time_ms")
	m.data.SetDescription("Total elapsed time for currently executing query")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverActivequeryElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("login_name", loginNameAttributeValue)
	dp.Attributes().PutStr("host_name", hostNameAttributeValue)
	dp.Attributes().PutStr("program_name", programNameAttributeValue)
	dp.Attributes().PutStr("request_command", requestCommandAttributeValue)
	dp.Attributes().PutStr("request_status", requestStatusAttributeValue)
	dp.Attributes().PutStr("session_status", sessionStatusAttributeValue)
	dp.Attributes().PutStr("client_interface_name", clientInterfaceNameAttributeValue)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
	dp.Attributes().PutStr("wait_type_description", waitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_type_category", waitTypeCategoryAttributeValue)
	dp.Attributes().PutStr("wait_resource", waitResourceAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_name", waitResourceObjectNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_database_name", waitResourceDatabaseNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_type", waitResourceTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_description", waitResourceDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_resource_schema_name", waitResourceSchemaNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_table_name", waitResourceTableNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_type", waitResourceObjectTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_name", waitResourceIndexNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_type", waitResourceIndexTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type", lastWaitTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type_description", lastWaitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
	dp.Attributes().PutInt("transaction_id", transactionIDAttributeValue)
	dp.Attributes().PutInt("open_transaction_count", openTransactionCountAttributeValue)
	dp.Attributes().PutInt("transaction_isolation_level", transactionIsolationLevelAttributeValue)
	dp.Attributes().PutInt("degree_of_parallelism", degreeOfParallelismAttributeValue)
	dp.Attributes().PutInt("parallel_worker_count", parallelWorkerCountAttributeValue)
	dp.Attributes().PutInt("blocking_session_id", blockingSessionIDAttributeValue)
	dp.Attributes().PutStr("blocking_login_name", blockingLoginNameAttributeValue)
	dp.Attributes().PutStr("blocking_host_name", blockingHostNameAttributeValue)
	dp.Attributes().PutStr("blocking_program_name", blockingProgramNameAttributeValue)
	dp.Attributes().PutStr("blocking_status", blockingStatusAttributeValue)
	dp.Attributes().PutInt("blocking_isolation_level", blockingIsolationLevelAttributeValue)
	dp.Attributes().PutInt("blocking_open_transaction_count", blockingOpenTransactionCountAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryElapsedTimeMs(cfg MetricConfig) metricSqlserverActivequeryElapsedTimeMs {
	m := metricSqlserverActivequeryElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryGrantedQueryMemoryPages struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.granted_query_memory_pages metric with initial data.
func (m *metricSqlserverActivequeryGrantedQueryMemoryPages) init() {
	m.data.SetName("sqlserver.activequery.granted_query_memory_pages")
	m.data.SetDescription("Number of memory pages granted to currently executing query")
	m.data.SetUnit("{pages}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverActivequeryGrantedQueryMemoryPages) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("login_name", loginNameAttributeValue)
	dp.Attributes().PutStr("host_name", hostNameAttributeValue)
	dp.Attributes().PutStr("program_name", programNameAttributeValue)
	dp.Attributes().PutStr("request_command", requestCommandAttributeValue)
	dp.Attributes().PutStr("request_status", requestStatusAttributeValue)
	dp.Attributes().PutStr("session_status", sessionStatusAttributeValue)
	dp.Attributes().PutStr("client_interface_name", clientInterfaceNameAttributeValue)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
	dp.Attributes().PutStr("wait_type_description", waitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_type_category", waitTypeCategoryAttributeValue)
	dp.Attributes().PutStr("wait_resource", waitResourceAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_name", waitResourceObjectNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_database_name", waitResourceDatabaseNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_type", waitResourceTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_description", waitResourceDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_resource_schema_name", waitResourceSchemaNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_table_name", waitResourceTableNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_type", waitResourceObjectTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_name", waitResourceIndexNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_type", waitResourceIndexTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type", lastWaitTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type_description", lastWaitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
	dp.Attributes().PutInt("transaction_id", transactionIDAttributeValue)
	dp.Attributes().PutInt("open_transaction_count", openTransactionCountAttributeValue)
	dp.Attributes().PutInt("transaction_isolation_level", transactionIsolationLevelAttributeValue)
	dp.Attributes().PutInt("degree_of_parallelism", degreeOfParallelismAttributeValue)
	dp.Attributes().PutInt("parallel_worker_count", parallelWorkerCountAttributeValue)
	dp.Attributes().PutInt("blocking_session_id", blockingSessionIDAttributeValue)
	dp.Attributes().PutStr("blocking_login_name", blockingLoginNameAttributeValue)
	dp.Attributes().PutStr("blocking_host_name", blockingHostNameAttributeValue)
	dp.Attributes().PutStr("blocking_program_name", blockingProgramNameAttributeValue)
	dp.Attributes().PutStr("blocking_status", blockingStatusAttributeValue)
	dp.Attributes().PutInt("blocking_isolation_level", blockingIsolationLevelAttributeValue)
	dp.Attributes().PutInt("blocking_open_transaction_count", blockingOpenTransactionCountAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryGrantedQueryMemoryPages) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryGrantedQueryMemoryPages) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryGrantedQueryMemoryPages(cfg MetricConfig) metricSqlserverActivequeryGrantedQueryMemoryPages {
	m := metricSqlserverActivequeryGrantedQueryMemoryPages{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryLogicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.logical_reads metric with initial data.
func (m *metricSqlserverActivequeryLogicalReads) init() {
	m.data.SetName("sqlserver.activequery.logical_reads")
	m.data.SetDescription("Number of logical reads from buffer cache for currently executing query")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverActivequeryLogicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("login_name", loginNameAttributeValue)
	dp.Attributes().PutStr("host_name", hostNameAttributeValue)
	dp.Attributes().PutStr("program_name", programNameAttributeValue)
	dp.Attributes().PutStr("request_command", requestCommandAttributeValue)
	dp.Attributes().PutStr("request_status", requestStatusAttributeValue)
	dp.Attributes().PutStr("session_status", sessionStatusAttributeValue)
	dp.Attributes().PutStr("client_interface_name", clientInterfaceNameAttributeValue)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
	dp.Attributes().PutStr("wait_type_description", waitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_type_category", waitTypeCategoryAttributeValue)
	dp.Attributes().PutStr("wait_resource", waitResourceAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_name", waitResourceObjectNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_database_name", waitResourceDatabaseNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_type", waitResourceTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_description", waitResourceDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_resource_schema_name", waitResourceSchemaNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_table_name", waitResourceTableNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_type", waitResourceObjectTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_name", waitResourceIndexNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_type", waitResourceIndexTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type", lastWaitTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type_description", lastWaitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
	dp.Attributes().PutInt("transaction_id", transactionIDAttributeValue)
	dp.Attributes().PutInt("open_transaction_count", openTransactionCountAttributeValue)
	dp.Attributes().PutInt("transaction_isolation_level", transactionIsolationLevelAttributeValue)
	dp.Attributes().PutInt("degree_of_parallelism", degreeOfParallelismAttributeValue)
	dp.Attributes().PutInt("parallel_worker_count", parallelWorkerCountAttributeValue)
	dp.Attributes().PutInt("blocking_session_id", blockingSessionIDAttributeValue)
	dp.Attributes().PutStr("blocking_login_name", blockingLoginNameAttributeValue)
	dp.Attributes().PutStr("blocking_host_name", blockingHostNameAttributeValue)
	dp.Attributes().PutStr("blocking_program_name", blockingProgramNameAttributeValue)
	dp.Attributes().PutStr("blocking_status", blockingStatusAttributeValue)
	dp.Attributes().PutInt("blocking_isolation_level", blockingIsolationLevelAttributeValue)
	dp.Attributes().PutInt("blocking_open_transaction_count", blockingOpenTransactionCountAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryLogicalReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryLogicalReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryLogicalReads(cfg MetricConfig) metricSqlserverActivequeryLogicalReads {
	m := metricSqlserverActivequeryLogicalReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.reads metric with initial data.
func (m *metricSqlserverActivequeryReads) init() {
	m.data.SetName("sqlserver.activequery.reads")
	m.data.SetDescription("Number of physical reads from disk for currently executing query")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverActivequeryReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("login_name", loginNameAttributeValue)
	dp.Attributes().PutStr("host_name", hostNameAttributeValue)
	dp.Attributes().PutStr("program_name", programNameAttributeValue)
	dp.Attributes().PutStr("request_command", requestCommandAttributeValue)
	dp.Attributes().PutStr("request_status", requestStatusAttributeValue)
	dp.Attributes().PutStr("session_status", sessionStatusAttributeValue)
	dp.Attributes().PutStr("client_interface_name", clientInterfaceNameAttributeValue)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
	dp.Attributes().PutStr("wait_type_description", waitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_type_category", waitTypeCategoryAttributeValue)
	dp.Attributes().PutStr("wait_resource", waitResourceAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_name", waitResourceObjectNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_database_name", waitResourceDatabaseNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_type", waitResourceTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_description", waitResourceDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_resource_schema_name", waitResourceSchemaNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_table_name", waitResourceTableNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_type", waitResourceObjectTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_name", waitResourceIndexNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_type", waitResourceIndexTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type", lastWaitTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type_description", lastWaitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
	dp.Attributes().PutInt("transaction_id", transactionIDAttributeValue)
	dp.Attributes().PutInt("open_transaction_count", openTransactionCountAttributeValue)
	dp.Attributes().PutInt("transaction_isolation_level", transactionIsolationLevelAttributeValue)
	dp.Attributes().PutInt("degree_of_parallelism", degreeOfParallelismAttributeValue)
	dp.Attributes().PutInt("parallel_worker_count", parallelWorkerCountAttributeValue)
	dp.Attributes().PutInt("blocking_session_id", blockingSessionIDAttributeValue)
	dp.Attributes().PutStr("blocking_login_name", blockingLoginNameAttributeValue)
	dp.Attributes().PutStr("blocking_host_name", blockingHostNameAttributeValue)
	dp.Attributes().PutStr("blocking_program_name", blockingProgramNameAttributeValue)
	dp.Attributes().PutStr("blocking_status", blockingStatusAttributeValue)
	dp.Attributes().PutInt("blocking_isolation_level", blockingIsolationLevelAttributeValue)
	dp.Attributes().PutInt("blocking_open_transaction_count", blockingOpenTransactionCountAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryReads(cfg MetricConfig) metricSqlserverActivequeryReads {
	m := metricSqlserverActivequeryReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryRowCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.row_count metric with initial data.
func (m *metricSqlserverActivequeryRowCount) init() {
	m.data.SetName("sqlserver.activequery.row_count")
	m.data.SetDescription("Number of rows returned by currently executing query")
	m.data.SetUnit("{rows}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverActivequeryRowCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("login_name", loginNameAttributeValue)
	dp.Attributes().PutStr("host_name", hostNameAttributeValue)
	dp.Attributes().PutStr("program_name", programNameAttributeValue)
	dp.Attributes().PutStr("request_command", requestCommandAttributeValue)
	dp.Attributes().PutStr("request_status", requestStatusAttributeValue)
	dp.Attributes().PutStr("session_status", sessionStatusAttributeValue)
	dp.Attributes().PutStr("client_interface_name", clientInterfaceNameAttributeValue)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
	dp.Attributes().PutStr("wait_type_description", waitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_type_category", waitTypeCategoryAttributeValue)
	dp.Attributes().PutStr("wait_resource", waitResourceAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_name", waitResourceObjectNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_database_name", waitResourceDatabaseNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_type", waitResourceTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_description", waitResourceDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_resource_schema_name", waitResourceSchemaNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_table_name", waitResourceTableNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_type", waitResourceObjectTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_name", waitResourceIndexNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_type", waitResourceIndexTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type", lastWaitTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type_description", lastWaitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
	dp.Attributes().PutInt("transaction_id", transactionIDAttributeValue)
	dp.Attributes().PutInt("open_transaction_count", openTransactionCountAttributeValue)
	dp.Attributes().PutInt("transaction_isolation_level", transactionIsolationLevelAttributeValue)
	dp.Attributes().PutInt("degree_of_parallelism", degreeOfParallelismAttributeValue)
	dp.Attributes().PutInt("parallel_worker_count", parallelWorkerCountAttributeValue)
	dp.Attributes().PutInt("blocking_session_id", blockingSessionIDAttributeValue)
	dp.Attributes().PutStr("blocking_login_name", blockingLoginNameAttributeValue)
	dp.Attributes().PutStr("blocking_host_name", blockingHostNameAttributeValue)
	dp.Attributes().PutStr("blocking_program_name", blockingProgramNameAttributeValue)
	dp.Attributes().PutStr("blocking_status", blockingStatusAttributeValue)
	dp.Attributes().PutInt("blocking_isolation_level", blockingIsolationLevelAttributeValue)
	dp.Attributes().PutInt("blocking_open_transaction_count", blockingOpenTransactionCountAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryRowCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryRowCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryRowCount(cfg MetricConfig) metricSqlserverActivequeryRowCount {
	m := metricSqlserverActivequeryRowCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryWaitTimeSeconds struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.wait_time_seconds metric with initial data.
func (m *metricSqlserverActivequeryWaitTimeSeconds) init() {
	m.data.SetName("sqlserver.activequery.wait_time_seconds")
	m.data.SetDescription("Wait time for currently executing query")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverActivequeryWaitTimeSeconds) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("login_name", loginNameAttributeValue)
	dp.Attributes().PutStr("host_name", hostNameAttributeValue)
	dp.Attributes().PutStr("program_name", programNameAttributeValue)
	dp.Attributes().PutStr("request_command", requestCommandAttributeValue)
	dp.Attributes().PutStr("request_status", requestStatusAttributeValue)
	dp.Attributes().PutStr("session_status", sessionStatusAttributeValue)
	dp.Attributes().PutStr("client_interface_name", clientInterfaceNameAttributeValue)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
	dp.Attributes().PutStr("wait_type_description", waitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_type_category", waitTypeCategoryAttributeValue)
	dp.Attributes().PutStr("wait_resource", waitResourceAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_name", waitResourceObjectNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_database_name", waitResourceDatabaseNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_type", waitResourceTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_description", waitResourceDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_resource_schema_name", waitResourceSchemaNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_table_name", waitResourceTableNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_type", waitResourceObjectTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_name", waitResourceIndexNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_type", waitResourceIndexTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type", lastWaitTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type_description", lastWaitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
	dp.Attributes().PutInt("transaction_id", transactionIDAttributeValue)
	dp.Attributes().PutInt("open_transaction_count", openTransactionCountAttributeValue)
	dp.Attributes().PutInt("transaction_isolation_level", transactionIsolationLevelAttributeValue)
	dp.Attributes().PutInt("degree_of_parallelism", degreeOfParallelismAttributeValue)
	dp.Attributes().PutInt("parallel_worker_count", parallelWorkerCountAttributeValue)
	dp.Attributes().PutInt("blocking_session_id", blockingSessionIDAttributeValue)
	dp.Attributes().PutStr("blocking_login_name", blockingLoginNameAttributeValue)
	dp.Attributes().PutStr("blocking_host_name", blockingHostNameAttributeValue)
	dp.Attributes().PutStr("blocking_program_name", blockingProgramNameAttributeValue)
	dp.Attributes().PutStr("blocking_status", blockingStatusAttributeValue)
	dp.Attributes().PutInt("blocking_isolation_level", blockingIsolationLevelAttributeValue)
	dp.Attributes().PutInt("blocking_open_transaction_count", blockingOpenTransactionCountAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryWaitTimeSeconds) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryWaitTimeSeconds) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryWaitTimeSeconds(cfg MetricConfig) metricSqlserverActivequeryWaitTimeSeconds {
	m := metricSqlserverActivequeryWaitTimeSeconds{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryWrites struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.writes metric with initial data.
func (m *metricSqlserverActivequeryWrites) init() {
	m.data.SetName("sqlserver.activequery.writes")
	m.data.SetDescription("Number of writes for currently executing query")
	m.data.SetUnit("{writes}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverActivequeryWrites) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("login_name", loginNameAttributeValue)
	dp.Attributes().PutStr("host_name", hostNameAttributeValue)
	dp.Attributes().PutStr("program_name", programNameAttributeValue)
	dp.Attributes().PutStr("request_command", requestCommandAttributeValue)
	dp.Attributes().PutStr("request_status", requestStatusAttributeValue)
	dp.Attributes().PutStr("session_status", sessionStatusAttributeValue)
	dp.Attributes().PutStr("client_interface_name", clientInterfaceNameAttributeValue)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
	dp.Attributes().PutStr("wait_type_description", waitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_type_category", waitTypeCategoryAttributeValue)
	dp.Attributes().PutStr("wait_resource", waitResourceAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_name", waitResourceObjectNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_database_name", waitResourceDatabaseNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_type", waitResourceTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_description", waitResourceDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_resource_schema_name", waitResourceSchemaNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_table_name", waitResourceTableNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_type", waitResourceObjectTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_name", waitResourceIndexNameAttributeValue)
	dp.Attributes().PutStr("wait_resource_index_type", waitResourceIndexTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type", lastWaitTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type_description", lastWaitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
	dp.Attributes().PutInt("transaction_id", transactionIDAttributeValue)
	dp.Attributes().PutInt("open_transaction_count", openTransactionCountAttributeValue)
	dp.Attributes().PutInt("transaction_isolation_level", transactionIsolationLevelAttributeValue)
	dp.Attributes().PutInt("degree_of_parallelism", degreeOfParallelismAttributeValue)
	dp.Attributes().PutInt("parallel_worker_count", parallelWorkerCountAttributeValue)
	dp.Attributes().PutInt("blocking_session_id", blockingSessionIDAttributeValue)
	dp.Attributes().PutStr("blocking_login_name", blockingLoginNameAttributeValue)
	dp.Attributes().PutStr("blocking_host_name", blockingHostNameAttributeValue)
	dp.Attributes().PutStr("blocking_program_name", blockingProgramNameAttributeValue)
	dp.Attributes().PutStr("blocking_status", blockingStatusAttributeValue)
	dp.Attributes().PutInt("blocking_isolation_level", blockingIsolationLevelAttributeValue)
	dp.Attributes().PutInt("blocking_open_transaction_count", blockingOpenTransactionCountAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryWrites) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryWrites) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryWrites(cfg MetricConfig) metricSqlserverActivequeryWrites {
	m := metricSqlserverActivequeryWrites{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBufferCacheHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.buffer.cache_hit_ratio metric with initial data.
func (m *metricSqlserverBufferCacheHitRatio) init() {
	m.data.SetName("sqlserver.buffer.cache_hit_ratio")
	m.data.SetDescription("Buffer cache hit ratio percentage")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBufferCacheHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBufferCacheHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBufferCacheHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBufferCacheHitRatio(cfg MetricConfig) metricSqlserverBufferCacheHitRatio {
	m := metricSqlserverBufferCacheHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBufferCheckpointPagesPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.buffer.checkpoint_pages_per_sec metric with initial data.
func (m *metricSqlserverBufferCheckpointPagesPerSec) init() {
	m.data.SetName("sqlserver.buffer.checkpoint_pages_per_sec")
	m.data.SetDescription("Checkpoint pages per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBufferCheckpointPagesPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBufferCheckpointPagesPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBufferCheckpointPagesPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBufferCheckpointPagesPerSec(cfg MetricConfig) metricSqlserverBufferCheckpointPagesPerSec {
	m := metricSqlserverBufferCheckpointPagesPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBufferPageLifeExpectancy struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.buffer.page_life_expectancy metric with initial data.
func (m *metricSqlserverBufferPageLifeExpectancy) init() {
	m.data.SetName("sqlserver.buffer.page_life_expectancy")
	m.data.SetDescription("Page life expectancy in seconds")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBufferPageLifeExpectancy) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBufferPageLifeExpectancy) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBufferPageLifeExpectancy) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBufferPageLifeExpectancy(cfg MetricConfig) metricSqlserverBufferPageLifeExpectancy {
	m := metricSqlserverBufferPageLifeExpectancy{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBufferPoolHitPercent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.bufferPoolHitPercent metric with initial data.
func (m *metricSqlserverBufferPoolHitPercent) init() {
	m.data.SetName("sqlserver.bufferPoolHitPercent")
	m.data.SetDescription("Buffer pool hit percentage")
	m.data.SetUnit("Percent")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBufferPoolHitPercent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBufferPoolHitPercent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBufferPoolHitPercent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBufferPoolHitPercent(cfg MetricConfig) metricSqlserverBufferPoolHitPercent {
	m := metricSqlserverBufferPoolHitPercent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBufferpoolBatchRequestsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.bufferpool.batch_requests_per_sec metric with initial data.
func (m *metricSqlserverBufferpoolBatchRequestsPerSec) init() {
	m.data.SetName("sqlserver.bufferpool.batch_requests_per_sec")
	m.data.SetDescription("Batch requests per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBufferpoolBatchRequestsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBufferpoolBatchRequestsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBufferpoolBatchRequestsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBufferpoolBatchRequestsPerSec(cfg MetricConfig) metricSqlserverBufferpoolBatchRequestsPerSec {
	m := metricSqlserverBufferpoolBatchRequestsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBufferpoolPageLifeExpectancyMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.bufferpool.page_life_expectancy_ms metric with initial data.
func (m *metricSqlserverBufferpoolPageLifeExpectancyMs) init() {
	m.data.SetName("sqlserver.bufferpool.page_life_expectancy_ms")
	m.data.SetDescription("Page life expectancy in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBufferpoolPageLifeExpectancyMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBufferpoolPageLifeExpectancyMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBufferpoolPageLifeExpectancyMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBufferpoolPageLifeExpectancyMs(cfg MetricConfig) metricSqlserverBufferpoolPageLifeExpectancyMs {
	m := metricSqlserverBufferpoolPageLifeExpectancyMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverConnectionsUser struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.connections.user metric with initial data.
func (m *metricSqlserverConnectionsUser) init() {
	m.data.SetName("sqlserver.connections.user")
	m.data.SetDescription("Number of user connections")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverConnectionsUser) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverConnectionsUser) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverConnectionsUser) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverConnectionsUser(cfg MetricConfig) metricSqlserverConnectionsUser {
	m := metricSqlserverConnectionsUser{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.bufferpool.sizePerDatabaseInBytes metric with initial data.
func (m *metricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes) init() {
	m.data.SetName("sqlserver.database.bufferpool.sizePerDatabaseInBytes")
	m.data.SetDescription("Size of the SQL Server buffer pool allocated for the database")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes(cfg MetricConfig) metricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes {
	m := metricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseIoStallInMilliseconds struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.io.stallInMilliseconds metric with initial data.
func (m *metricSqlserverDatabaseIoStallInMilliseconds) init() {
	m.data.SetName("sqlserver.database.io.stallInMilliseconds")
	m.data.SetDescription("Total IO stall time for the SQL Server database")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseIoStallInMilliseconds) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseIoStallInMilliseconds) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseIoStallInMilliseconds) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseIoStallInMilliseconds(cfg MetricConfig) metricSqlserverDatabaseIoStallInMilliseconds {
	m := metricSqlserverDatabaseIoStallInMilliseconds{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseLogBytesFlushesPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.log.bytesFlushesPerSec metric with initial data.
func (m *metricSqlserverDatabaseLogBytesFlushesPerSec) init() {
	m.data.SetName("sqlserver.database.log.bytesFlushesPerSec")
	m.data.SetDescription("Number of log bytes flushed per second")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseLogBytesFlushesPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseLogBytesFlushesPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseLogBytesFlushesPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseLogBytesFlushesPerSec(cfg MetricConfig) metricSqlserverDatabaseLogBytesFlushesPerSec {
	m := metricSqlserverDatabaseLogBytesFlushesPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseLogFlushWaitsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.log.flushWaitsPerSec metric with initial data.
func (m *metricSqlserverDatabaseLogFlushWaitsPerSec) init() {
	m.data.SetName("sqlserver.database.log.flushWaitsPerSec")
	m.data.SetDescription("Number of flush wait operations per second")
	m.data.SetUnit("{operations}/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseLogFlushWaitsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseLogFlushWaitsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseLogFlushWaitsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseLogFlushWaitsPerSec(cfg MetricConfig) metricSqlserverDatabaseLogFlushWaitsPerSec {
	m := metricSqlserverDatabaseLogFlushWaitsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseLogFlushesPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.log.flushesPerSec metric with initial data.
func (m *metricSqlserverDatabaseLogFlushesPerSec) init() {
	m.data.SetName("sqlserver.database.log.flushesPerSec")
	m.data.SetDescription("Number of log flush operations per second")
	m.data.SetUnit("{operations}/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseLogFlushesPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseLogFlushesPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseLogFlushesPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseLogFlushesPerSec(cfg MetricConfig) metricSqlserverDatabaseLogFlushesPerSec {
	m := metricSqlserverDatabaseLogFlushesPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseLogTransactionGrowth struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.log.transactionGrowth metric with initial data.
func (m *metricSqlserverDatabaseLogTransactionGrowth) init() {
	m.data.SetName("sqlserver.database.log.transactionGrowth")
	m.data.SetDescription("Number of log growth events for the SQL Server database")
	m.data.SetUnit("{events}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseLogTransactionGrowth) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseLogTransactionGrowth) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseLogTransactionGrowth) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseLogTransactionGrowth(cfg MetricConfig) metricSqlserverDatabaseLogTransactionGrowth {
	m := metricSqlserverDatabaseLogTransactionGrowth{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseLogUsedSpaceMB struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.log.usedSpaceMB metric with initial data.
func (m *metricSqlserverDatabaseLogUsedSpaceMB) init() {
	m.data.SetName("sqlserver.database.log.usedSpaceMB")
	m.data.SetDescription("Used log space in megabytes")
	m.data.SetUnit("MBy")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseLogUsedSpaceMB) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseLogUsedSpaceMB) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseLogUsedSpaceMB) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseLogUsedSpaceMB(cfg MetricConfig) metricSqlserverDatabaseLogUsedSpaceMB {
	m := metricSqlserverDatabaseLogUsedSpaceMB{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseMaxDiskSizeInBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.maxDiskSizeInBytes metric with initial data.
func (m *metricSqlserverDatabaseMaxDiskSizeInBytes) init() {
	m.data.SetName("sqlserver.database.maxDiskSizeInBytes")
	m.data.SetDescription("Maximum disk size allowed for the SQL Server database")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseMaxDiskSizeInBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseMaxDiskSizeInBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseMaxDiskSizeInBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseMaxDiskSizeInBytes(cfg MetricConfig) metricSqlserverDatabaseMaxDiskSizeInBytes {
	m := metricSqlserverDatabaseMaxDiskSizeInBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePageFileAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.pageFileAvailable metric with initial data.
func (m *metricSqlserverDatabasePageFileAvailable) init() {
	m.data.SetName("sqlserver.database.pageFileAvailable")
	m.data.SetDescription("Available page file space (reserved space not used) for the SQL Server database")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePageFileAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePageFileAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePageFileAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePageFileAvailable(cfg MetricConfig) metricSqlserverDatabasePageFileAvailable {
	m := metricSqlserverDatabasePageFileAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePageFileTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.pageFileTotal metric with initial data.
func (m *metricSqlserverDatabasePageFileTotal) init() {
	m.data.SetName("sqlserver.database.pageFileTotal")
	m.data.SetDescription("Total page file space (total reserved space) for the SQL Server database")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePageFileTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePageFileTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePageFileTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePageFileTotal(cfg MetricConfig) metricSqlserverDatabasePageFileTotal {
	m := metricSqlserverDatabasePageFileTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalCreateDate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principal.createDate metric with initial data.
func (m *metricSqlserverDatabasePrincipalCreateDate) init() {
	m.data.SetName("sqlserver.database.principal.createDate")
	m.data.SetDescription("Database principal creation date as Unix timestamp")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalCreateDate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, principalNameAttributeValue string, principalTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("principal_name", principalNameAttributeValue)
	dp.Attributes().PutStr("principal_type", principalTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalCreateDate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalCreateDate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalCreateDate(cfg MetricConfig) metricSqlserverDatabasePrincipalCreateDate {
	m := metricSqlserverDatabasePrincipalCreateDate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsApplicationRoles struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.applicationRoles metric with initial data.
func (m *metricSqlserverDatabasePrincipalsApplicationRoles) init() {
	m.data.SetName("sqlserver.database.principals.applicationRoles")
	m.data.SetDescription("Number of application roles")
	m.data.SetUnit("{roles}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsApplicationRoles) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsApplicationRoles) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsApplicationRoles) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsApplicationRoles(cfg MetricConfig) metricSqlserverDatabasePrincipalsApplicationRoles {
	m := metricSqlserverDatabasePrincipalsApplicationRoles{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsOld struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.old metric with initial data.
func (m *metricSqlserverDatabasePrincipalsOld) init() {
	m.data.SetName("sqlserver.database.principals.old")
	m.data.SetDescription("Number of old principals (older than 365 days)")
	m.data.SetUnit("{principals}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsOld) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsOld) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsOld) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsOld(cfg MetricConfig) metricSqlserverDatabasePrincipalsOld {
	m := metricSqlserverDatabasePrincipalsOld{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsOrphanedUsers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.orphanedUsers metric with initial data.
func (m *metricSqlserverDatabasePrincipalsOrphanedUsers) init() {
	m.data.SetName("sqlserver.database.principals.orphanedUsers")
	m.data.SetDescription("Number of orphaned users without server login")
	m.data.SetUnit("{users}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsOrphanedUsers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsOrphanedUsers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsOrphanedUsers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsOrphanedUsers(cfg MetricConfig) metricSqlserverDatabasePrincipalsOrphanedUsers {
	m := metricSqlserverDatabasePrincipalsOrphanedUsers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsRecentlyCreated struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.recentlyCreated metric with initial data.
func (m *metricSqlserverDatabasePrincipalsRecentlyCreated) init() {
	m.data.SetName("sqlserver.database.principals.recentlyCreated")
	m.data.SetDescription("Number of recently created principals (last 30 days)")
	m.data.SetUnit("{principals}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsRecentlyCreated) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsRecentlyCreated) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsRecentlyCreated) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsRecentlyCreated(cfg MetricConfig) metricSqlserverDatabasePrincipalsRecentlyCreated {
	m := metricSqlserverDatabasePrincipalsRecentlyCreated{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsRoles struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.roles metric with initial data.
func (m *metricSqlserverDatabasePrincipalsRoles) init() {
	m.data.SetName("sqlserver.database.principals.roles")
	m.data.SetDescription("Number of database roles")
	m.data.SetUnit("{roles}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsRoles) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsRoles) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsRoles) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsRoles(cfg MetricConfig) metricSqlserverDatabasePrincipalsRoles {
	m := metricSqlserverDatabasePrincipalsRoles{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsSQLUsers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.sqlUsers metric with initial data.
func (m *metricSqlserverDatabasePrincipalsSQLUsers) init() {
	m.data.SetName("sqlserver.database.principals.sqlUsers")
	m.data.SetDescription("Number of SQL authentication users")
	m.data.SetUnit("{users}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsSQLUsers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsSQLUsers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsSQLUsers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsSQLUsers(cfg MetricConfig) metricSqlserverDatabasePrincipalsSQLUsers {
	m := metricSqlserverDatabasePrincipalsSQLUsers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.total metric with initial data.
func (m *metricSqlserverDatabasePrincipalsTotal) init() {
	m.data.SetName("sqlserver.database.principals.total")
	m.data.SetDescription("Total number of database principals")
	m.data.SetUnit("{principals}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsTotal(cfg MetricConfig) metricSqlserverDatabasePrincipalsTotal {
	m := metricSqlserverDatabasePrincipalsTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsUsers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.users metric with initial data.
func (m *metricSqlserverDatabasePrincipalsUsers) init() {
	m.data.SetName("sqlserver.database.principals.users")
	m.data.SetDescription("Number of database users")
	m.data.SetUnit("{users}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsUsers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsUsers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsUsers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsUsers(cfg MetricConfig) metricSqlserverDatabasePrincipalsUsers {
	m := metricSqlserverDatabasePrincipalsUsers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsWindowsUsers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.windowsUsers metric with initial data.
func (m *metricSqlserverDatabasePrincipalsWindowsUsers) init() {
	m.data.SetName("sqlserver.database.principals.windowsUsers")
	m.data.SetDescription("Number of Windows authentication users")
	m.data.SetUnit("{users}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsWindowsUsers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsWindowsUsers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsWindowsUsers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsWindowsUsers(cfg MetricConfig) metricSqlserverDatabasePrincipalsWindowsUsers {
	m := metricSqlserverDatabasePrincipalsWindowsUsers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembersApplicationRoles struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.members.applicationRoles metric with initial data.
func (m *metricSqlserverDatabaseRoleMembersApplicationRoles) init() {
	m.data.SetName("sqlserver.database.role.members.applicationRoles")
	m.data.SetDescription("Number of application role members")
	m.data.SetUnit("{members}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembersApplicationRoles) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembersApplicationRoles) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembersApplicationRoles) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembersApplicationRoles(cfg MetricConfig) metricSqlserverDatabaseRoleMembersApplicationRoles {
	m := metricSqlserverDatabaseRoleMembersApplicationRoles{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembersCrossRole struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.members.crossRole metric with initial data.
func (m *metricSqlserverDatabaseRoleMembersCrossRole) init() {
	m.data.SetName("sqlserver.database.role.members.crossRole")
	m.data.SetDescription("Number of cross-role members")
	m.data.SetUnit("{members}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembersCrossRole) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembersCrossRole) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembersCrossRole) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembersCrossRole(cfg MetricConfig) metricSqlserverDatabaseRoleMembersCrossRole {
	m := metricSqlserverDatabaseRoleMembersCrossRole{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembersHighPrivilege struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.members.highPrivilege metric with initial data.
func (m *metricSqlserverDatabaseRoleMembersHighPrivilege) init() {
	m.data.SetName("sqlserver.database.role.members.highPrivilege")
	m.data.SetDescription("Number of high privilege role members")
	m.data.SetUnit("{members}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembersHighPrivilege) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembersHighPrivilege) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembersHighPrivilege) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembersHighPrivilege(cfg MetricConfig) metricSqlserverDatabaseRoleMembersHighPrivilege {
	m := metricSqlserverDatabaseRoleMembersHighPrivilege{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembersUnique struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.members.unique metric with initial data.
func (m *metricSqlserverDatabaseRoleMembersUnique) init() {
	m.data.SetName("sqlserver.database.role.members.unique")
	m.data.SetDescription("Number of unique members in roles")
	m.data.SetUnit("{members}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembersUnique) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembersUnique) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembersUnique) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembersUnique(cfg MetricConfig) metricSqlserverDatabaseRoleMembersUnique {
	m := metricSqlserverDatabaseRoleMembersUnique{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembershipActive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.membership.active metric with initial data.
func (m *metricSqlserverDatabaseRoleMembershipActive) init() {
	m.data.SetName("sqlserver.database.role.membership.active")
	m.data.SetDescription("Database role membership active status")
	m.data.SetUnit("{status}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembershipActive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, roleNameAttributeValue string, memberNameAttributeValue string, roleTypeAttributeValue string, memberTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("role_name", roleNameAttributeValue)
	dp.Attributes().PutStr("member_name", memberNameAttributeValue)
	dp.Attributes().PutStr("role_type", roleTypeAttributeValue)
	dp.Attributes().PutStr("member_type", memberTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembershipActive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembershipActive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembershipActive(cfg MetricConfig) metricSqlserverDatabaseRoleMembershipActive {
	m := metricSqlserverDatabaseRoleMembershipActive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembershipsActive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.memberships.active metric with initial data.
func (m *metricSqlserverDatabaseRoleMembershipsActive) init() {
	m.data.SetName("sqlserver.database.role.memberships.active")
	m.data.SetDescription("Number of active role memberships")
	m.data.SetUnit("{memberships}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembershipsActive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembershipsActive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembershipsActive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembershipsActive(cfg MetricConfig) metricSqlserverDatabaseRoleMembershipsActive {
	m := metricSqlserverDatabaseRoleMembershipsActive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembershipsCustom struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.memberships.custom metric with initial data.
func (m *metricSqlserverDatabaseRoleMembershipsCustom) init() {
	m.data.SetName("sqlserver.database.role.memberships.custom")
	m.data.SetDescription("Number of custom role memberships")
	m.data.SetUnit("{memberships}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembershipsCustom) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembershipsCustom) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembershipsCustom) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembershipsCustom(cfg MetricConfig) metricSqlserverDatabaseRoleMembershipsCustom {
	m := metricSqlserverDatabaseRoleMembershipsCustom{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembershipsNested struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.memberships.nested metric with initial data.
func (m *metricSqlserverDatabaseRoleMembershipsNested) init() {
	m.data.SetName("sqlserver.database.role.memberships.nested")
	m.data.SetDescription("Number of nested role memberships")
	m.data.SetUnit("{memberships}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembershipsNested) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembershipsNested) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembershipsNested) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembershipsNested(cfg MetricConfig) metricSqlserverDatabaseRoleMembershipsNested {
	m := metricSqlserverDatabaseRoleMembershipsNested{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembershipsTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.memberships.total metric with initial data.
func (m *metricSqlserverDatabaseRoleMembershipsTotal) init() {
	m.data.SetName("sqlserver.database.role.memberships.total")
	m.data.SetDescription("Total number of role memberships")
	m.data.SetUnit("{memberships}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembershipsTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembershipsTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembershipsTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembershipsTotal(cfg MetricConfig) metricSqlserverDatabaseRoleMembershipsTotal {
	m := metricSqlserverDatabaseRoleMembershipsTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembershipsUsers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.memberships.users metric with initial data.
func (m *metricSqlserverDatabaseRoleMembershipsUsers) init() {
	m.data.SetName("sqlserver.database.role.memberships.users")
	m.data.SetDescription("Number of user role memberships")
	m.data.SetUnit("{memberships}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembershipsUsers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembershipsUsers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembershipsUsers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembershipsUsers(cfg MetricConfig) metricSqlserverDatabaseRoleMembershipsUsers {
	m := metricSqlserverDatabaseRoleMembershipsUsers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleNestingLevel struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.nesting.level metric with initial data.
func (m *metricSqlserverDatabaseRoleNestingLevel) init() {
	m.data.SetName("sqlserver.database.role.nesting.level")
	m.data.SetDescription("Role nesting level")
	m.data.SetUnit("{level}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleNestingLevel) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, parentRoleNameAttributeValue string, childRoleNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("parent_role_name", parentRoleNameAttributeValue)
	dp.Attributes().PutStr("child_role_name", childRoleNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleNestingLevel) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleNestingLevel) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleNestingLevel(cfg MetricConfig) metricSqlserverDatabaseRoleNestingLevel {
	m := metricSqlserverDatabaseRoleNestingLevel{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRolePermissionMemberCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.permission.memberCount metric with initial data.
func (m *metricSqlserverDatabaseRolePermissionMemberCount) init() {
	m.data.SetName("sqlserver.database.role.permission.memberCount")
	m.data.SetDescription("Number of members in role")
	m.data.SetUnit("{members}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRolePermissionMemberCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, roleNameAttributeValue string, permissionScopeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("role_name", roleNameAttributeValue)
	dp.Attributes().PutStr("permission_scope", permissionScopeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRolePermissionMemberCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRolePermissionMemberCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRolePermissionMemberCount(cfg MetricConfig) metricSqlserverDatabaseRolePermissionMemberCount {
	m := metricSqlserverDatabaseRolePermissionMemberCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRolePermissionRiskLevel struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.permission.riskLevel metric with initial data.
func (m *metricSqlserverDatabaseRolePermissionRiskLevel) init() {
	m.data.SetName("sqlserver.database.role.permission.riskLevel")
	m.data.SetDescription("Role risk level")
	m.data.SetUnit("{level}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRolePermissionRiskLevel) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, roleNameAttributeValue string, permissionScopeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("role_name", roleNameAttributeValue)
	dp.Attributes().PutStr("permission_scope", permissionScopeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRolePermissionRiskLevel) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRolePermissionRiskLevel) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRolePermissionRiskLevel(cfg MetricConfig) metricSqlserverDatabaseRolePermissionRiskLevel {
	m := metricSqlserverDatabaseRolePermissionRiskLevel{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRolePermissionsInherited struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.permissions.inherited metric with initial data.
func (m *metricSqlserverDatabaseRolePermissionsInherited) init() {
	m.data.SetName("sqlserver.database.role.permissions.inherited")
	m.data.SetDescription("Role permission inheritance status")
	m.data.SetUnit("{status}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRolePermissionsInherited) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, parentRoleNameAttributeValue string, childRoleNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("parent_role_name", parentRoleNameAttributeValue)
	dp.Attributes().PutStr("child_role_name", childRoleNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRolePermissionsInherited) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRolePermissionsInherited) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRolePermissionsInherited(cfg MetricConfig) metricSqlserverDatabaseRolePermissionsInherited {
	m := metricSqlserverDatabaseRolePermissionsInherited{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleRolesEmpty struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.roles.empty metric with initial data.
func (m *metricSqlserverDatabaseRoleRolesEmpty) init() {
	m.data.SetName("sqlserver.database.role.roles.empty")
	m.data.SetDescription("Number of empty roles")
	m.data.SetUnit("{roles}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleRolesEmpty) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleRolesEmpty) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleRolesEmpty) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleRolesEmpty(cfg MetricConfig) metricSqlserverDatabaseRoleRolesEmpty {
	m := metricSqlserverDatabaseRoleRolesEmpty{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleRolesWithMembers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.roles.withMembers metric with initial data.
func (m *metricSqlserverDatabaseRoleRolesWithMembers) init() {
	m.data.SetName("sqlserver.database.role.roles.withMembers")
	m.data.SetDescription("Number of unique roles with members")
	m.data.SetUnit("{roles}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleRolesWithMembers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleRolesWithMembers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleRolesWithMembers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleRolesWithMembers(cfg MetricConfig) metricSqlserverDatabaseRoleRolesWithMembers {
	m := metricSqlserverDatabaseRoleRolesWithMembers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseSizeDataSizeMB struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.size.dataSizeMB metric with initial data.
func (m *metricSqlserverDatabaseSizeDataSizeMB) init() {
	m.data.SetName("sqlserver.database.size.dataSizeMB")
	m.data.SetDescription("Total data file size excluding log files")
	m.data.SetUnit("MBy")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseSizeDataSizeMB) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseSizeDataSizeMB) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseSizeDataSizeMB) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseSizeDataSizeMB(cfg MetricConfig) metricSqlserverDatabaseSizeDataSizeMB {
	m := metricSqlserverDatabaseSizeDataSizeMB{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseSizeTotalSizeMB struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.size.totalSizeMB metric with initial data.
func (m *metricSqlserverDatabaseSizeTotalSizeMB) init() {
	m.data.SetName("sqlserver.database.size.totalSizeMB")
	m.data.SetDescription("Total database size including data and log files")
	m.data.SetUnit("MBy")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseSizeTotalSizeMB) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseSizeTotalSizeMB) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseSizeTotalSizeMB) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseSizeTotalSizeMB(cfg MetricConfig) metricSqlserverDatabaseSizeTotalSizeMB {
	m := metricSqlserverDatabaseSizeTotalSizeMB{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseTransactionsActive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.transactions.active metric with initial data.
func (m *metricSqlserverDatabaseTransactionsActive) init() {
	m.data.SetName("sqlserver.database.transactions.active")
	m.data.SetDescription("Number of active transactions")
	m.data.SetUnit("{transactions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseTransactionsActive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseTransactionsActive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseTransactionsActive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseTransactionsActive(cfg MetricConfig) metricSqlserverDatabaseTransactionsActive {
	m := metricSqlserverDatabaseTransactionsActive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterAgClusterType struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.ag_cluster_type metric with initial data.
func (m *metricSqlserverFailoverClusterAgClusterType) init() {
	m.data.SetName("sqlserver.failover_cluster.ag_cluster_type")
	m.data.SetDescription("Cluster type for the availability group (WSFC, EXTERNAL, NONE)")
	m.data.SetUnit("{status}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterAgClusterType) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("group_name", groupNameAttributeValue)
	dp.Attributes().PutStr("cluster_type_desc", clusterTypeDescAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterAgClusterType) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterAgClusterType) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterAgClusterType(cfg MetricConfig) metricSqlserverFailoverClusterAgClusterType {
	m := metricSqlserverFailoverClusterAgClusterType{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterAgFailureConditionLevel struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.ag_failure_condition_level metric with initial data.
func (m *metricSqlserverFailoverClusterAgFailureConditionLevel) init() {
	m.data.SetName("sqlserver.failover_cluster.ag_failure_condition_level")
	m.data.SetDescription("Automatic failover condition level for the availability group (1-5)")
	m.data.SetUnit("{level}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterAgFailureConditionLevel) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("group_name", groupNameAttributeValue)
	dp.Attributes().PutStr("cluster_type_desc", clusterTypeDescAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterAgFailureConditionLevel) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterAgFailureConditionLevel) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterAgFailureConditionLevel(cfg MetricConfig) metricSqlserverFailoverClusterAgFailureConditionLevel {
	m := metricSqlserverFailoverClusterAgFailureConditionLevel{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterAgHealthCheckTimeout struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.ag_health_check_timeout metric with initial data.
func (m *metricSqlserverFailoverClusterAgHealthCheckTimeout) init() {
	m.data.SetName("sqlserver.failover_cluster.ag_health_check_timeout")
	m.data.SetDescription("Health check timeout for the availability group in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterAgHealthCheckTimeout) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("group_name", groupNameAttributeValue)
	dp.Attributes().PutStr("cluster_type_desc", clusterTypeDescAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterAgHealthCheckTimeout) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterAgHealthCheckTimeout) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterAgHealthCheckTimeout(cfg MetricConfig) metricSqlserverFailoverClusterAgHealthCheckTimeout {
	m := metricSqlserverFailoverClusterAgHealthCheckTimeout{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterAgReplicaRole struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.ag_replica_role metric with initial data.
func (m *metricSqlserverFailoverClusterAgReplicaRole) init() {
	m.data.SetName("sqlserver.failover_cluster.ag_replica_role")
	m.data.SetDescription("Current role of the replica within the Availability Group (PRIMARY or SECONDARY)")
	m.data.SetUnit("{status}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterAgReplicaRole) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, roleDescAttributeValue string, synchronizationHealthDescAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("replica_server_name", replicaServerNameAttributeValue)
	dp.Attributes().PutStr("role_desc", roleDescAttributeValue)
	dp.Attributes().PutStr("synchronization_health_desc", synchronizationHealthDescAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterAgReplicaRole) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterAgReplicaRole) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterAgReplicaRole(cfg MetricConfig) metricSqlserverFailoverClusterAgReplicaRole {
	m := metricSqlserverFailoverClusterAgReplicaRole{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterAgSynchronizationHealth struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.ag_synchronization_health metric with initial data.
func (m *metricSqlserverFailoverClusterAgSynchronizationHealth) init() {
	m.data.SetName("sqlserver.failover_cluster.ag_synchronization_health")
	m.data.SetDescription("Health of data synchronization between primary and secondary replica (HEALTHY, PARTIALLY_HEALTHY, NOT_HEALTHY)")
	m.data.SetUnit("{status}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterAgSynchronizationHealth) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, roleDescAttributeValue string, synchronizationHealthDescAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("replica_server_name", replicaServerNameAttributeValue)
	dp.Attributes().PutStr("role_desc", roleDescAttributeValue)
	dp.Attributes().PutStr("synchronization_health_desc", synchronizationHealthDescAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterAgSynchronizationHealth) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterAgSynchronizationHealth) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterAgSynchronizationHealth(cfg MetricConfig) metricSqlserverFailoverClusterAgSynchronizationHealth {
	m := metricSqlserverFailoverClusterAgSynchronizationHealth{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterFlowControlTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.flow_control_time_ms metric with initial data.
func (m *metricSqlserverFailoverClusterFlowControlTimeMs) init() {
	m.data.SetName("sqlserver.failover_cluster.flow_control_time_ms")
	m.data.SetDescription("Time spent in flow control by log records from primary replica in milliseconds per second")
	m.data.SetUnit("ms/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterFlowControlTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("instance_name", instanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterFlowControlTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterFlowControlTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterFlowControlTimeMs(cfg MetricConfig) metricSqlserverFailoverClusterFlowControlTimeMs {
	m := metricSqlserverFailoverClusterFlowControlTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterLogBytesReceivedPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.log_bytes_received_per_sec metric with initial data.
func (m *metricSqlserverFailoverClusterLogBytesReceivedPerSec) init() {
	m.data.SetName("sqlserver.failover_cluster.log_bytes_received_per_sec")
	m.data.SetDescription("Rate of log records received by secondary replica from primary replica in bytes per second")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterLogBytesReceivedPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("instance_name", instanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterLogBytesReceivedPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterLogBytesReceivedPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterLogBytesReceivedPerSec(cfg MetricConfig) metricSqlserverFailoverClusterLogBytesReceivedPerSec {
	m := metricSqlserverFailoverClusterLogBytesReceivedPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterLogSendQueueKb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.log_send_queue_kb metric with initial data.
func (m *metricSqlserverFailoverClusterLogSendQueueKb) init() {
	m.data.SetName("sqlserver.failover_cluster.log_send_queue_kb")
	m.data.SetDescription("Amount of log records in the log send queue waiting to be sent to the secondary replica in kilobytes")
	m.data.SetUnit("KBy")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterLogSendQueueKb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("replica_server_name", replicaServerNameAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterLogSendQueueKb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterLogSendQueueKb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterLogSendQueueKb(cfg MetricConfig) metricSqlserverFailoverClusterLogSendQueueKb {
	m := metricSqlserverFailoverClusterLogSendQueueKb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterRedoQueueKb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.redo_queue_kb metric with initial data.
func (m *metricSqlserverFailoverClusterRedoQueueKb) init() {
	m.data.SetName("sqlserver.failover_cluster.redo_queue_kb")
	m.data.SetDescription("Amount of log records in the redo queue waiting to be redone on the secondary replica in kilobytes")
	m.data.SetUnit("KBy")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterRedoQueueKb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("replica_server_name", replicaServerNameAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterRedoQueueKb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterRedoQueueKb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterRedoQueueKb(cfg MetricConfig) metricSqlserverFailoverClusterRedoQueueKb {
	m := metricSqlserverFailoverClusterRedoQueueKb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterRedoRateKbSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.redo_rate_kb_sec metric with initial data.
func (m *metricSqlserverFailoverClusterRedoRateKbSec) init() {
	m.data.SetName("sqlserver.failover_cluster.redo_rate_kb_sec")
	m.data.SetDescription("Rate at which log records are being redone on the secondary replica in kilobytes per second")
	m.data.SetUnit("KBy/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterRedoRateKbSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("replica_server_name", replicaServerNameAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterRedoRateKbSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterRedoRateKbSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterRedoRateKbSec(cfg MetricConfig) metricSqlserverFailoverClusterRedoRateKbSec {
	m := metricSqlserverFailoverClusterRedoRateKbSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterTransactionDelayMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.transaction_delay_ms metric with initial data.
func (m *metricSqlserverFailoverClusterTransactionDelayMs) init() {
	m.data.SetName("sqlserver.failover_cluster.transaction_delay_ms")
	m.data.SetDescription("Average delay for transactions on the secondary replica in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterTransactionDelayMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("instance_name", instanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterTransactionDelayMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterTransactionDelayMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterTransactionDelayMs(cfg MetricConfig) metricSqlserverFailoverClusterTransactionDelayMs {
	m := metricSqlserverFailoverClusterTransactionDelayMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverIndividualQueryTotalCPUMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.individual_query.total_cpu_ms metric with initial data.
func (m *metricSqlserverIndividualQueryTotalCPUMs) init() {
	m.data.SetName("sqlserver.individual_query.total_cpu_ms")
	m.data.SetDescription("Total CPU time in milliseconds for individual query analysis")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverIndividualQueryTotalCPUMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanIDAttributeValue string, queryTextAttributeValue string, creationTimeAttributeValue string, lastExecutionTimeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_id", queryPlanIDAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverIndividualQueryTotalCPUMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverIndividualQueryTotalCPUMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverIndividualQueryTotalCPUMs(cfg MetricConfig) metricSqlserverIndividualQueryTotalCPUMs {
	m := metricSqlserverIndividualQueryTotalCPUMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverIndividualQueryTotalElapsedMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.individual_query.total_elapsed_ms metric with initial data.
func (m *metricSqlserverIndividualQueryTotalElapsedMs) init() {
	m.data.SetName("sqlserver.individual_query.total_elapsed_ms")
	m.data.SetDescription("Total elapsed time in milliseconds for individual query analysis")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverIndividualQueryTotalElapsedMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanIDAttributeValue string, queryTextAttributeValue string, creationTimeAttributeValue string, lastExecutionTimeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_id", queryPlanIDAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverIndividualQueryTotalElapsedMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverIndividualQueryTotalElapsedMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverIndividualQueryTotalElapsedMs(cfg MetricConfig) metricSqlserverIndividualQueryTotalElapsedMs {
	m := metricSqlserverIndividualQueryTotalElapsedMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceBufferPoolSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.buffer_pool_size metric with initial data.
func (m *metricSqlserverInstanceBufferPoolSize) init() {
	m.data.SetName("sqlserver.instance.buffer_pool_size")
	m.data.SetDescription("Buffer pool size")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceBufferPoolSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceBufferPoolSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceBufferPoolSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceBufferPoolSize(cfg MetricConfig) metricSqlserverInstanceBufferPoolSize {
	m := metricSqlserverInstanceBufferPoolSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceCompilationsPerBatch struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.compilations_per_batch metric with initial data.
func (m *metricSqlserverInstanceCompilationsPerBatch) init() {
	m.data.SetName("sqlserver.instance.compilations_per_batch")
	m.data.SetDescription("SQL compilations per batch request")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceCompilationsPerBatch) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceCompilationsPerBatch) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceCompilationsPerBatch) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceCompilationsPerBatch(cfg MetricConfig) metricSqlserverInstanceCompilationsPerBatch {
	m := metricSqlserverInstanceCompilationsPerBatch{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceForcedParameterizationsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.forced_parameterizations_per_sec metric with initial data.
func (m *metricSqlserverInstanceForcedParameterizationsPerSec) init() {
	m.data.SetName("sqlserver.instance.forced_parameterizations_per_sec")
	m.data.SetDescription("Forced parameterizations per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceForcedParameterizationsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceForcedParameterizationsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceForcedParameterizationsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceForcedParameterizationsPerSec(cfg MetricConfig) metricSqlserverInstanceForcedParameterizationsPerSec {
	m := metricSqlserverInstanceForcedParameterizationsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceFullScansRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.full_scans_rate metric with initial data.
func (m *metricSqlserverInstanceFullScansRate) init() {
	m.data.SetName("sqlserver.instance.full_scans_rate")
	m.data.SetDescription("Full table/index scans per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceFullScansRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceFullScansRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceFullScansRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceFullScansRate(cfg MetricConfig) metricSqlserverInstanceFullScansRate {
	m := metricSqlserverInstanceFullScansRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceLockTimeoutsRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.lock_timeouts_rate metric with initial data.
func (m *metricSqlserverInstanceLockTimeoutsRate) init() {
	m.data.SetName("sqlserver.instance.lock_timeouts_rate")
	m.data.SetDescription("Number of lock timeouts per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceLockTimeoutsRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceLockTimeoutsRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceLockTimeoutsRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceLockTimeoutsRate(cfg MetricConfig) metricSqlserverInstanceLockTimeoutsRate {
	m := metricSqlserverInstanceLockTimeoutsRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.memoryAvailable metric with initial data.
func (m *metricSqlserverInstanceMemoryAvailable) init() {
	m.data.SetName("sqlserver.instance.memoryAvailable")
	m.data.SetDescription("Available physical memory on the system")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceMemoryAvailable(cfg MetricConfig) metricSqlserverInstanceMemoryAvailable {
	m := metricSqlserverInstanceMemoryAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceMemoryTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.memoryTotal metric with initial data.
func (m *metricSqlserverInstanceMemoryTotal) init() {
	m.data.SetName("sqlserver.instance.memoryTotal")
	m.data.SetDescription("Total physical memory on the system")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceMemoryTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceMemoryTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceMemoryTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceMemoryTotal(cfg MetricConfig) metricSqlserverInstanceMemoryTotal {
	m := metricSqlserverInstanceMemoryTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceMemoryUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.memoryUtilization metric with initial data.
func (m *metricSqlserverInstanceMemoryUtilization) init() {
	m.data.SetName("sqlserver.instance.memoryUtilization")
	m.data.SetDescription("Percentage of memory utilization")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceMemoryUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceMemoryUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceMemoryUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceMemoryUtilization(cfg MetricConfig) metricSqlserverInstanceMemoryUtilization {
	m := metricSqlserverInstanceMemoryUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstancePageSplitsPerBatch struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.page_splits_per_batch metric with initial data.
func (m *metricSqlserverInstancePageSplitsPerBatch) init() {
	m.data.SetName("sqlserver.instance.page_splits_per_batch")
	m.data.SetDescription("Page splits per batch request")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstancePageSplitsPerBatch) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstancePageSplitsPerBatch) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstancePageSplitsPerBatch) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstancePageSplitsPerBatch(cfg MetricConfig) metricSqlserverInstancePageSplitsPerBatch {
	m := metricSqlserverInstancePageSplitsPerBatch{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceTargetMemoryKb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.target_memory_kb metric with initial data.
func (m *metricSqlserverInstanceTargetMemoryKb) init() {
	m.data.SetName("sqlserver.instance.target_memory_kb")
	m.data.SetDescription("Target server memory in KB")
	m.data.SetUnit("kb")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceTargetMemoryKb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceTargetMemoryKb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceTargetMemoryKb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceTargetMemoryKb(cfg MetricConfig) metricSqlserverInstanceTargetMemoryKb {
	m := metricSqlserverInstanceTargetMemoryKb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceTransactionsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.transactions_per_sec metric with initial data.
func (m *metricSqlserverInstanceTransactionsPerSec) init() {
	m.data.SetName("sqlserver.instance.transactions_per_sec")
	m.data.SetDescription("Transactions per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceTransactionsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceTransactionsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceTransactionsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceTransactionsPerSec(cfg MetricConfig) metricSqlserverInstanceTransactionsPerSec {
	m := metricSqlserverInstanceTransactionsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeBulkUpdate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.bulk_update metric with initial data.
func (m *metricSqlserverLockModeBulkUpdate) init() {
	m.data.SetName("sqlserver.lock.mode.bulk_update")
	m.data.SetDescription("Number of bulk update locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeBulkUpdate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeBulkUpdate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeBulkUpdate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeBulkUpdate(cfg MetricConfig) metricSqlserverLockModeBulkUpdate {
	m := metricSqlserverLockModeBulkUpdate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeExclusive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.exclusive metric with initial data.
func (m *metricSqlserverLockModeExclusive) init() {
	m.data.SetName("sqlserver.lock.mode.exclusive")
	m.data.SetDescription("Number of exclusive locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeExclusive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeExclusive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeExclusive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeExclusive(cfg MetricConfig) metricSqlserverLockModeExclusive {
	m := metricSqlserverLockModeExclusive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeIntent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.intent metric with initial data.
func (m *metricSqlserverLockModeIntent) init() {
	m.data.SetName("sqlserver.lock.mode.intent")
	m.data.SetDescription("Number of intent locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeIntent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeIntent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeIntent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeIntent(cfg MetricConfig) metricSqlserverLockModeIntent {
	m := metricSqlserverLockModeIntent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeSchema struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.schema metric with initial data.
func (m *metricSqlserverLockModeSchema) init() {
	m.data.SetName("sqlserver.lock.mode.schema")
	m.data.SetDescription("Number of schema locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeSchema) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeSchema) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeSchema) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeSchema(cfg MetricConfig) metricSqlserverLockModeSchema {
	m := metricSqlserverLockModeSchema{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeShared struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.shared metric with initial data.
func (m *metricSqlserverLockModeShared) init() {
	m.data.SetName("sqlserver.lock.mode.shared")
	m.data.SetDescription("Number of shared locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeShared) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeShared) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeShared) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeShared(cfg MetricConfig) metricSqlserverLockModeShared {
	m := metricSqlserverLockModeShared{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeSharedIntentExclusive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.shared_intent_exclusive metric with initial data.
func (m *metricSqlserverLockModeSharedIntentExclusive) init() {
	m.data.SetName("sqlserver.lock.mode.shared_intent_exclusive")
	m.data.SetDescription("Number of shared intent exclusive locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeSharedIntentExclusive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeSharedIntentExclusive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeSharedIntentExclusive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeSharedIntentExclusive(cfg MetricConfig) metricSqlserverLockModeSharedIntentExclusive {
	m := metricSqlserverLockModeSharedIntentExclusive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.total metric with initial data.
func (m *metricSqlserverLockModeTotal) init() {
	m.data.SetName("sqlserver.lock.mode.total")
	m.data.SetDescription("Total active locks by mode")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeTotal(cfg MetricConfig) metricSqlserverLockModeTotal {
	m := metricSqlserverLockModeTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeUpdate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.update metric with initial data.
func (m *metricSqlserverLockModeUpdate) init() {
	m.data.SetName("sqlserver.lock.mode.update")
	m.data.SetDescription("Number of update locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeUpdate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeUpdate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeUpdate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeUpdate(cfg MetricConfig) metricSqlserverLockModeUpdate {
	m := metricSqlserverLockModeUpdate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceAllocationUnit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.allocation_unit metric with initial data.
func (m *metricSqlserverLockResourceAllocationUnit) init() {
	m.data.SetName("sqlserver.lock.resource.allocation_unit")
	m.data.SetDescription("Number of allocation unit locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceAllocationUnit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceAllocationUnit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceAllocationUnit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceAllocationUnit(cfg MetricConfig) metricSqlserverLockResourceAllocationUnit {
	m := metricSqlserverLockResourceAllocationUnit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceApplication struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.application metric with initial data.
func (m *metricSqlserverLockResourceApplication) init() {
	m.data.SetName("sqlserver.lock.resource.application")
	m.data.SetDescription("Number of application locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceApplication) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceApplication) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceApplication) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceApplication(cfg MetricConfig) metricSqlserverLockResourceApplication {
	m := metricSqlserverLockResourceApplication{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceDatabaseLevel struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.database_level metric with initial data.
func (m *metricSqlserverLockResourceDatabaseLevel) init() {
	m.data.SetName("sqlserver.lock.resource.database_level")
	m.data.SetDescription("Number of database-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceDatabaseLevel) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceDatabaseLevel) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceDatabaseLevel) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceDatabaseLevel(cfg MetricConfig) metricSqlserverLockResourceDatabaseLevel {
	m := metricSqlserverLockResourceDatabaseLevel{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceExtent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.extent metric with initial data.
func (m *metricSqlserverLockResourceExtent) init() {
	m.data.SetName("sqlserver.lock.resource.extent")
	m.data.SetDescription("Number of extent-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceExtent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceExtent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceExtent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceExtent(cfg MetricConfig) metricSqlserverLockResourceExtent {
	m := metricSqlserverLockResourceExtent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceFile struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.file metric with initial data.
func (m *metricSqlserverLockResourceFile) init() {
	m.data.SetName("sqlserver.lock.resource.file")
	m.data.SetDescription("Number of file-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceFile) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceFile) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceFile) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceFile(cfg MetricConfig) metricSqlserverLockResourceFile {
	m := metricSqlserverLockResourceFile{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceHobt struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.hobt metric with initial data.
func (m *metricSqlserverLockResourceHobt) init() {
	m.data.SetName("sqlserver.lock.resource.hobt")
	m.data.SetDescription("Number of heap or B-tree locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceHobt) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceHobt) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceHobt) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceHobt(cfg MetricConfig) metricSqlserverLockResourceHobt {
	m := metricSqlserverLockResourceHobt{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceKey struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.key metric with initial data.
func (m *metricSqlserverLockResourceKey) init() {
	m.data.SetName("sqlserver.lock.resource.key")
	m.data.SetDescription("Number of key-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceKey) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceKey) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceKey) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceKey(cfg MetricConfig) metricSqlserverLockResourceKey {
	m := metricSqlserverLockResourceKey{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceMetadata struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.metadata metric with initial data.
func (m *metricSqlserverLockResourceMetadata) init() {
	m.data.SetName("sqlserver.lock.resource.metadata")
	m.data.SetDescription("Number of metadata locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceMetadata) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceMetadata) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceMetadata) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceMetadata(cfg MetricConfig) metricSqlserverLockResourceMetadata {
	m := metricSqlserverLockResourceMetadata{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourcePage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.page metric with initial data.
func (m *metricSqlserverLockResourcePage) init() {
	m.data.SetName("sqlserver.lock.resource.page")
	m.data.SetDescription("Number of page-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourcePage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourcePage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourcePage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourcePage(cfg MetricConfig) metricSqlserverLockResourcePage {
	m := metricSqlserverLockResourcePage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceRow struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.row metric with initial data.
func (m *metricSqlserverLockResourceRow) init() {
	m.data.SetName("sqlserver.lock.resource.row")
	m.data.SetDescription("Number of row-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceRow) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceRow) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceRow) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceRow(cfg MetricConfig) metricSqlserverLockResourceRow {
	m := metricSqlserverLockResourceRow{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceTable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.table metric with initial data.
func (m *metricSqlserverLockResourceTable) init() {
	m.data.SetName("sqlserver.lock.resource.table")
	m.data.SetDescription("Number of table-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceTable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceTable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceTable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceTable(cfg MetricConfig) metricSqlserverLockResourceTable {
	m := metricSqlserverLockResourceTable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.total metric with initial data.
func (m *metricSqlserverLockResourceTotal) init() {
	m.data.SetName("sqlserver.lock.resource.total")
	m.data.SetDescription("Total active locks in the database")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceTotal(cfg MetricConfig) metricSqlserverLockResourceTotal {
	m := metricSqlserverLockResourceTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockedObject struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.locked_object metric with initial data.
func (m *metricSqlserverLockedObject) init() {
	m.data.SetName("sqlserver.locked_object")
	m.data.SetDescription("Database object locked by a session")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockedObject) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockedObject) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockedObject) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockedObject(cfg MetricConfig) metricSqlserverLockedObject {
	m := metricSqlserverLockedObject{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverMemoryTarget struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.memory.target metric with initial data.
func (m *metricSqlserverMemoryTarget) init() {
	m.data.SetName("sqlserver.memory.target")
	m.data.SetDescription("Target server memory in KB")
	m.data.SetUnit("kBy")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverMemoryTarget) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverMemoryTarget) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverMemoryTarget) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverMemoryTarget(cfg MetricConfig) metricSqlserverMemoryTarget {
	m := metricSqlserverMemoryTarget{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverMemoryTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.memory.total metric with initial data.
func (m *metricSqlserverMemoryTotal) init() {
	m.data.SetName("sqlserver.memory.total")
	m.data.SetDescription("Total server memory in KB")
	m.data.SetUnit("kBy")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverMemoryTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverMemoryTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverMemoryTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverMemoryTotal(cfg MetricConfig) metricSqlserverMemoryTotal {
	m := metricSqlserverMemoryTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanAvgElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.avg_elapsed_time_ms metric with initial data.
func (m *metricSqlserverPlanAvgElapsedTimeMs) init() {
	m.data.SetName("sqlserver.plan.avg_elapsed_time_ms")
	m.data.SetDescription("Average elapsed time per execution of this plan (historical)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverPlanAvgElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_hash", queryPlanHashAttributeValue)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanAvgElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanAvgElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanAvgElapsedTimeMs(cfg MetricConfig) metricSqlserverPlanAvgElapsedTimeMs {
	m := metricSqlserverPlanAvgElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanAvgLogicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.avg_logical_reads metric with initial data.
func (m *metricSqlserverPlanAvgLogicalReads) init() {
	m.data.SetName("sqlserver.plan.avg_logical_reads")
	m.data.SetDescription("Average logical reads per execution of this plan (historical)")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverPlanAvgLogicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_hash", queryPlanHashAttributeValue)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanAvgLogicalReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanAvgLogicalReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanAvgLogicalReads(cfg MetricConfig) metricSqlserverPlanAvgLogicalReads {
	m := metricSqlserverPlanAvgLogicalReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanAvgLogicalWrites struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.avg_logical_writes metric with initial data.
func (m *metricSqlserverPlanAvgLogicalWrites) init() {
	m.data.SetName("sqlserver.plan.avg_logical_writes")
	m.data.SetDescription("Average logical writes per execution of this plan (historical)")
	m.data.SetUnit("{writes}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverPlanAvgLogicalWrites) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_hash", queryPlanHashAttributeValue)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanAvgLogicalWrites) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanAvgLogicalWrites) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanAvgLogicalWrites(cfg MetricConfig) metricSqlserverPlanAvgLogicalWrites {
	m := metricSqlserverPlanAvgLogicalWrites{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanAvgWorkerTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.avg_worker_time_ms metric with initial data.
func (m *metricSqlserverPlanAvgWorkerTimeMs) init() {
	m.data.SetName("sqlserver.plan.avg_worker_time_ms")
	m.data.SetDescription("Average CPU time per execution of this plan (historical)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverPlanAvgWorkerTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_hash", queryPlanHashAttributeValue)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanAvgWorkerTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanAvgWorkerTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanAvgWorkerTimeMs(cfg MetricConfig) metricSqlserverPlanAvgWorkerTimeMs {
	m := metricSqlserverPlanAvgWorkerTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanExecutionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.execution_count metric with initial data.
func (m *metricSqlserverPlanExecutionCount) init() {
	m.data.SetName("sqlserver.plan.execution_count")
	m.data.SetDescription("Total number of executions for this execution plan (historical)")
	m.data.SetUnit("{executions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverPlanExecutionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_hash", queryPlanHashAttributeValue)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanExecutionCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanExecutionCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanExecutionCount(cfg MetricConfig) metricSqlserverPlanExecutionCount {
	m := metricSqlserverPlanExecutionCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanLastDop struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.last_dop metric with initial data.
func (m *metricSqlserverPlanLastDop) init() {
	m.data.SetName("sqlserver.plan.last_dop")
	m.data.SetDescription("Degree of parallelism for last execution of this plan")
	m.data.SetUnit("{threads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverPlanLastDop) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_hash", queryPlanHashAttributeValue)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanLastDop) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanLastDop) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanLastDop(cfg MetricConfig) metricSqlserverPlanLastDop {
	m := metricSqlserverPlanLastDop{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanLastGrantKb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.last_grant_kb metric with initial data.
func (m *metricSqlserverPlanLastGrantKb) init() {
	m.data.SetName("sqlserver.plan.last_grant_kb")
	m.data.SetDescription("Memory grant for last execution of this plan")
	m.data.SetUnit("KB")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverPlanLastGrantKb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_hash", queryPlanHashAttributeValue)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanLastGrantKb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanLastGrantKb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanLastGrantKb(cfg MetricConfig) metricSqlserverPlanLastGrantKb {
	m := metricSqlserverPlanLastGrantKb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanLastSpills struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.last_spills metric with initial data.
func (m *metricSqlserverPlanLastSpills) init() {
	m.data.SetName("sqlserver.plan.last_spills")
	m.data.SetDescription("TempDB spills for last execution of this plan")
	m.data.SetUnit("{pages}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverPlanLastSpills) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_hash", queryPlanHashAttributeValue)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanLastSpills) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanLastSpills) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanLastSpills(cfg MetricConfig) metricSqlserverPlanLastSpills {
	m := metricSqlserverPlanLastSpills{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanMaxElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.max_elapsed_time_ms metric with initial data.
func (m *metricSqlserverPlanMaxElapsedTimeMs) init() {
	m.data.SetName("sqlserver.plan.max_elapsed_time_ms")
	m.data.SetDescription("Maximum elapsed time for this plan (historical)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverPlanMaxElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_hash", queryPlanHashAttributeValue)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanMaxElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanMaxElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanMaxElapsedTimeMs(cfg MetricConfig) metricSqlserverPlanMaxElapsedTimeMs {
	m := metricSqlserverPlanMaxElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanMinElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.min_elapsed_time_ms metric with initial data.
func (m *metricSqlserverPlanMinElapsedTimeMs) init() {
	m.data.SetName("sqlserver.plan.min_elapsed_time_ms")
	m.data.SetDescription("Minimum elapsed time for this plan (historical)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverPlanMinElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_hash", queryPlanHashAttributeValue)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanMinElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanMinElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanMinElapsedTimeMs(cfg MetricConfig) metricSqlserverPlanMinElapsedTimeMs {
	m := metricSqlserverPlanMinElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanTotalElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.total_elapsed_time_ms metric with initial data.
func (m *metricSqlserverPlanTotalElapsedTimeMs) init() {
	m.data.SetName("sqlserver.plan.total_elapsed_time_ms")
	m.data.SetDescription("Total elapsed time across all executions of this plan (historical)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverPlanTotalElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_hash", queryPlanHashAttributeValue)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanTotalElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanTotalElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanTotalElapsedTimeMs(cfg MetricConfig) metricSqlserverPlanTotalElapsedTimeMs {
	m := metricSqlserverPlanTotalElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSecurityServerPrincipalsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.security.server_principals_count metric with initial data.
func (m *metricSqlserverSecurityServerPrincipalsCount) init() {
	m.data.SetName("sqlserver.security.server_principals_count")
	m.data.SetDescription("Total number of server principals (logins)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSecurityServerPrincipalsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, metricTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("metric.type", metricTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSecurityServerPrincipalsCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSecurityServerPrincipalsCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSecurityServerPrincipalsCount(cfg MetricConfig) metricSqlserverSecurityServerPrincipalsCount {
	m := metricSqlserverSecurityServerPrincipalsCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSecurityServerRoleMembersCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.security.server_role_members_count metric with initial data.
func (m *metricSqlserverSecurityServerRoleMembersCount) init() {
	m.data.SetName("sqlserver.security.server_role_members_count")
	m.data.SetDescription("Total number of server role members")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSecurityServerRoleMembersCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, metricTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("metric.type", metricTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSecurityServerRoleMembersCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSecurityServerRoleMembersCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSecurityServerRoleMembersCount(cfg MetricConfig) metricSqlserverSecurityServerRoleMembersCount {
	m := metricSqlserverSecurityServerRoleMembersCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryAvgDiskReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.avg_disk_reads metric with initial data.
func (m *metricSqlserverSlowqueryAvgDiskReads) init() {
	m.data.SetName("sqlserver.slowquery.avg_disk_reads")
	m.data.SetDescription("Average disk reads for slow query")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryAvgDiskReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryAvgDiskReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryAvgDiskReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryAvgDiskReads(cfg MetricConfig) metricSqlserverSlowqueryAvgDiskReads {
	m := metricSqlserverSlowqueryAvgDiskReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryAvgDiskWrites struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.avg_disk_writes metric with initial data.
func (m *metricSqlserverSlowqueryAvgDiskWrites) init() {
	m.data.SetName("sqlserver.slowquery.avg_disk_writes")
	m.data.SetDescription("Average disk writes for slow query")
	m.data.SetUnit("{writes}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryAvgDiskWrites) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryAvgDiskWrites) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryAvgDiskWrites) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryAvgDiskWrites(cfg MetricConfig) metricSqlserverSlowqueryAvgDiskWrites {
	m := metricSqlserverSlowqueryAvgDiskWrites{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryAvgRowsProcessed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.avg_rows_processed metric with initial data.
func (m *metricSqlserverSlowqueryAvgRowsProcessed) init() {
	m.data.SetName("sqlserver.slowquery.avg_rows_processed")
	m.data.SetDescription("Average rows processed (returned) per execution for slow query")
	m.data.SetUnit("{rows}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryAvgRowsProcessed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryAvgRowsProcessed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryAvgRowsProcessed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryAvgRowsProcessed(cfg MetricConfig) metricSqlserverSlowqueryAvgRowsProcessed {
	m := metricSqlserverSlowqueryAvgRowsProcessed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryHistoricalAvgCPUTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.historical_avg_cpu_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryHistoricalAvgCPUTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.historical_avg_cpu_time_ms")
	m.data.SetDescription("Historical average CPU time in milliseconds (cumulative since plan cached)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryHistoricalAvgCPUTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryHistoricalAvgCPUTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryHistoricalAvgCPUTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryHistoricalAvgCPUTimeMs(cfg MetricConfig) metricSqlserverSlowqueryHistoricalAvgCPUTimeMs {
	m := metricSqlserverSlowqueryHistoricalAvgCPUTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryHistoricalAvgElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.historical_avg_elapsed_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryHistoricalAvgElapsedTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.historical_avg_elapsed_time_ms")
	m.data.SetDescription("Historical average elapsed time in milliseconds (cumulative since plan cached)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryHistoricalAvgElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string, collectionTimestampAttributeValue string, lastExecutionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
	dp.Attributes().PutStr("last_execution_timestamp", lastExecutionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryHistoricalAvgElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryHistoricalAvgElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryHistoricalAvgElapsedTimeMs(cfg MetricConfig) metricSqlserverSlowqueryHistoricalAvgElapsedTimeMs {
	m := metricSqlserverSlowqueryHistoricalAvgElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryHistoricalExecutionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.historical_execution_count metric with initial data.
func (m *metricSqlserverSlowqueryHistoricalExecutionCount) init() {
	m.data.SetName("sqlserver.slowquery.historical_execution_count")
	m.data.SetDescription("Historical execution count (cumulative since plan cached)")
	m.data.SetUnit("{executions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryHistoricalExecutionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryHistoricalExecutionCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryHistoricalExecutionCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryHistoricalExecutionCount(cfg MetricConfig) metricSqlserverSlowqueryHistoricalExecutionCount {
	m := metricSqlserverSlowqueryHistoricalExecutionCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalAvgElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_avg_elapsed_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryIntervalAvgElapsedTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.interval_avg_elapsed_time_ms")
	m.data.SetDescription("Interval average elapsed time in milliseconds (delta for this collection interval)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalAvgElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalAvgElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalAvgElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalAvgElapsedTimeMs(cfg MetricConfig) metricSqlserverSlowqueryIntervalAvgElapsedTimeMs {
	m := metricSqlserverSlowqueryIntervalAvgElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalExecutionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_execution_count metric with initial data.
func (m *metricSqlserverSlowqueryIntervalExecutionCount) init() {
	m.data.SetName("sqlserver.slowquery.interval_execution_count")
	m.data.SetDescription("Interval execution count (delta for this collection interval)")
	m.data.SetUnit("{executions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalExecutionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalExecutionCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalExecutionCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalExecutionCount(cfg MetricConfig) metricSqlserverSlowqueryIntervalExecutionCount {
	m := metricSqlserverSlowqueryIntervalExecutionCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryLastDop struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.last_dop metric with initial data.
func (m *metricSqlserverSlowqueryLastDop) init() {
	m.data.SetName("sqlserver.slowquery.last_dop")
	m.data.SetDescription("Last degree of parallelism")
	m.data.SetUnit("{threads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryLastDop) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryLastDop) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryLastDop) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryLastDop(cfg MetricConfig) metricSqlserverSlowqueryLastDop {
	m := metricSqlserverSlowqueryLastDop{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryLastElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.last_elapsed_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryLastElapsedTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.last_elapsed_time_ms")
	m.data.SetDescription("Last elapsed time in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryLastElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryLastElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryLastElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryLastElapsedTimeMs(cfg MetricConfig) metricSqlserverSlowqueryLastElapsedTimeMs {
	m := metricSqlserverSlowqueryLastElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryLastGrantKb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.last_grant_kb metric with initial data.
func (m *metricSqlserverSlowqueryLastGrantKb) init() {
	m.data.SetName("sqlserver.slowquery.last_grant_kb")
	m.data.SetDescription("Last memory grant in KB")
	m.data.SetUnit("KB")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryLastGrantKb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryLastGrantKb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryLastGrantKb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryLastGrantKb(cfg MetricConfig) metricSqlserverSlowqueryLastGrantKb {
	m := metricSqlserverSlowqueryLastGrantKb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryLastSpills struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.last_spills metric with initial data.
func (m *metricSqlserverSlowqueryLastSpills) init() {
	m.data.SetName("sqlserver.slowquery.last_spills")
	m.data.SetDescription("Last TempDB spills count")
	m.data.SetUnit("{pages}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryLastSpills) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryLastSpills) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryLastSpills) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryLastSpills(cfg MetricConfig) metricSqlserverSlowqueryLastSpills {
	m := metricSqlserverSlowqueryLastSpills{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryLastUsedGrantKb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.last_used_grant_kb metric with initial data.
func (m *metricSqlserverSlowqueryLastUsedGrantKb) init() {
	m.data.SetName("sqlserver.slowquery.last_used_grant_kb")
	m.data.SetDescription("Last used memory grant in KB")
	m.data.SetUnit("KB")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryLastUsedGrantKb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryLastUsedGrantKb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryLastUsedGrantKb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryLastUsedGrantKb(cfg MetricConfig) metricSqlserverSlowqueryLastUsedGrantKb {
	m := metricSqlserverSlowqueryLastUsedGrantKb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryMaxElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.max_elapsed_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryMaxElapsedTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.max_elapsed_time_ms")
	m.data.SetDescription("Maximum elapsed time in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryMaxElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryMaxElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryMaxElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryMaxElapsedTimeMs(cfg MetricConfig) metricSqlserverSlowqueryMaxElapsedTimeMs {
	m := metricSqlserverSlowqueryMaxElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryMaxSpills struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.max_spills metric with initial data.
func (m *metricSqlserverSlowqueryMaxSpills) init() {
	m.data.SetName("sqlserver.slowquery.max_spills")
	m.data.SetDescription("Maximum TempDB spills count")
	m.data.SetUnit("{pages}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryMaxSpills) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryMaxSpills) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryMaxSpills) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryMaxSpills(cfg MetricConfig) metricSqlserverSlowqueryMaxSpills {
	m := metricSqlserverSlowqueryMaxSpills{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryMinElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.min_elapsed_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryMinElapsedTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.min_elapsed_time_ms")
	m.data.SetDescription("Minimum elapsed time in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryMinElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryMinElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryMinElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryMinElapsedTimeMs(cfg MetricConfig) metricSqlserverSlowqueryMinElapsedTimeMs {
	m := metricSqlserverSlowqueryMinElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryQueryText struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.query_text metric with initial data.
func (m *metricSqlserverSlowqueryQueryText) init() {
	m.data.SetName("sqlserver.slowquery.query_text")
	m.data.SetDescription("Query text for slow query")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryQueryText) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string, querySignatureAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("statement_type", statementTypeAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("query_signature", querySignatureAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryQueryText) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryQueryText) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryQueryText(cfg MetricConfig) metricSqlserverSlowqueryQueryText {
	m := metricSqlserverSlowqueryQueryText{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsConnections struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.connections metric with initial data.
func (m *metricSqlserverStatsConnections) init() {
	m.data.SetName("sqlserver.stats.connections")
	m.data.SetDescription("Current user connections")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsConnections) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsConnections) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsConnections) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsConnections(cfg MetricConfig) metricSqlserverStatsConnections {
	m := metricSqlserverStatsConnections{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsDeadlocksPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.deadlocks_per_sec metric with initial data.
func (m *metricSqlserverStatsDeadlocksPerSec) init() {
	m.data.SetName("sqlserver.stats.deadlocks_per_sec")
	m.data.SetDescription("Deadlocks per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsDeadlocksPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsDeadlocksPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsDeadlocksPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsDeadlocksPerSec(cfg MetricConfig) metricSqlserverStatsDeadlocksPerSec {
	m := metricSqlserverStatsDeadlocksPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsKillConnectionErrorsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.kill_connection_errors_per_sec metric with initial data.
func (m *metricSqlserverStatsKillConnectionErrorsPerSec) init() {
	m.data.SetName("sqlserver.stats.kill_connection_errors_per_sec")
	m.data.SetDescription("Kill connection errors per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsKillConnectionErrorsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsKillConnectionErrorsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsKillConnectionErrorsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsKillConnectionErrorsPerSec(cfg MetricConfig) metricSqlserverStatsKillConnectionErrorsPerSec {
	m := metricSqlserverStatsKillConnectionErrorsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsLockWaitsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.lock_waits_per_sec metric with initial data.
func (m *metricSqlserverStatsLockWaitsPerSec) init() {
	m.data.SetName("sqlserver.stats.lock_waits_per_sec")
	m.data.SetDescription("Lock waits per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsLockWaitsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsLockWaitsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsLockWaitsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsLockWaitsPerSec(cfg MetricConfig) metricSqlserverStatsLockWaitsPerSec {
	m := metricSqlserverStatsLockWaitsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsSQLCompilationsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.sql_compilations_per_sec metric with initial data.
func (m *metricSqlserverStatsSQLCompilationsPerSec) init() {
	m.data.SetName("sqlserver.stats.sql_compilations_per_sec")
	m.data.SetDescription("SQL compilations per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsSQLCompilationsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsSQLCompilationsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsSQLCompilationsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsSQLCompilationsPerSec(cfg MetricConfig) metricSqlserverStatsSQLCompilationsPerSec {
	m := metricSqlserverStatsSQLCompilationsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsSQLRecompilationsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.sql_recompilations_per_sec metric with initial data.
func (m *metricSqlserverStatsSQLRecompilationsPerSec) init() {
	m.data.SetName("sqlserver.stats.sql_recompilations_per_sec")
	m.data.SetDescription("SQL recompilations per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsSQLRecompilationsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsSQLRecompilationsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsSQLRecompilationsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsSQLRecompilationsPerSec(cfg MetricConfig) metricSqlserverStatsSQLRecompilationsPerSec {
	m := metricSqlserverStatsSQLRecompilationsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsUserErrorsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.user_errors_per_sec metric with initial data.
func (m *metricSqlserverStatsUserErrorsPerSec) init() {
	m.data.SetName("sqlserver.stats.user_errors_per_sec")
	m.data.SetDescription("User errors per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsUserErrorsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsUserErrorsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsUserErrorsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsUserErrorsPerSec(cfg MetricConfig) metricSqlserverStatsUserErrorsPerSec {
	m := metricSqlserverStatsUserErrorsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbAllocationWaitsMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.allocation_waits_ms metric with initial data.
func (m *metricSqlserverTempdbAllocationWaitsMs) init() {
	m.data.SetName("sqlserver.tempdb.allocation_waits_ms")
	m.data.SetDescription("Total allocation-related wait time (GAM, SGAM, PFS)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverTempdbAllocationWaitsMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("tempdb_health_status", tempdbHealthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbAllocationWaitsMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbAllocationWaitsMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbAllocationWaitsMs(cfg MetricConfig) metricSqlserverTempdbAllocationWaitsMs {
	m := metricSqlserverTempdbAllocationWaitsMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbCurrentWaiters struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.current_waiters metric with initial data.
func (m *metricSqlserverTempdbCurrentWaiters) init() {
	m.data.SetName("sqlserver.tempdb.current_waiters")
	m.data.SetDescription("Number of tasks currently waiting on TempDB page latches")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverTempdbCurrentWaiters) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("tempdb_health_status", tempdbHealthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbCurrentWaiters) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbCurrentWaiters) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbCurrentWaiters(cfg MetricConfig) metricSqlserverTempdbCurrentWaiters {
	m := metricSqlserverTempdbCurrentWaiters{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbDataFileCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.data_file_count metric with initial data.
func (m *metricSqlserverTempdbDataFileCount) init() {
	m.data.SetName("sqlserver.tempdb.data_file_count")
	m.data.SetDescription("Number of TempDB data files")
	m.data.SetUnit("{files}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverTempdbDataFileCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("tempdb_health_status", tempdbHealthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbDataFileCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbDataFileCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbDataFileCount(cfg MetricConfig) metricSqlserverTempdbDataFileCount {
	m := metricSqlserverTempdbDataFileCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbPagelatchWaitsMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.pagelatch_waits_ms metric with initial data.
func (m *metricSqlserverTempdbPagelatchWaitsMs) init() {
	m.data.SetName("sqlserver.tempdb.pagelatch_waits_ms")
	m.data.SetDescription("Total page latch wait time since server start")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverTempdbPagelatchWaitsMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("tempdb_health_status", tempdbHealthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbPagelatchWaitsMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbPagelatchWaitsMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbPagelatchWaitsMs(cfg MetricConfig) metricSqlserverTempdbPagelatchWaitsMs {
	m := metricSqlserverTempdbPagelatchWaitsMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbTotalSizeMb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.total_size_mb metric with initial data.
func (m *metricSqlserverTempdbTotalSizeMb) init() {
	m.data.SetName("sqlserver.tempdb.total_size_mb")
	m.data.SetDescription("Total size of TempDB data files")
	m.data.SetUnit("MB")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverTempdbTotalSizeMb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("tempdb_health_status", tempdbHealthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbTotalSizeMb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbTotalSizeMb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbTotalSizeMb(cfg MetricConfig) metricSqlserverTempdbTotalSizeMb {
	m := metricSqlserverTempdbTotalSizeMb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolCurrentTasks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.current_tasks metric with initial data.
func (m *metricSqlserverThreadpoolCurrentTasks) init() {
	m.data.SetName("sqlserver.threadpool.current_tasks")
	m.data.SetDescription("Total tasks currently assigned to schedulers")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolCurrentTasks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolCurrentTasks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolCurrentTasks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolCurrentTasks(cfg MetricConfig) metricSqlserverThreadpoolCurrentTasks {
	m := metricSqlserverThreadpoolCurrentTasks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolMaxWorkers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.max_workers metric with initial data.
func (m *metricSqlserverThreadpoolMaxWorkers) init() {
	m.data.SetName("sqlserver.threadpool.max_workers")
	m.data.SetDescription("Maximum configured worker threads")
	m.data.SetUnit("{threads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolMaxWorkers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolMaxWorkers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolMaxWorkers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolMaxWorkers(cfg MetricConfig) metricSqlserverThreadpoolMaxWorkers {
	m := metricSqlserverThreadpoolMaxWorkers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolRunnableTasks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.runnable_tasks metric with initial data.
func (m *metricSqlserverThreadpoolRunnableTasks) init() {
	m.data.SetName("sqlserver.threadpool.runnable_tasks")
	m.data.SetDescription("Tasks ready to run but waiting for CPU time")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolRunnableTasks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolRunnableTasks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolRunnableTasks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolRunnableTasks(cfg MetricConfig) metricSqlserverThreadpoolRunnableTasks {
	m := metricSqlserverThreadpoolRunnableTasks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolRunningWorkers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.running_workers metric with initial data.
func (m *metricSqlserverThreadpoolRunningWorkers) init() {
	m.data.SetName("sqlserver.threadpool.running_workers")
	m.data.SetDescription("Number of worker threads currently running")
	m.data.SetUnit("{threads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolRunningWorkers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolRunningWorkers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolRunningWorkers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolRunningWorkers(cfg MetricConfig) metricSqlserverThreadpoolRunningWorkers {
	m := metricSqlserverThreadpoolRunningWorkers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolUtilizationPercent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.utilization_percent metric with initial data.
func (m *metricSqlserverThreadpoolUtilizationPercent) init() {
	m.data.SetName("sqlserver.threadpool.utilization_percent")
	m.data.SetDescription("Percentage of worker threads currently in use")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolUtilizationPercent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolUtilizationPercent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolUtilizationPercent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolUtilizationPercent(cfg MetricConfig) metricSqlserverThreadpoolUtilizationPercent {
	m := metricSqlserverThreadpoolUtilizationPercent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolWaitingTasks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.waiting_tasks metric with initial data.
func (m *metricSqlserverThreadpoolWaitingTasks) init() {
	m.data.SetName("sqlserver.threadpool.waiting_tasks")
	m.data.SetDescription("Number of tasks currently waiting for threadpool worker threads")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolWaitingTasks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolWaitingTasks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolWaitingTasks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolWaitingTasks(cfg MetricConfig) metricSqlserverThreadpoolWaitingTasks {
	m := metricSqlserverThreadpoolWaitingTasks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolWorkQueueCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.work_queue_count metric with initial data.
func (m *metricSqlserverThreadpoolWorkQueueCount) init() {
	m.data.SetName("sqlserver.threadpool.work_queue_count")
	m.data.SetDescription("Total number of tasks in scheduler work queues")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolWorkQueueCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolWorkQueueCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolWorkQueueCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolWorkQueueCount(cfg MetricConfig) metricSqlserverThreadpoolWorkQueueCount {
	m := metricSqlserverThreadpoolWorkQueueCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationChurnRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.churn_rate metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationChurnRate) init() {
	m.data.SetName("sqlserver.user_connections.authentication.churn_rate")
	m.data.SetDescription("Connection churn rate (logout/login ratio as percentage)")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationChurnRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationChurnRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationChurnRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationChurnRate(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationChurnRate {
	m := metricSqlserverUserConnectionsAuthenticationChurnRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationFailedLoginEvents struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.failed_login_events metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationFailedLoginEvents) init() {
	m.data.SetName("sqlserver.user_connections.authentication.failed_login_events")
	m.data.SetDescription("Count of failed login events processed")
	m.data.SetUnit("{events}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverUserConnectionsAuthenticationFailedLoginEvents) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, eventTypeAttributeValue string, descriptionAttributeValue string, startTimeAttributeValue string, clientIPAttributeValue string, logDateAttributeValue string, processInfoAttributeValue string, errorTextAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("event_type", eventTypeAttributeValue)
	dp.Attributes().PutStr("description", descriptionAttributeValue)
	dp.Attributes().PutStr("start_time", startTimeAttributeValue)
	dp.Attributes().PutStr("client_ip", clientIPAttributeValue)
	dp.Attributes().PutStr("log_date", logDateAttributeValue)
	dp.Attributes().PutStr("process_info", processInfoAttributeValue)
	dp.Attributes().PutStr("error_text", errorTextAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationFailedLoginEvents) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationFailedLoginEvents) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationFailedLoginEvents(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationFailedLoginEvents {
	m := metricSqlserverUserConnectionsAuthenticationFailedLoginEvents{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationLoginsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.logins_per_sec metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationLoginsPerSec) init() {
	m.data.SetName("sqlserver.user_connections.authentication.logins_per_sec")
	m.data.SetDescription("Current login rate per second")
	m.data.SetUnit("{logins}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationLoginsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationLoginsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationLoginsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationLoginsPerSec(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationLoginsPerSec {
	m := metricSqlserverUserConnectionsAuthenticationLoginsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationLogoutsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.logouts_per_sec metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationLogoutsPerSec) init() {
	m.data.SetName("sqlserver.user_connections.authentication.logouts_per_sec")
	m.data.SetDescription("Current logout rate per second")
	m.data.SetUnit("{logouts}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationLogoutsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationLogoutsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationLogoutsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationLogoutsPerSec(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationLogoutsPerSec {
	m := metricSqlserverUserConnectionsAuthenticationLogoutsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.rate metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationRate) init() {
	m.data.SetName("sqlserver.user_connections.authentication.rate")
	m.data.SetDescription("Login or logout rate per second from performance counters")
	m.data.SetUnit("{events}/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverUserConnectionsAuthenticationRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, counterNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("counter_name", counterNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationRate(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationRate {
	m := metricSqlserverUserConnectionsAuthenticationRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationRecentFailedLogins struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.recent_failed_logins metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationRecentFailedLogins) init() {
	m.data.SetName("sqlserver.user_connections.authentication.recent_failed_logins")
	m.data.SetDescription("Count of failed logins in the last hour")
	m.data.SetUnit("{attempts}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationRecentFailedLogins) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationRecentFailedLogins) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationRecentFailedLogins) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationRecentFailedLogins(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationRecentFailedLogins {
	m := metricSqlserverUserConnectionsAuthenticationRecentFailedLogins{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationTotalActivity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.total_activity metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationTotalActivity) init() {
	m.data.SetName("sqlserver.user_connections.authentication.total_activity")
	m.data.SetDescription("Sum of logins and logouts per second")
	m.data.SetUnit("{events}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationTotalActivity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationTotalActivity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationTotalActivity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationTotalActivity(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationTotalActivity {
	m := metricSqlserverUserConnectionsAuthenticationTotalActivity{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationTotalFailedLogins struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.total_failed_logins metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationTotalFailedLogins) init() {
	m.data.SetName("sqlserver.user_connections.authentication.total_failed_logins")
	m.data.SetDescription("Total count of failed login attempts in current error log")
	m.data.SetUnit("{attempts}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationTotalFailedLogins) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationTotalFailedLogins) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationTotalFailedLogins) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationTotalFailedLogins(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationTotalFailedLogins {
	m := metricSqlserverUserConnectionsAuthenticationTotalFailedLogins{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationUniqueFailedSources struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.unique_failed_sources metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedSources) init() {
	m.data.SetName("sqlserver.user_connections.authentication.unique_failed_sources")
	m.data.SetDescription("Count of distinct source IPs with failed logins")
	m.data.SetUnit("{sources}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedSources) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedSources) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedSources) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationUniqueFailedSources(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationUniqueFailedSources {
	m := metricSqlserverUserConnectionsAuthenticationUniqueFailedSources{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.unique_failed_users metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers) init() {
	m.data.SetName("sqlserver.user_connections.authentication.unique_failed_users")
	m.data.SetDescription("Count of distinct usernames with failed logins")
	m.data.SetUnit("{users}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationUniqueFailedUsers(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers {
	m := metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsClientCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.client.count metric with initial data.
func (m *metricSqlserverUserConnectionsClientCount) init() {
	m.data.SetName("sqlserver.user_connections.client.count")
	m.data.SetDescription("Number of connections grouped by client host and program")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverUserConnectionsClientCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostNameAttributeValue string, programNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("host_name", hostNameAttributeValue)
	dp.Attributes().PutStr("program_name", programNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsClientCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsClientCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsClientCount(cfg MetricConfig) metricSqlserverUserConnectionsClientCount {
	m := metricSqlserverUserConnectionsClientCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsClientHostsMultiProgram struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.client.hosts_multi_program metric with initial data.
func (m *metricSqlserverUserConnectionsClientHostsMultiProgram) init() {
	m.data.SetName("sqlserver.user_connections.client.hosts_multi_program")
	m.data.SetDescription("Count of hosts running multiple different programs")
	m.data.SetUnit("{hosts}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsClientHostsMultiProgram) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsClientHostsMultiProgram) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsClientHostsMultiProgram) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsClientHostsMultiProgram(cfg MetricConfig) metricSqlserverUserConnectionsClientHostsMultiProgram {
	m := metricSqlserverUserConnectionsClientHostsMultiProgram{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsClientProgramsMultiHost struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.client.programs_multi_host metric with initial data.
func (m *metricSqlserverUserConnectionsClientProgramsMultiHost) init() {
	m.data.SetName("sqlserver.user_connections.client.programs_multi_host")
	m.data.SetDescription("Count of programs connecting from multiple hosts")
	m.data.SetUnit("{programs}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsClientProgramsMultiHost) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsClientProgramsMultiHost) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsClientProgramsMultiHost) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsClientProgramsMultiHost(cfg MetricConfig) metricSqlserverUserConnectionsClientProgramsMultiHost {
	m := metricSqlserverUserConnectionsClientProgramsMultiHost{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsClientTopHostConnections struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.client.top_host_connections metric with initial data.
func (m *metricSqlserverUserConnectionsClientTopHostConnections) init() {
	m.data.SetName("sqlserver.user_connections.client.top_host_connections")
	m.data.SetDescription("Highest number of connections from a single host")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsClientTopHostConnections) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsClientTopHostConnections) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsClientTopHostConnections) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsClientTopHostConnections(cfg MetricConfig) metricSqlserverUserConnectionsClientTopHostConnections {
	m := metricSqlserverUserConnectionsClientTopHostConnections{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsClientTopProgramConnections struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.client.top_program_connections metric with initial data.
func (m *metricSqlserverUserConnectionsClientTopProgramConnections) init() {
	m.data.SetName("sqlserver.user_connections.client.top_program_connections")
	m.data.SetDescription("Highest number of connections from a single program")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsClientTopProgramConnections) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsClientTopProgramConnections) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsClientTopProgramConnections) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsClientTopProgramConnections(cfg MetricConfig) metricSqlserverUserConnectionsClientTopProgramConnections {
	m := metricSqlserverUserConnectionsClientTopProgramConnections{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsClientUniqueHosts struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.client.unique_hosts metric with initial data.
func (m *metricSqlserverUserConnectionsClientUniqueHosts) init() {
	m.data.SetName("sqlserver.user_connections.client.unique_hosts")
	m.data.SetDescription("Count of unique client hosts with active connections")
	m.data.SetUnit("{hosts}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsClientUniqueHosts) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsClientUniqueHosts) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsClientUniqueHosts) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsClientUniqueHosts(cfg MetricConfig) metricSqlserverUserConnectionsClientUniqueHosts {
	m := metricSqlserverUserConnectionsClientUniqueHosts{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsClientUniquePrograms struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.client.unique_programs metric with initial data.
func (m *metricSqlserverUserConnectionsClientUniquePrograms) init() {
	m.data.SetName("sqlserver.user_connections.client.unique_programs")
	m.data.SetDescription("Count of unique programs with active connections")
	m.data.SetUnit("{programs}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsClientUniquePrograms) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsClientUniquePrograms) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsClientUniquePrograms) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsClientUniquePrograms(cfg MetricConfig) metricSqlserverUserConnectionsClientUniquePrograms {
	m := metricSqlserverUserConnectionsClientUniquePrograms{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsDormant struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.dormant metric with initial data.
func (m *metricSqlserverUserConnectionsDormant) init() {
	m.data.SetName("sqlserver.user_connections.dormant")
	m.data.SetDescription("Number of dormant user connections")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsDormant) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsDormant) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsDormant) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsDormant(cfg MetricConfig) metricSqlserverUserConnectionsDormant {
	m := metricSqlserverUserConnectionsDormant{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsRunnable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.runnable metric with initial data.
func (m *metricSqlserverUserConnectionsRunnable) init() {
	m.data.SetName("sqlserver.user_connections.runnable")
	m.data.SetDescription("Number of runnable user connections")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsRunnable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsRunnable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsRunnable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsRunnable(cfg MetricConfig) metricSqlserverUserConnectionsRunnable {
	m := metricSqlserverUserConnectionsRunnable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsRunning struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.running metric with initial data.
func (m *metricSqlserverUserConnectionsRunning) init() {
	m.data.SetName("sqlserver.user_connections.running")
	m.data.SetDescription("Number of running user connections")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsRunning) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsRunning) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsRunning) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsRunning(cfg MetricConfig) metricSqlserverUserConnectionsRunning {
	m := metricSqlserverUserConnectionsRunning{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsSleeping struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.sleeping metric with initial data.
func (m *metricSqlserverUserConnectionsSleeping) init() {
	m.data.SetName("sqlserver.user_connections.sleeping")
	m.data.SetDescription("Number of sleeping user connections")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsSleeping) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsSleeping) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsSleeping) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsSleeping(cfg MetricConfig) metricSqlserverUserConnectionsSleeping {
	m := metricSqlserverUserConnectionsSleeping{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsStatusCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.status.count metric with initial data.
func (m *metricSqlserverUserConnectionsStatusCount) init() {
	m.data.SetName("sqlserver.user_connections.status.count")
	m.data.SetDescription("Number of user sessions by connection status")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverUserConnectionsStatusCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, statusAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("status", statusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsStatusCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsStatusCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsStatusCount(cfg MetricConfig) metricSqlserverUserConnectionsStatusCount {
	m := metricSqlserverUserConnectionsStatusCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsSuspended struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.suspended metric with initial data.
func (m *metricSqlserverUserConnectionsSuspended) init() {
	m.data.SetName("sqlserver.user_connections.suspended")
	m.data.SetDescription("Number of suspended user connections")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsSuspended) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsSuspended) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsSuspended) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsSuspended(cfg MetricConfig) metricSqlserverUserConnectionsSuspended {
	m := metricSqlserverUserConnectionsSuspended{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.total metric with initial data.
func (m *metricSqlserverUserConnectionsTotal) init() {
	m.data.SetName("sqlserver.user_connections.total")
	m.data.SetDescription("Total number of user connections across all statuses")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsTotal(cfg MetricConfig) metricSqlserverUserConnectionsTotal {
	m := metricSqlserverUserConnectionsTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsUtilizationActiveRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.utilization.active_ratio metric with initial data.
func (m *metricSqlserverUserConnectionsUtilizationActiveRatio) init() {
	m.data.SetName("sqlserver.user_connections.utilization.active_ratio")
	m.data.SetDescription("Ratio of active connections to total connections")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsUtilizationActiveRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsUtilizationActiveRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsUtilizationActiveRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsUtilizationActiveRatio(cfg MetricConfig) metricSqlserverUserConnectionsUtilizationActiveRatio {
	m := metricSqlserverUserConnectionsUtilizationActiveRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsUtilizationEfficiency struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.utilization.efficiency metric with initial data.
func (m *metricSqlserverUserConnectionsUtilizationEfficiency) init() {
	m.data.SetName("sqlserver.user_connections.utilization.efficiency")
	m.data.SetDescription("Connection efficiency metric (active/total ratio adjusted for waiting)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsUtilizationEfficiency) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsUtilizationEfficiency) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsUtilizationEfficiency) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsUtilizationEfficiency(cfg MetricConfig) metricSqlserverUserConnectionsUtilizationEfficiency {
	m := metricSqlserverUserConnectionsUtilizationEfficiency{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsUtilizationIdleRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.utilization.idle_ratio metric with initial data.
func (m *metricSqlserverUserConnectionsUtilizationIdleRatio) init() {
	m.data.SetName("sqlserver.user_connections.utilization.idle_ratio")
	m.data.SetDescription("Ratio of idle connections to total connections")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsUtilizationIdleRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsUtilizationIdleRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsUtilizationIdleRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsUtilizationIdleRatio(cfg MetricConfig) metricSqlserverUserConnectionsUtilizationIdleRatio {
	m := metricSqlserverUserConnectionsUtilizationIdleRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsUtilizationWaitingRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.utilization.waiting_ratio metric with initial data.
func (m *metricSqlserverUserConnectionsUtilizationWaitingRatio) init() {
	m.data.SetName("sqlserver.user_connections.utilization.waiting_ratio")
	m.data.SetDescription("Ratio of waiting connections to total connections")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsUtilizationWaitingRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsUtilizationWaitingRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsUtilizationWaitingRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsUtilizationWaitingRatio(cfg MetricConfig) metricSqlserverUserConnectionsUtilizationWaitingRatio {
	m := metricSqlserverUserConnectionsUtilizationWaitingRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverWaitStatsLatchWaitTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.wait_stats.latch.wait_time_ms metric with initial data.
func (m *metricSqlserverWaitStatsLatchWaitTimeMs) init() {
	m.data.SetName("sqlserver.wait_stats.latch.wait_time_ms")
	m.data.SetDescription("Latch wait time in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverWaitStatsLatchWaitTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverWaitStatsLatchWaitTimeMs) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverWaitStatsLatchWaitTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverWaitStatsLatchWaitTimeMs(cfg MetricConfig) metricSqlserverWaitStatsLatchWaitTimeMs {
	m := metricSqlserverWaitStatsLatchWaitTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverWaitStatsLatchWaitingTasksCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.wait_stats.latch.waiting_tasks_count metric with initial data.
func (m *metricSqlserverWaitStatsLatchWaitingTasksCount) init() {
	m.data.SetName("sqlserver.wait_stats.latch.waiting_tasks_count")
	m.data.SetDescription("Number of tasks waiting on latches")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverWaitStatsLatchWaitingTasksCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverWaitStatsLatchWaitingTasksCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverWaitStatsLatchWaitingTasksCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverWaitStatsLatchWaitingTasksCount(cfg MetricConfig) metricSqlserverWaitStatsLatchWaitingTasksCount {
	m := metricSqlserverWaitStatsLatchWaitingTasksCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverWaitStatsWaitTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.wait_stats.wait_time_ms metric with initial data.
func (m *metricSqlserverWaitStatsWaitTimeMs) init() {
	m.data.SetName("sqlserver.wait_stats.wait_time_ms")
	m.data.SetDescription("Total wait time in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverWaitStatsWaitTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverWaitStatsWaitTimeMs) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverWaitStatsWaitTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverWaitStatsWaitTimeMs(cfg MetricConfig) metricSqlserverWaitStatsWaitTimeMs {
	m := metricSqlserverWaitStatsWaitTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverWaitStatsWaitingTasksCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.wait_stats.waiting_tasks_count metric with initial data.
func (m *metricSqlserverWaitStatsWaitingTasksCount) init() {
	m.data.SetName("sqlserver.wait_stats.waiting_tasks_count")
	m.data.SetDescription("Number of tasks currently waiting")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverWaitStatsWaitingTasksCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverWaitStatsWaitingTasksCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverWaitStatsWaitingTasksCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverWaitStatsWaitingTasksCount(cfg MetricConfig) metricSqlserverWaitStatsWaitingTasksCount {
	m := metricSqlserverWaitStatsWaitingTasksCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                                                          MetricsBuilderConfig // config of the metrics builder.
	startTime                                                       pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                                                 int                  // maximum observed number of metrics per resource.
	metricsBuffer                                                   pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                                                       component.BuildInfo  // contains version information.
	resourceAttributeIncludeFilter                                  map[string]filter.Filter
	resourceAttributeExcludeFilter                                  map[string]filter.Filter
	metricActiveConnections                                         metricActiveConnections
	metricInstanceBackgroundProcessesCount                          metricInstanceBackgroundProcessesCount
	metricInstanceBlockedProcessesCount                             metricInstanceBlockedProcessesCount
	metricInstanceDiskInBytes                                       metricInstanceDiskInBytes
	metricInstanceDormantProcessesCount                             metricInstanceDormantProcessesCount
	metricInstancePreconnectProcessesCount                          metricInstancePreconnectProcessesCount
	metricInstanceRunnableProcessesCount                            metricInstanceRunnableProcessesCount
	metricInstanceRunnableTasks                                     metricInstanceRunnableTasks
	metricInstanceRunningProcessesCount                             metricInstanceRunningProcessesCount
	metricInstanceSleepingProcessesCount                            metricInstanceSleepingProcessesCount
	metricInstanceSuspendedProcessesCount                           metricInstanceSuspendedProcessesCount
	metricSqlserverAccessPageSplitsPerSec                           metricSqlserverAccessPageSplitsPerSec
	metricSqlserverActivequeryCPUTimeMs                             metricSqlserverActivequeryCPUTimeMs
	metricSqlserverActivequeryElapsedTimeMs                         metricSqlserverActivequeryElapsedTimeMs
	metricSqlserverActivequeryGrantedQueryMemoryPages               metricSqlserverActivequeryGrantedQueryMemoryPages
	metricSqlserverActivequeryLogicalReads                          metricSqlserverActivequeryLogicalReads
	metricSqlserverActivequeryReads                                 metricSqlserverActivequeryReads
	metricSqlserverActivequeryRowCount                              metricSqlserverActivequeryRowCount
	metricSqlserverActivequeryWaitTimeSeconds                       metricSqlserverActivequeryWaitTimeSeconds
	metricSqlserverActivequeryWrites                                metricSqlserverActivequeryWrites
	metricSqlserverBufferCacheHitRatio                              metricSqlserverBufferCacheHitRatio
	metricSqlserverBufferCheckpointPagesPerSec                      metricSqlserverBufferCheckpointPagesPerSec
	metricSqlserverBufferPageLifeExpectancy                         metricSqlserverBufferPageLifeExpectancy
	metricSqlserverBufferPoolHitPercent                             metricSqlserverBufferPoolHitPercent
	metricSqlserverBufferpoolBatchRequestsPerSec                    metricSqlserverBufferpoolBatchRequestsPerSec
	metricSqlserverBufferpoolPageLifeExpectancyMs                   metricSqlserverBufferpoolPageLifeExpectancyMs
	metricSqlserverConnectionsUser                                  metricSqlserverConnectionsUser
	metricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes         metricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes
	metricSqlserverDatabaseIoStallInMilliseconds                    metricSqlserverDatabaseIoStallInMilliseconds
	metricSqlserverDatabaseLogBytesFlushesPerSec                    metricSqlserverDatabaseLogBytesFlushesPerSec
	metricSqlserverDatabaseLogFlushWaitsPerSec                      metricSqlserverDatabaseLogFlushWaitsPerSec
	metricSqlserverDatabaseLogFlushesPerSec                         metricSqlserverDatabaseLogFlushesPerSec
	metricSqlserverDatabaseLogTransactionGrowth                     metricSqlserverDatabaseLogTransactionGrowth
	metricSqlserverDatabaseLogUsedSpaceMB                           metricSqlserverDatabaseLogUsedSpaceMB
	metricSqlserverDatabaseMaxDiskSizeInBytes                       metricSqlserverDatabaseMaxDiskSizeInBytes
	metricSqlserverDatabasePageFileAvailable                        metricSqlserverDatabasePageFileAvailable
	metricSqlserverDatabasePageFileTotal                            metricSqlserverDatabasePageFileTotal
	metricSqlserverDatabasePrincipalCreateDate                      metricSqlserverDatabasePrincipalCreateDate
	metricSqlserverDatabasePrincipalsApplicationRoles               metricSqlserverDatabasePrincipalsApplicationRoles
	metricSqlserverDatabasePrincipalsOld                            metricSqlserverDatabasePrincipalsOld
	metricSqlserverDatabasePrincipalsOrphanedUsers                  metricSqlserverDatabasePrincipalsOrphanedUsers
	metricSqlserverDatabasePrincipalsRecentlyCreated                metricSqlserverDatabasePrincipalsRecentlyCreated
	metricSqlserverDatabasePrincipalsRoles                          metricSqlserverDatabasePrincipalsRoles
	metricSqlserverDatabasePrincipalsSQLUsers                       metricSqlserverDatabasePrincipalsSQLUsers
	metricSqlserverDatabasePrincipalsTotal                          metricSqlserverDatabasePrincipalsTotal
	metricSqlserverDatabasePrincipalsUsers                          metricSqlserverDatabasePrincipalsUsers
	metricSqlserverDatabasePrincipalsWindowsUsers                   metricSqlserverDatabasePrincipalsWindowsUsers
	metricSqlserverDatabaseRoleMembersApplicationRoles              metricSqlserverDatabaseRoleMembersApplicationRoles
	metricSqlserverDatabaseRoleMembersCrossRole                     metricSqlserverDatabaseRoleMembersCrossRole
	metricSqlserverDatabaseRoleMembersHighPrivilege                 metricSqlserverDatabaseRoleMembersHighPrivilege
	metricSqlserverDatabaseRoleMembersUnique                        metricSqlserverDatabaseRoleMembersUnique
	metricSqlserverDatabaseRoleMembershipActive                     metricSqlserverDatabaseRoleMembershipActive
	metricSqlserverDatabaseRoleMembershipsActive                    metricSqlserverDatabaseRoleMembershipsActive
	metricSqlserverDatabaseRoleMembershipsCustom                    metricSqlserverDatabaseRoleMembershipsCustom
	metricSqlserverDatabaseRoleMembershipsNested                    metricSqlserverDatabaseRoleMembershipsNested
	metricSqlserverDatabaseRoleMembershipsTotal                     metricSqlserverDatabaseRoleMembershipsTotal
	metricSqlserverDatabaseRoleMembershipsUsers                     metricSqlserverDatabaseRoleMembershipsUsers
	metricSqlserverDatabaseRoleNestingLevel                         metricSqlserverDatabaseRoleNestingLevel
	metricSqlserverDatabaseRolePermissionMemberCount                metricSqlserverDatabaseRolePermissionMemberCount
	metricSqlserverDatabaseRolePermissionRiskLevel                  metricSqlserverDatabaseRolePermissionRiskLevel
	metricSqlserverDatabaseRolePermissionsInherited                 metricSqlserverDatabaseRolePermissionsInherited
	metricSqlserverDatabaseRoleRolesEmpty                           metricSqlserverDatabaseRoleRolesEmpty
	metricSqlserverDatabaseRoleRolesWithMembers                     metricSqlserverDatabaseRoleRolesWithMembers
	metricSqlserverDatabaseSizeDataSizeMB                           metricSqlserverDatabaseSizeDataSizeMB
	metricSqlserverDatabaseSizeTotalSizeMB                          metricSqlserverDatabaseSizeTotalSizeMB
	metricSqlserverDatabaseTransactionsActive                       metricSqlserverDatabaseTransactionsActive
	metricSqlserverFailoverClusterAgClusterType                     metricSqlserverFailoverClusterAgClusterType
	metricSqlserverFailoverClusterAgFailureConditionLevel           metricSqlserverFailoverClusterAgFailureConditionLevel
	metricSqlserverFailoverClusterAgHealthCheckTimeout              metricSqlserverFailoverClusterAgHealthCheckTimeout
	metricSqlserverFailoverClusterAgReplicaRole                     metricSqlserverFailoverClusterAgReplicaRole
	metricSqlserverFailoverClusterAgSynchronizationHealth           metricSqlserverFailoverClusterAgSynchronizationHealth
	metricSqlserverFailoverClusterFlowControlTimeMs                 metricSqlserverFailoverClusterFlowControlTimeMs
	metricSqlserverFailoverClusterLogBytesReceivedPerSec            metricSqlserverFailoverClusterLogBytesReceivedPerSec
	metricSqlserverFailoverClusterLogSendQueueKb                    metricSqlserverFailoverClusterLogSendQueueKb
	metricSqlserverFailoverClusterRedoQueueKb                       metricSqlserverFailoverClusterRedoQueueKb
	metricSqlserverFailoverClusterRedoRateKbSec                     metricSqlserverFailoverClusterRedoRateKbSec
	metricSqlserverFailoverClusterTransactionDelayMs                metricSqlserverFailoverClusterTransactionDelayMs
	metricSqlserverIndividualQueryTotalCPUMs                        metricSqlserverIndividualQueryTotalCPUMs
	metricSqlserverIndividualQueryTotalElapsedMs                    metricSqlserverIndividualQueryTotalElapsedMs
	metricSqlserverInstanceBufferPoolSize                           metricSqlserverInstanceBufferPoolSize
	metricSqlserverInstanceCompilationsPerBatch                     metricSqlserverInstanceCompilationsPerBatch
	metricSqlserverInstanceForcedParameterizationsPerSec            metricSqlserverInstanceForcedParameterizationsPerSec
	metricSqlserverInstanceFullScansRate                            metricSqlserverInstanceFullScansRate
	metricSqlserverInstanceLockTimeoutsRate                         metricSqlserverInstanceLockTimeoutsRate
	metricSqlserverInstanceMemoryAvailable                          metricSqlserverInstanceMemoryAvailable
	metricSqlserverInstanceMemoryTotal                              metricSqlserverInstanceMemoryTotal
	metricSqlserverInstanceMemoryUtilization                        metricSqlserverInstanceMemoryUtilization
	metricSqlserverInstancePageSplitsPerBatch                       metricSqlserverInstancePageSplitsPerBatch
	metricSqlserverInstanceTargetMemoryKb                           metricSqlserverInstanceTargetMemoryKb
	metricSqlserverInstanceTransactionsPerSec                       metricSqlserverInstanceTransactionsPerSec
	metricSqlserverLockModeBulkUpdate                               metricSqlserverLockModeBulkUpdate
	metricSqlserverLockModeExclusive                                metricSqlserverLockModeExclusive
	metricSqlserverLockModeIntent                                   metricSqlserverLockModeIntent
	metricSqlserverLockModeSchema                                   metricSqlserverLockModeSchema
	metricSqlserverLockModeShared                                   metricSqlserverLockModeShared
	metricSqlserverLockModeSharedIntentExclusive                    metricSqlserverLockModeSharedIntentExclusive
	metricSqlserverLockModeTotal                                    metricSqlserverLockModeTotal
	metricSqlserverLockModeUpdate                                   metricSqlserverLockModeUpdate
	metricSqlserverLockResourceAllocationUnit                       metricSqlserverLockResourceAllocationUnit
	metricSqlserverLockResourceApplication                          metricSqlserverLockResourceApplication
	metricSqlserverLockResourceDatabaseLevel                        metricSqlserverLockResourceDatabaseLevel
	metricSqlserverLockResourceExtent                               metricSqlserverLockResourceExtent
	metricSqlserverLockResourceFile                                 metricSqlserverLockResourceFile
	metricSqlserverLockResourceHobt                                 metricSqlserverLockResourceHobt
	metricSqlserverLockResourceKey                                  metricSqlserverLockResourceKey
	metricSqlserverLockResourceMetadata                             metricSqlserverLockResourceMetadata
	metricSqlserverLockResourcePage                                 metricSqlserverLockResourcePage
	metricSqlserverLockResourceRow                                  metricSqlserverLockResourceRow
	metricSqlserverLockResourceTable                                metricSqlserverLockResourceTable
	metricSqlserverLockResourceTotal                                metricSqlserverLockResourceTotal
	metricSqlserverLockedObject                                     metricSqlserverLockedObject
	metricSqlserverMemoryTarget                                     metricSqlserverMemoryTarget
	metricSqlserverMemoryTotal                                      metricSqlserverMemoryTotal
	metricSqlserverPlanAvgElapsedTimeMs                             metricSqlserverPlanAvgElapsedTimeMs
	metricSqlserverPlanAvgLogicalReads                              metricSqlserverPlanAvgLogicalReads
	metricSqlserverPlanAvgLogicalWrites                             metricSqlserverPlanAvgLogicalWrites
	metricSqlserverPlanAvgWorkerTimeMs                              metricSqlserverPlanAvgWorkerTimeMs
	metricSqlserverPlanExecutionCount                               metricSqlserverPlanExecutionCount
	metricSqlserverPlanLastDop                                      metricSqlserverPlanLastDop
	metricSqlserverPlanLastGrantKb                                  metricSqlserverPlanLastGrantKb
	metricSqlserverPlanLastSpills                                   metricSqlserverPlanLastSpills
	metricSqlserverPlanMaxElapsedTimeMs                             metricSqlserverPlanMaxElapsedTimeMs
	metricSqlserverPlanMinElapsedTimeMs                             metricSqlserverPlanMinElapsedTimeMs
	metricSqlserverPlanTotalElapsedTimeMs                           metricSqlserverPlanTotalElapsedTimeMs
	metricSqlserverSecurityServerPrincipalsCount                    metricSqlserverSecurityServerPrincipalsCount
	metricSqlserverSecurityServerRoleMembersCount                   metricSqlserverSecurityServerRoleMembersCount
	metricSqlserverSlowqueryAvgDiskReads                            metricSqlserverSlowqueryAvgDiskReads
	metricSqlserverSlowqueryAvgDiskWrites                           metricSqlserverSlowqueryAvgDiskWrites
	metricSqlserverSlowqueryAvgRowsProcessed                        metricSqlserverSlowqueryAvgRowsProcessed
	metricSqlserverSlowqueryHistoricalAvgCPUTimeMs                  metricSqlserverSlowqueryHistoricalAvgCPUTimeMs
	metricSqlserverSlowqueryHistoricalAvgElapsedTimeMs              metricSqlserverSlowqueryHistoricalAvgElapsedTimeMs
	metricSqlserverSlowqueryHistoricalExecutionCount                metricSqlserverSlowqueryHistoricalExecutionCount
	metricSqlserverSlowqueryIntervalAvgElapsedTimeMs                metricSqlserverSlowqueryIntervalAvgElapsedTimeMs
	metricSqlserverSlowqueryIntervalExecutionCount                  metricSqlserverSlowqueryIntervalExecutionCount
	metricSqlserverSlowqueryLastDop                                 metricSqlserverSlowqueryLastDop
	metricSqlserverSlowqueryLastElapsedTimeMs                       metricSqlserverSlowqueryLastElapsedTimeMs
	metricSqlserverSlowqueryLastGrantKb                             metricSqlserverSlowqueryLastGrantKb
	metricSqlserverSlowqueryLastSpills                              metricSqlserverSlowqueryLastSpills
	metricSqlserverSlowqueryLastUsedGrantKb                         metricSqlserverSlowqueryLastUsedGrantKb
	metricSqlserverSlowqueryMaxElapsedTimeMs                        metricSqlserverSlowqueryMaxElapsedTimeMs
	metricSqlserverSlowqueryMaxSpills                               metricSqlserverSlowqueryMaxSpills
	metricSqlserverSlowqueryMinElapsedTimeMs                        metricSqlserverSlowqueryMinElapsedTimeMs
	metricSqlserverSlowqueryQueryText                               metricSqlserverSlowqueryQueryText
	metricSqlserverStatsConnections                                 metricSqlserverStatsConnections
	metricSqlserverStatsDeadlocksPerSec                             metricSqlserverStatsDeadlocksPerSec
	metricSqlserverStatsKillConnectionErrorsPerSec                  metricSqlserverStatsKillConnectionErrorsPerSec
	metricSqlserverStatsLockWaitsPerSec                             metricSqlserverStatsLockWaitsPerSec
	metricSqlserverStatsSQLCompilationsPerSec                       metricSqlserverStatsSQLCompilationsPerSec
	metricSqlserverStatsSQLRecompilationsPerSec                     metricSqlserverStatsSQLRecompilationsPerSec
	metricSqlserverStatsUserErrorsPerSec                            metricSqlserverStatsUserErrorsPerSec
	metricSqlserverTempdbAllocationWaitsMs                          metricSqlserverTempdbAllocationWaitsMs
	metricSqlserverTempdbCurrentWaiters                             metricSqlserverTempdbCurrentWaiters
	metricSqlserverTempdbDataFileCount                              metricSqlserverTempdbDataFileCount
	metricSqlserverTempdbPagelatchWaitsMs                           metricSqlserverTempdbPagelatchWaitsMs
	metricSqlserverTempdbTotalSizeMb                                metricSqlserverTempdbTotalSizeMb
	metricSqlserverThreadpoolCurrentTasks                           metricSqlserverThreadpoolCurrentTasks
	metricSqlserverThreadpoolMaxWorkers                             metricSqlserverThreadpoolMaxWorkers
	metricSqlserverThreadpoolRunnableTasks                          metricSqlserverThreadpoolRunnableTasks
	metricSqlserverThreadpoolRunningWorkers                         metricSqlserverThreadpoolRunningWorkers
	metricSqlserverThreadpoolUtilizationPercent                     metricSqlserverThreadpoolUtilizationPercent
	metricSqlserverThreadpoolWaitingTasks                           metricSqlserverThreadpoolWaitingTasks
	metricSqlserverThreadpoolWorkQueueCount                         metricSqlserverThreadpoolWorkQueueCount
	metricSqlserverUserConnectionsAuthenticationChurnRate           metricSqlserverUserConnectionsAuthenticationChurnRate
	metricSqlserverUserConnectionsAuthenticationFailedLoginEvents   metricSqlserverUserConnectionsAuthenticationFailedLoginEvents
	metricSqlserverUserConnectionsAuthenticationLoginsPerSec        metricSqlserverUserConnectionsAuthenticationLoginsPerSec
	metricSqlserverUserConnectionsAuthenticationLogoutsPerSec       metricSqlserverUserConnectionsAuthenticationLogoutsPerSec
	metricSqlserverUserConnectionsAuthenticationRate                metricSqlserverUserConnectionsAuthenticationRate
	metricSqlserverUserConnectionsAuthenticationRecentFailedLogins  metricSqlserverUserConnectionsAuthenticationRecentFailedLogins
	metricSqlserverUserConnectionsAuthenticationTotalActivity       metricSqlserverUserConnectionsAuthenticationTotalActivity
	metricSqlserverUserConnectionsAuthenticationTotalFailedLogins   metricSqlserverUserConnectionsAuthenticationTotalFailedLogins
	metricSqlserverUserConnectionsAuthenticationUniqueFailedSources metricSqlserverUserConnectionsAuthenticationUniqueFailedSources
	metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers   metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers
	metricSqlserverUserConnectionsClientCount                       metricSqlserverUserConnectionsClientCount
	metricSqlserverUserConnectionsClientHostsMultiProgram           metricSqlserverUserConnectionsClientHostsMultiProgram
	metricSqlserverUserConnectionsClientProgramsMultiHost           metricSqlserverUserConnectionsClientProgramsMultiHost
	metricSqlserverUserConnectionsClientTopHostConnections          metricSqlserverUserConnectionsClientTopHostConnections
	metricSqlserverUserConnectionsClientTopProgramConnections       metricSqlserverUserConnectionsClientTopProgramConnections
	metricSqlserverUserConnectionsClientUniqueHosts                 metricSqlserverUserConnectionsClientUniqueHosts
	metricSqlserverUserConnectionsClientUniquePrograms              metricSqlserverUserConnectionsClientUniquePrograms
	metricSqlserverUserConnectionsDormant                           metricSqlserverUserConnectionsDormant
	metricSqlserverUserConnectionsRunnable                          metricSqlserverUserConnectionsRunnable
	metricSqlserverUserConnectionsRunning                           metricSqlserverUserConnectionsRunning
	metricSqlserverUserConnectionsSleeping                          metricSqlserverUserConnectionsSleeping
	metricSqlserverUserConnectionsStatusCount                       metricSqlserverUserConnectionsStatusCount
	metricSqlserverUserConnectionsSuspended                         metricSqlserverUserConnectionsSuspended
	metricSqlserverUserConnectionsTotal                             metricSqlserverUserConnectionsTotal
	metricSqlserverUserConnectionsUtilizationActiveRatio            metricSqlserverUserConnectionsUtilizationActiveRatio
	metricSqlserverUserConnectionsUtilizationEfficiency             metricSqlserverUserConnectionsUtilizationEfficiency
	metricSqlserverUserConnectionsUtilizationIdleRatio              metricSqlserverUserConnectionsUtilizationIdleRatio
	metricSqlserverUserConnectionsUtilizationWaitingRatio           metricSqlserverUserConnectionsUtilizationWaitingRatio
	metricSqlserverWaitStatsLatchWaitTimeMs                         metricSqlserverWaitStatsLatchWaitTimeMs
	metricSqlserverWaitStatsLatchWaitingTasksCount                  metricSqlserverWaitStatsLatchWaitingTasksCount
	metricSqlserverWaitStatsWaitTimeMs                              metricSqlserverWaitStatsWaitTimeMs
	metricSqlserverWaitStatsWaitingTasksCount                       metricSqlserverWaitStatsWaitingTasksCount
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}
func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:                                                          mbc,
		startTime:                                                       pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                                                   pmetric.NewMetrics(),
		buildInfo:                                                       settings.BuildInfo,
		metricActiveConnections:                                         newMetricActiveConnections(mbc.Metrics.ActiveConnections),
		metricInstanceBackgroundProcessesCount:                          newMetricInstanceBackgroundProcessesCount(mbc.Metrics.InstanceBackgroundProcessesCount),
		metricInstanceBlockedProcessesCount:                             newMetricInstanceBlockedProcessesCount(mbc.Metrics.InstanceBlockedProcessesCount),
		metricInstanceDiskInBytes:                                       newMetricInstanceDiskInBytes(mbc.Metrics.InstanceDiskInBytes),
		metricInstanceDormantProcessesCount:                             newMetricInstanceDormantProcessesCount(mbc.Metrics.InstanceDormantProcessesCount),
		metricInstancePreconnectProcessesCount:                          newMetricInstancePreconnectProcessesCount(mbc.Metrics.InstancePreconnectProcessesCount),
		metricInstanceRunnableProcessesCount:                            newMetricInstanceRunnableProcessesCount(mbc.Metrics.InstanceRunnableProcessesCount),
		metricInstanceRunnableTasks:                                     newMetricInstanceRunnableTasks(mbc.Metrics.InstanceRunnableTasks),
		metricInstanceRunningProcessesCount:                             newMetricInstanceRunningProcessesCount(mbc.Metrics.InstanceRunningProcessesCount),
		metricInstanceSleepingProcessesCount:                            newMetricInstanceSleepingProcessesCount(mbc.Metrics.InstanceSleepingProcessesCount),
		metricInstanceSuspendedProcessesCount:                           newMetricInstanceSuspendedProcessesCount(mbc.Metrics.InstanceSuspendedProcessesCount),
		metricSqlserverAccessPageSplitsPerSec:                           newMetricSqlserverAccessPageSplitsPerSec(mbc.Metrics.SqlserverAccessPageSplitsPerSec),
		metricSqlserverActivequeryCPUTimeMs:                             newMetricSqlserverActivequeryCPUTimeMs(mbc.Metrics.SqlserverActivequeryCPUTimeMs),
		metricSqlserverActivequeryElapsedTimeMs:                         newMetricSqlserverActivequeryElapsedTimeMs(mbc.Metrics.SqlserverActivequeryElapsedTimeMs),
		metricSqlserverActivequeryGrantedQueryMemoryPages:               newMetricSqlserverActivequeryGrantedQueryMemoryPages(mbc.Metrics.SqlserverActivequeryGrantedQueryMemoryPages),
		metricSqlserverActivequeryLogicalReads:                          newMetricSqlserverActivequeryLogicalReads(mbc.Metrics.SqlserverActivequeryLogicalReads),
		metricSqlserverActivequeryReads:                                 newMetricSqlserverActivequeryReads(mbc.Metrics.SqlserverActivequeryReads),
		metricSqlserverActivequeryRowCount:                              newMetricSqlserverActivequeryRowCount(mbc.Metrics.SqlserverActivequeryRowCount),
		metricSqlserverActivequeryWaitTimeSeconds:                       newMetricSqlserverActivequeryWaitTimeSeconds(mbc.Metrics.SqlserverActivequeryWaitTimeSeconds),
		metricSqlserverActivequeryWrites:                                newMetricSqlserverActivequeryWrites(mbc.Metrics.SqlserverActivequeryWrites),
		metricSqlserverBufferCacheHitRatio:                              newMetricSqlserverBufferCacheHitRatio(mbc.Metrics.SqlserverBufferCacheHitRatio),
		metricSqlserverBufferCheckpointPagesPerSec:                      newMetricSqlserverBufferCheckpointPagesPerSec(mbc.Metrics.SqlserverBufferCheckpointPagesPerSec),
		metricSqlserverBufferPageLifeExpectancy:                         newMetricSqlserverBufferPageLifeExpectancy(mbc.Metrics.SqlserverBufferPageLifeExpectancy),
		metricSqlserverBufferPoolHitPercent:                             newMetricSqlserverBufferPoolHitPercent(mbc.Metrics.SqlserverBufferPoolHitPercent),
		metricSqlserverBufferpoolBatchRequestsPerSec:                    newMetricSqlserverBufferpoolBatchRequestsPerSec(mbc.Metrics.SqlserverBufferpoolBatchRequestsPerSec),
		metricSqlserverBufferpoolPageLifeExpectancyMs:                   newMetricSqlserverBufferpoolPageLifeExpectancyMs(mbc.Metrics.SqlserverBufferpoolPageLifeExpectancyMs),
		metricSqlserverConnectionsUser:                                  newMetricSqlserverConnectionsUser(mbc.Metrics.SqlserverConnectionsUser),
		metricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes:         newMetricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes(mbc.Metrics.SqlserverDatabaseBufferpoolSizePerDatabaseInBytes),
		metricSqlserverDatabaseIoStallInMilliseconds:                    newMetricSqlserverDatabaseIoStallInMilliseconds(mbc.Metrics.SqlserverDatabaseIoStallInMilliseconds),
		metricSqlserverDatabaseLogBytesFlushesPerSec:                    newMetricSqlserverDatabaseLogBytesFlushesPerSec(mbc.Metrics.SqlserverDatabaseLogBytesFlushesPerSec),
		metricSqlserverDatabaseLogFlushWaitsPerSec:                      newMetricSqlserverDatabaseLogFlushWaitsPerSec(mbc.Metrics.SqlserverDatabaseLogFlushWaitsPerSec),
		metricSqlserverDatabaseLogFlushesPerSec:                         newMetricSqlserverDatabaseLogFlushesPerSec(mbc.Metrics.SqlserverDatabaseLogFlushesPerSec),
		metricSqlserverDatabaseLogTransactionGrowth:                     newMetricSqlserverDatabaseLogTransactionGrowth(mbc.Metrics.SqlserverDatabaseLogTransactionGrowth),
		metricSqlserverDatabaseLogUsedSpaceMB:                           newMetricSqlserverDatabaseLogUsedSpaceMB(mbc.Metrics.SqlserverDatabaseLogUsedSpaceMB),
		metricSqlserverDatabaseMaxDiskSizeInBytes:                       newMetricSqlserverDatabaseMaxDiskSizeInBytes(mbc.Metrics.SqlserverDatabaseMaxDiskSizeInBytes),
		metricSqlserverDatabasePageFileAvailable:                        newMetricSqlserverDatabasePageFileAvailable(mbc.Metrics.SqlserverDatabasePageFileAvailable),
		metricSqlserverDatabasePageFileTotal:                            newMetricSqlserverDatabasePageFileTotal(mbc.Metrics.SqlserverDatabasePageFileTotal),
		metricSqlserverDatabasePrincipalCreateDate:                      newMetricSqlserverDatabasePrincipalCreateDate(mbc.Metrics.SqlserverDatabasePrincipalCreateDate),
		metricSqlserverDatabasePrincipalsApplicationRoles:               newMetricSqlserverDatabasePrincipalsApplicationRoles(mbc.Metrics.SqlserverDatabasePrincipalsApplicationRoles),
		metricSqlserverDatabasePrincipalsOld:                            newMetricSqlserverDatabasePrincipalsOld(mbc.Metrics.SqlserverDatabasePrincipalsOld),
		metricSqlserverDatabasePrincipalsOrphanedUsers:                  newMetricSqlserverDatabasePrincipalsOrphanedUsers(mbc.Metrics.SqlserverDatabasePrincipalsOrphanedUsers),
		metricSqlserverDatabasePrincipalsRecentlyCreated:                newMetricSqlserverDatabasePrincipalsRecentlyCreated(mbc.Metrics.SqlserverDatabasePrincipalsRecentlyCreated),
		metricSqlserverDatabasePrincipalsRoles:                          newMetricSqlserverDatabasePrincipalsRoles(mbc.Metrics.SqlserverDatabasePrincipalsRoles),
		metricSqlserverDatabasePrincipalsSQLUsers:                       newMetricSqlserverDatabasePrincipalsSQLUsers(mbc.Metrics.SqlserverDatabasePrincipalsSQLUsers),
		metricSqlserverDatabasePrincipalsTotal:                          newMetricSqlserverDatabasePrincipalsTotal(mbc.Metrics.SqlserverDatabasePrincipalsTotal),
		metricSqlserverDatabasePrincipalsUsers:                          newMetricSqlserverDatabasePrincipalsUsers(mbc.Metrics.SqlserverDatabasePrincipalsUsers),
		metricSqlserverDatabasePrincipalsWindowsUsers:                   newMetricSqlserverDatabasePrincipalsWindowsUsers(mbc.Metrics.SqlserverDatabasePrincipalsWindowsUsers),
		metricSqlserverDatabaseRoleMembersApplicationRoles:              newMetricSqlserverDatabaseRoleMembersApplicationRoles(mbc.Metrics.SqlserverDatabaseRoleMembersApplicationRoles),
		metricSqlserverDatabaseRoleMembersCrossRole:                     newMetricSqlserverDatabaseRoleMembersCrossRole(mbc.Metrics.SqlserverDatabaseRoleMembersCrossRole),
		metricSqlserverDatabaseRoleMembersHighPrivilege:                 newMetricSqlserverDatabaseRoleMembersHighPrivilege(mbc.Metrics.SqlserverDatabaseRoleMembersHighPrivilege),
		metricSqlserverDatabaseRoleMembersUnique:                        newMetricSqlserverDatabaseRoleMembersUnique(mbc.Metrics.SqlserverDatabaseRoleMembersUnique),
		metricSqlserverDatabaseRoleMembershipActive:                     newMetricSqlserverDatabaseRoleMembershipActive(mbc.Metrics.SqlserverDatabaseRoleMembershipActive),
		metricSqlserverDatabaseRoleMembershipsActive:                    newMetricSqlserverDatabaseRoleMembershipsActive(mbc.Metrics.SqlserverDatabaseRoleMembershipsActive),
		metricSqlserverDatabaseRoleMembershipsCustom:                    newMetricSqlserverDatabaseRoleMembershipsCustom(mbc.Metrics.SqlserverDatabaseRoleMembershipsCustom),
		metricSqlserverDatabaseRoleMembershipsNested:                    newMetricSqlserverDatabaseRoleMembershipsNested(mbc.Metrics.SqlserverDatabaseRoleMembershipsNested),
		metricSqlserverDatabaseRoleMembershipsTotal:                     newMetricSqlserverDatabaseRoleMembershipsTotal(mbc.Metrics.SqlserverDatabaseRoleMembershipsTotal),
		metricSqlserverDatabaseRoleMembershipsUsers:                     newMetricSqlserverDatabaseRoleMembershipsUsers(mbc.Metrics.SqlserverDatabaseRoleMembershipsUsers),
		metricSqlserverDatabaseRoleNestingLevel:                         newMetricSqlserverDatabaseRoleNestingLevel(mbc.Metrics.SqlserverDatabaseRoleNestingLevel),
		metricSqlserverDatabaseRolePermissionMemberCount:                newMetricSqlserverDatabaseRolePermissionMemberCount(mbc.Metrics.SqlserverDatabaseRolePermissionMemberCount),
		metricSqlserverDatabaseRolePermissionRiskLevel:                  newMetricSqlserverDatabaseRolePermissionRiskLevel(mbc.Metrics.SqlserverDatabaseRolePermissionRiskLevel),
		metricSqlserverDatabaseRolePermissionsInherited:                 newMetricSqlserverDatabaseRolePermissionsInherited(mbc.Metrics.SqlserverDatabaseRolePermissionsInherited),
		metricSqlserverDatabaseRoleRolesEmpty:                           newMetricSqlserverDatabaseRoleRolesEmpty(mbc.Metrics.SqlserverDatabaseRoleRolesEmpty),
		metricSqlserverDatabaseRoleRolesWithMembers:                     newMetricSqlserverDatabaseRoleRolesWithMembers(mbc.Metrics.SqlserverDatabaseRoleRolesWithMembers),
		metricSqlserverDatabaseSizeDataSizeMB:                           newMetricSqlserverDatabaseSizeDataSizeMB(mbc.Metrics.SqlserverDatabaseSizeDataSizeMB),
		metricSqlserverDatabaseSizeTotalSizeMB:                          newMetricSqlserverDatabaseSizeTotalSizeMB(mbc.Metrics.SqlserverDatabaseSizeTotalSizeMB),
		metricSqlserverDatabaseTransactionsActive:                       newMetricSqlserverDatabaseTransactionsActive(mbc.Metrics.SqlserverDatabaseTransactionsActive),
		metricSqlserverFailoverClusterAgClusterType:                     newMetricSqlserverFailoverClusterAgClusterType(mbc.Metrics.SqlserverFailoverClusterAgClusterType),
		metricSqlserverFailoverClusterAgFailureConditionLevel:           newMetricSqlserverFailoverClusterAgFailureConditionLevel(mbc.Metrics.SqlserverFailoverClusterAgFailureConditionLevel),
		metricSqlserverFailoverClusterAgHealthCheckTimeout:              newMetricSqlserverFailoverClusterAgHealthCheckTimeout(mbc.Metrics.SqlserverFailoverClusterAgHealthCheckTimeout),
		metricSqlserverFailoverClusterAgReplicaRole:                     newMetricSqlserverFailoverClusterAgReplicaRole(mbc.Metrics.SqlserverFailoverClusterAgReplicaRole),
		metricSqlserverFailoverClusterAgSynchronizationHealth:           newMetricSqlserverFailoverClusterAgSynchronizationHealth(mbc.Metrics.SqlserverFailoverClusterAgSynchronizationHealth),
		metricSqlserverFailoverClusterFlowControlTimeMs:                 newMetricSqlserverFailoverClusterFlowControlTimeMs(mbc.Metrics.SqlserverFailoverClusterFlowControlTimeMs),
		metricSqlserverFailoverClusterLogBytesReceivedPerSec:            newMetricSqlserverFailoverClusterLogBytesReceivedPerSec(mbc.Metrics.SqlserverFailoverClusterLogBytesReceivedPerSec),
		metricSqlserverFailoverClusterLogSendQueueKb:                    newMetricSqlserverFailoverClusterLogSendQueueKb(mbc.Metrics.SqlserverFailoverClusterLogSendQueueKb),
		metricSqlserverFailoverClusterRedoQueueKb:                       newMetricSqlserverFailoverClusterRedoQueueKb(mbc.Metrics.SqlserverFailoverClusterRedoQueueKb),
		metricSqlserverFailoverClusterRedoRateKbSec:                     newMetricSqlserverFailoverClusterRedoRateKbSec(mbc.Metrics.SqlserverFailoverClusterRedoRateKbSec),
		metricSqlserverFailoverClusterTransactionDelayMs:                newMetricSqlserverFailoverClusterTransactionDelayMs(mbc.Metrics.SqlserverFailoverClusterTransactionDelayMs),
		metricSqlserverIndividualQueryTotalCPUMs:                        newMetricSqlserverIndividualQueryTotalCPUMs(mbc.Metrics.SqlserverIndividualQueryTotalCPUMs),
		metricSqlserverIndividualQueryTotalElapsedMs:                    newMetricSqlserverIndividualQueryTotalElapsedMs(mbc.Metrics.SqlserverIndividualQueryTotalElapsedMs),
		metricSqlserverInstanceBufferPoolSize:                           newMetricSqlserverInstanceBufferPoolSize(mbc.Metrics.SqlserverInstanceBufferPoolSize),
		metricSqlserverInstanceCompilationsPerBatch:                     newMetricSqlserverInstanceCompilationsPerBatch(mbc.Metrics.SqlserverInstanceCompilationsPerBatch),
		metricSqlserverInstanceForcedParameterizationsPerSec:            newMetricSqlserverInstanceForcedParameterizationsPerSec(mbc.Metrics.SqlserverInstanceForcedParameterizationsPerSec),
		metricSqlserverInstanceFullScansRate:                            newMetricSqlserverInstanceFullScansRate(mbc.Metrics.SqlserverInstanceFullScansRate),
		metricSqlserverInstanceLockTimeoutsRate:                         newMetricSqlserverInstanceLockTimeoutsRate(mbc.Metrics.SqlserverInstanceLockTimeoutsRate),
		metricSqlserverInstanceMemoryAvailable:                          newMetricSqlserverInstanceMemoryAvailable(mbc.Metrics.SqlserverInstanceMemoryAvailable),
		metricSqlserverInstanceMemoryTotal:                              newMetricSqlserverInstanceMemoryTotal(mbc.Metrics.SqlserverInstanceMemoryTotal),
		metricSqlserverInstanceMemoryUtilization:                        newMetricSqlserverInstanceMemoryUtilization(mbc.Metrics.SqlserverInstanceMemoryUtilization),
		metricSqlserverInstancePageSplitsPerBatch:                       newMetricSqlserverInstancePageSplitsPerBatch(mbc.Metrics.SqlserverInstancePageSplitsPerBatch),
		metricSqlserverInstanceTargetMemoryKb:                           newMetricSqlserverInstanceTargetMemoryKb(mbc.Metrics.SqlserverInstanceTargetMemoryKb),
		metricSqlserverInstanceTransactionsPerSec:                       newMetricSqlserverInstanceTransactionsPerSec(mbc.Metrics.SqlserverInstanceTransactionsPerSec),
		metricSqlserverLockModeBulkUpdate:                               newMetricSqlserverLockModeBulkUpdate(mbc.Metrics.SqlserverLockModeBulkUpdate),
		metricSqlserverLockModeExclusive:                                newMetricSqlserverLockModeExclusive(mbc.Metrics.SqlserverLockModeExclusive),
		metricSqlserverLockModeIntent:                                   newMetricSqlserverLockModeIntent(mbc.Metrics.SqlserverLockModeIntent),
		metricSqlserverLockModeSchema:                                   newMetricSqlserverLockModeSchema(mbc.Metrics.SqlserverLockModeSchema),
		metricSqlserverLockModeShared:                                   newMetricSqlserverLockModeShared(mbc.Metrics.SqlserverLockModeShared),
		metricSqlserverLockModeSharedIntentExclusive:                    newMetricSqlserverLockModeSharedIntentExclusive(mbc.Metrics.SqlserverLockModeSharedIntentExclusive),
		metricSqlserverLockModeTotal:                                    newMetricSqlserverLockModeTotal(mbc.Metrics.SqlserverLockModeTotal),
		metricSqlserverLockModeUpdate:                                   newMetricSqlserverLockModeUpdate(mbc.Metrics.SqlserverLockModeUpdate),
		metricSqlserverLockResourceAllocationUnit:                       newMetricSqlserverLockResourceAllocationUnit(mbc.Metrics.SqlserverLockResourceAllocationUnit),
		metricSqlserverLockResourceApplication:                          newMetricSqlserverLockResourceApplication(mbc.Metrics.SqlserverLockResourceApplication),
		metricSqlserverLockResourceDatabaseLevel:                        newMetricSqlserverLockResourceDatabaseLevel(mbc.Metrics.SqlserverLockResourceDatabaseLevel),
		metricSqlserverLockResourceExtent:                               newMetricSqlserverLockResourceExtent(mbc.Metrics.SqlserverLockResourceExtent),
		metricSqlserverLockResourceFile:                                 newMetricSqlserverLockResourceFile(mbc.Metrics.SqlserverLockResourceFile),
		metricSqlserverLockResourceHobt:                                 newMetricSqlserverLockResourceHobt(mbc.Metrics.SqlserverLockResourceHobt),
		metricSqlserverLockResourceKey:                                  newMetricSqlserverLockResourceKey(mbc.Metrics.SqlserverLockResourceKey),
		metricSqlserverLockResourceMetadata:                             newMetricSqlserverLockResourceMetadata(mbc.Metrics.SqlserverLockResourceMetadata),
		metricSqlserverLockResourcePage:                                 newMetricSqlserverLockResourcePage(mbc.Metrics.SqlserverLockResourcePage),
		metricSqlserverLockResourceRow:                                  newMetricSqlserverLockResourceRow(mbc.Metrics.SqlserverLockResourceRow),
		metricSqlserverLockResourceTable:                                newMetricSqlserverLockResourceTable(mbc.Metrics.SqlserverLockResourceTable),
		metricSqlserverLockResourceTotal:                                newMetricSqlserverLockResourceTotal(mbc.Metrics.SqlserverLockResourceTotal),
		metricSqlserverLockedObject:                                     newMetricSqlserverLockedObject(mbc.Metrics.SqlserverLockedObject),
		metricSqlserverMemoryTarget:                                     newMetricSqlserverMemoryTarget(mbc.Metrics.SqlserverMemoryTarget),
		metricSqlserverMemoryTotal:                                      newMetricSqlserverMemoryTotal(mbc.Metrics.SqlserverMemoryTotal),
		metricSqlserverPlanAvgElapsedTimeMs:                             newMetricSqlserverPlanAvgElapsedTimeMs(mbc.Metrics.SqlserverPlanAvgElapsedTimeMs),
		metricSqlserverPlanAvgLogicalReads:                              newMetricSqlserverPlanAvgLogicalReads(mbc.Metrics.SqlserverPlanAvgLogicalReads),
		metricSqlserverPlanAvgLogicalWrites:                             newMetricSqlserverPlanAvgLogicalWrites(mbc.Metrics.SqlserverPlanAvgLogicalWrites),
		metricSqlserverPlanAvgWorkerTimeMs:                              newMetricSqlserverPlanAvgWorkerTimeMs(mbc.Metrics.SqlserverPlanAvgWorkerTimeMs),
		metricSqlserverPlanExecutionCount:                               newMetricSqlserverPlanExecutionCount(mbc.Metrics.SqlserverPlanExecutionCount),
		metricSqlserverPlanLastDop:                                      newMetricSqlserverPlanLastDop(mbc.Metrics.SqlserverPlanLastDop),
		metricSqlserverPlanLastGrantKb:                                  newMetricSqlserverPlanLastGrantKb(mbc.Metrics.SqlserverPlanLastGrantKb),
		metricSqlserverPlanLastSpills:                                   newMetricSqlserverPlanLastSpills(mbc.Metrics.SqlserverPlanLastSpills),
		metricSqlserverPlanMaxElapsedTimeMs:                             newMetricSqlserverPlanMaxElapsedTimeMs(mbc.Metrics.SqlserverPlanMaxElapsedTimeMs),
		metricSqlserverPlanMinElapsedTimeMs:                             newMetricSqlserverPlanMinElapsedTimeMs(mbc.Metrics.SqlserverPlanMinElapsedTimeMs),
		metricSqlserverPlanTotalElapsedTimeMs:                           newMetricSqlserverPlanTotalElapsedTimeMs(mbc.Metrics.SqlserverPlanTotalElapsedTimeMs),
		metricSqlserverSecurityServerPrincipalsCount:                    newMetricSqlserverSecurityServerPrincipalsCount(mbc.Metrics.SqlserverSecurityServerPrincipalsCount),
		metricSqlserverSecurityServerRoleMembersCount:                   newMetricSqlserverSecurityServerRoleMembersCount(mbc.Metrics.SqlserverSecurityServerRoleMembersCount),
		metricSqlserverSlowqueryAvgDiskReads:                            newMetricSqlserverSlowqueryAvgDiskReads(mbc.Metrics.SqlserverSlowqueryAvgDiskReads),
		metricSqlserverSlowqueryAvgDiskWrites:                           newMetricSqlserverSlowqueryAvgDiskWrites(mbc.Metrics.SqlserverSlowqueryAvgDiskWrites),
		metricSqlserverSlowqueryAvgRowsProcessed:                        newMetricSqlserverSlowqueryAvgRowsProcessed(mbc.Metrics.SqlserverSlowqueryAvgRowsProcessed),
		metricSqlserverSlowqueryHistoricalAvgCPUTimeMs:                  newMetricSqlserverSlowqueryHistoricalAvgCPUTimeMs(mbc.Metrics.SqlserverSlowqueryHistoricalAvgCPUTimeMs),
		metricSqlserverSlowqueryHistoricalAvgElapsedTimeMs:              newMetricSqlserverSlowqueryHistoricalAvgElapsedTimeMs(mbc.Metrics.SqlserverSlowqueryHistoricalAvgElapsedTimeMs),
		metricSqlserverSlowqueryHistoricalExecutionCount:                newMetricSqlserverSlowqueryHistoricalExecutionCount(mbc.Metrics.SqlserverSlowqueryHistoricalExecutionCount),
		metricSqlserverSlowqueryIntervalAvgElapsedTimeMs:                newMetricSqlserverSlowqueryIntervalAvgElapsedTimeMs(mbc.Metrics.SqlserverSlowqueryIntervalAvgElapsedTimeMs),
		metricSqlserverSlowqueryIntervalExecutionCount:                  newMetricSqlserverSlowqueryIntervalExecutionCount(mbc.Metrics.SqlserverSlowqueryIntervalExecutionCount),
		metricSqlserverSlowqueryLastDop:                                 newMetricSqlserverSlowqueryLastDop(mbc.Metrics.SqlserverSlowqueryLastDop),
		metricSqlserverSlowqueryLastElapsedTimeMs:                       newMetricSqlserverSlowqueryLastElapsedTimeMs(mbc.Metrics.SqlserverSlowqueryLastElapsedTimeMs),
		metricSqlserverSlowqueryLastGrantKb:                             newMetricSqlserverSlowqueryLastGrantKb(mbc.Metrics.SqlserverSlowqueryLastGrantKb),
		metricSqlserverSlowqueryLastSpills:                              newMetricSqlserverSlowqueryLastSpills(mbc.Metrics.SqlserverSlowqueryLastSpills),
		metricSqlserverSlowqueryLastUsedGrantKb:                         newMetricSqlserverSlowqueryLastUsedGrantKb(mbc.Metrics.SqlserverSlowqueryLastUsedGrantKb),
		metricSqlserverSlowqueryMaxElapsedTimeMs:                        newMetricSqlserverSlowqueryMaxElapsedTimeMs(mbc.Metrics.SqlserverSlowqueryMaxElapsedTimeMs),
		metricSqlserverSlowqueryMaxSpills:                               newMetricSqlserverSlowqueryMaxSpills(mbc.Metrics.SqlserverSlowqueryMaxSpills),
		metricSqlserverSlowqueryMinElapsedTimeMs:                        newMetricSqlserverSlowqueryMinElapsedTimeMs(mbc.Metrics.SqlserverSlowqueryMinElapsedTimeMs),
		metricSqlserverSlowqueryQueryText:                               newMetricSqlserverSlowqueryQueryText(mbc.Metrics.SqlserverSlowqueryQueryText),
		metricSqlserverStatsConnections:                                 newMetricSqlserverStatsConnections(mbc.Metrics.SqlserverStatsConnections),
		metricSqlserverStatsDeadlocksPerSec:                             newMetricSqlserverStatsDeadlocksPerSec(mbc.Metrics.SqlserverStatsDeadlocksPerSec),
		metricSqlserverStatsKillConnectionErrorsPerSec:                  newMetricSqlserverStatsKillConnectionErrorsPerSec(mbc.Metrics.SqlserverStatsKillConnectionErrorsPerSec),
		metricSqlserverStatsLockWaitsPerSec:                             newMetricSqlserverStatsLockWaitsPerSec(mbc.Metrics.SqlserverStatsLockWaitsPerSec),
		metricSqlserverStatsSQLCompilationsPerSec:                       newMetricSqlserverStatsSQLCompilationsPerSec(mbc.Metrics.SqlserverStatsSQLCompilationsPerSec),
		metricSqlserverStatsSQLRecompilationsPerSec:                     newMetricSqlserverStatsSQLRecompilationsPerSec(mbc.Metrics.SqlserverStatsSQLRecompilationsPerSec),
		metricSqlserverStatsUserErrorsPerSec:                            newMetricSqlserverStatsUserErrorsPerSec(mbc.Metrics.SqlserverStatsUserErrorsPerSec),
		metricSqlserverTempdbAllocationWaitsMs:                          newMetricSqlserverTempdbAllocationWaitsMs(mbc.Metrics.SqlserverTempdbAllocationWaitsMs),
		metricSqlserverTempdbCurrentWaiters:                             newMetricSqlserverTempdbCurrentWaiters(mbc.Metrics.SqlserverTempdbCurrentWaiters),
		metricSqlserverTempdbDataFileCount:                              newMetricSqlserverTempdbDataFileCount(mbc.Metrics.SqlserverTempdbDataFileCount),
		metricSqlserverTempdbPagelatchWaitsMs:                           newMetricSqlserverTempdbPagelatchWaitsMs(mbc.Metrics.SqlserverTempdbPagelatchWaitsMs),
		metricSqlserverTempdbTotalSizeMb:                                newMetricSqlserverTempdbTotalSizeMb(mbc.Metrics.SqlserverTempdbTotalSizeMb),
		metricSqlserverThreadpoolCurrentTasks:                           newMetricSqlserverThreadpoolCurrentTasks(mbc.Metrics.SqlserverThreadpoolCurrentTasks),
		metricSqlserverThreadpoolMaxWorkers:                             newMetricSqlserverThreadpoolMaxWorkers(mbc.Metrics.SqlserverThreadpoolMaxWorkers),
		metricSqlserverThreadpoolRunnableTasks:                          newMetricSqlserverThreadpoolRunnableTasks(mbc.Metrics.SqlserverThreadpoolRunnableTasks),
		metricSqlserverThreadpoolRunningWorkers:                         newMetricSqlserverThreadpoolRunningWorkers(mbc.Metrics.SqlserverThreadpoolRunningWorkers),
		metricSqlserverThreadpoolUtilizationPercent:                     newMetricSqlserverThreadpoolUtilizationPercent(mbc.Metrics.SqlserverThreadpoolUtilizationPercent),
		metricSqlserverThreadpoolWaitingTasks:                           newMetricSqlserverThreadpoolWaitingTasks(mbc.Metrics.SqlserverThreadpoolWaitingTasks),
		metricSqlserverThreadpoolWorkQueueCount:                         newMetricSqlserverThreadpoolWorkQueueCount(mbc.Metrics.SqlserverThreadpoolWorkQueueCount),
		metricSqlserverUserConnectionsAuthenticationChurnRate:           newMetricSqlserverUserConnectionsAuthenticationChurnRate(mbc.Metrics.SqlserverUserConnectionsAuthenticationChurnRate),
		metricSqlserverUserConnectionsAuthenticationFailedLoginEvents:   newMetricSqlserverUserConnectionsAuthenticationFailedLoginEvents(mbc.Metrics.SqlserverUserConnectionsAuthenticationFailedLoginEvents),
		metricSqlserverUserConnectionsAuthenticationLoginsPerSec:        newMetricSqlserverUserConnectionsAuthenticationLoginsPerSec(mbc.Metrics.SqlserverUserConnectionsAuthenticationLoginsPerSec),
		metricSqlserverUserConnectionsAuthenticationLogoutsPerSec:       newMetricSqlserverUserConnectionsAuthenticationLogoutsPerSec(mbc.Metrics.SqlserverUserConnectionsAuthenticationLogoutsPerSec),
		metricSqlserverUserConnectionsAuthenticationRate:                newMetricSqlserverUserConnectionsAuthenticationRate(mbc.Metrics.SqlserverUserConnectionsAuthenticationRate),
		metricSqlserverUserConnectionsAuthenticationRecentFailedLogins:  newMetricSqlserverUserConnectionsAuthenticationRecentFailedLogins(mbc.Metrics.SqlserverUserConnectionsAuthenticationRecentFailedLogins),
		metricSqlserverUserConnectionsAuthenticationTotalActivity:       newMetricSqlserverUserConnectionsAuthenticationTotalActivity(mbc.Metrics.SqlserverUserConnectionsAuthenticationTotalActivity),
		metricSqlserverUserConnectionsAuthenticationTotalFailedLogins:   newMetricSqlserverUserConnectionsAuthenticationTotalFailedLogins(mbc.Metrics.SqlserverUserConnectionsAuthenticationTotalFailedLogins),
		metricSqlserverUserConnectionsAuthenticationUniqueFailedSources: newMetricSqlserverUserConnectionsAuthenticationUniqueFailedSources(mbc.Metrics.SqlserverUserConnectionsAuthenticationUniqueFailedSources),
		metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers:   newMetricSqlserverUserConnectionsAuthenticationUniqueFailedUsers(mbc.Metrics.SqlserverUserConnectionsAuthenticationUniqueFailedUsers),
		metricSqlserverUserConnectionsClientCount:                       newMetricSqlserverUserConnectionsClientCount(mbc.Metrics.SqlserverUserConnectionsClientCount),
		metricSqlserverUserConnectionsClientHostsMultiProgram:           newMetricSqlserverUserConnectionsClientHostsMultiProgram(mbc.Metrics.SqlserverUserConnectionsClientHostsMultiProgram),
		metricSqlserverUserConnectionsClientProgramsMultiHost:           newMetricSqlserverUserConnectionsClientProgramsMultiHost(mbc.Metrics.SqlserverUserConnectionsClientProgramsMultiHost),
		metricSqlserverUserConnectionsClientTopHostConnections:          newMetricSqlserverUserConnectionsClientTopHostConnections(mbc.Metrics.SqlserverUserConnectionsClientTopHostConnections),
		metricSqlserverUserConnectionsClientTopProgramConnections:       newMetricSqlserverUserConnectionsClientTopProgramConnections(mbc.Metrics.SqlserverUserConnectionsClientTopProgramConnections),
		metricSqlserverUserConnectionsClientUniqueHosts:                 newMetricSqlserverUserConnectionsClientUniqueHosts(mbc.Metrics.SqlserverUserConnectionsClientUniqueHosts),
		metricSqlserverUserConnectionsClientUniquePrograms:              newMetricSqlserverUserConnectionsClientUniquePrograms(mbc.Metrics.SqlserverUserConnectionsClientUniquePrograms),
		metricSqlserverUserConnectionsDormant:                           newMetricSqlserverUserConnectionsDormant(mbc.Metrics.SqlserverUserConnectionsDormant),
		metricSqlserverUserConnectionsRunnable:                          newMetricSqlserverUserConnectionsRunnable(mbc.Metrics.SqlserverUserConnectionsRunnable),
		metricSqlserverUserConnectionsRunning:                           newMetricSqlserverUserConnectionsRunning(mbc.Metrics.SqlserverUserConnectionsRunning),
		metricSqlserverUserConnectionsSleeping:                          newMetricSqlserverUserConnectionsSleeping(mbc.Metrics.SqlserverUserConnectionsSleeping),
		metricSqlserverUserConnectionsStatusCount:                       newMetricSqlserverUserConnectionsStatusCount(mbc.Metrics.SqlserverUserConnectionsStatusCount),
		metricSqlserverUserConnectionsSuspended:                         newMetricSqlserverUserConnectionsSuspended(mbc.Metrics.SqlserverUserConnectionsSuspended),
		metricSqlserverUserConnectionsTotal:                             newMetricSqlserverUserConnectionsTotal(mbc.Metrics.SqlserverUserConnectionsTotal),
		metricSqlserverUserConnectionsUtilizationActiveRatio:            newMetricSqlserverUserConnectionsUtilizationActiveRatio(mbc.Metrics.SqlserverUserConnectionsUtilizationActiveRatio),
		metricSqlserverUserConnectionsUtilizationEfficiency:             newMetricSqlserverUserConnectionsUtilizationEfficiency(mbc.Metrics.SqlserverUserConnectionsUtilizationEfficiency),
		metricSqlserverUserConnectionsUtilizationIdleRatio:              newMetricSqlserverUserConnectionsUtilizationIdleRatio(mbc.Metrics.SqlserverUserConnectionsUtilizationIdleRatio),
		metricSqlserverUserConnectionsUtilizationWaitingRatio:           newMetricSqlserverUserConnectionsUtilizationWaitingRatio(mbc.Metrics.SqlserverUserConnectionsUtilizationWaitingRatio),
		metricSqlserverWaitStatsLatchWaitTimeMs:                         newMetricSqlserverWaitStatsLatchWaitTimeMs(mbc.Metrics.SqlserverWaitStatsLatchWaitTimeMs),
		metricSqlserverWaitStatsLatchWaitingTasksCount:                  newMetricSqlserverWaitStatsLatchWaitingTasksCount(mbc.Metrics.SqlserverWaitStatsLatchWaitingTasksCount),
		metricSqlserverWaitStatsWaitTimeMs:                              newMetricSqlserverWaitStatsWaitTimeMs(mbc.Metrics.SqlserverWaitStatsWaitTimeMs),
		metricSqlserverWaitStatsWaitingTasksCount:                       newMetricSqlserverWaitStatsWaitingTasksCount(mbc.Metrics.SqlserverWaitStatsWaitingTasksCount),
		resourceAttributeIncludeFilter:                                  make(map[string]filter.Filter),
		resourceAttributeExcludeFilter:                                  make(map[string]filter.Filter),
	}
	if mbc.ResourceAttributes.DatabaseName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["database_name"] = filter.CreateFilter(mbc.ResourceAttributes.DatabaseName.MetricsInclude)
	}
	if mbc.ResourceAttributes.DatabaseName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["database_name"] = filter.CreateFilter(mbc.ResourceAttributes.DatabaseName.MetricsExclude)
	}
	if mbc.ResourceAttributes.DbSystem.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["db.system"] = filter.CreateFilter(mbc.ResourceAttributes.DbSystem.MetricsInclude)
	}
	if mbc.ResourceAttributes.DbSystem.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["db.system"] = filter.CreateFilter(mbc.ResourceAttributes.DbSystem.MetricsExclude)
	}
	if mbc.ResourceAttributes.EngineEdition.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["engine_edition"] = filter.CreateFilter(mbc.ResourceAttributes.EngineEdition.MetricsInclude)
	}
	if mbc.ResourceAttributes.EngineEdition.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["engine_edition"] = filter.CreateFilter(mbc.ResourceAttributes.EngineEdition.MetricsExclude)
	}
	if mbc.ResourceAttributes.ServerAddress.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["server.address"] = filter.CreateFilter(mbc.ResourceAttributes.ServerAddress.MetricsInclude)
	}
	if mbc.ResourceAttributes.ServerAddress.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["server.address"] = filter.CreateFilter(mbc.ResourceAttributes.ServerAddress.MetricsExclude)
	}
	if mbc.ResourceAttributes.ServerPort.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["server.port"] = filter.CreateFilter(mbc.ResourceAttributes.ServerPort.MetricsInclude)
	}
	if mbc.ResourceAttributes.ServerPort.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["server.port"] = filter.CreateFilter(mbc.ResourceAttributes.ServerPort.MetricsExclude)
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricActiveConnections.emit(ils.Metrics())
	mb.metricInstanceBackgroundProcessesCount.emit(ils.Metrics())
	mb.metricInstanceBlockedProcessesCount.emit(ils.Metrics())
	mb.metricInstanceDiskInBytes.emit(ils.Metrics())
	mb.metricInstanceDormantProcessesCount.emit(ils.Metrics())
	mb.metricInstancePreconnectProcessesCount.emit(ils.Metrics())
	mb.metricInstanceRunnableProcessesCount.emit(ils.Metrics())
	mb.metricInstanceRunnableTasks.emit(ils.Metrics())
	mb.metricInstanceRunningProcessesCount.emit(ils.Metrics())
	mb.metricInstanceSleepingProcessesCount.emit(ils.Metrics())
	mb.metricInstanceSuspendedProcessesCount.emit(ils.Metrics())
	mb.metricSqlserverAccessPageSplitsPerSec.emit(ils.Metrics())
	mb.metricSqlserverActivequeryCPUTimeMs.emit(ils.Metrics())
	mb.metricSqlserverActivequeryElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverActivequeryGrantedQueryMemoryPages.emit(ils.Metrics())
	mb.metricSqlserverActivequeryLogicalReads.emit(ils.Metrics())
	mb.metricSqlserverActivequeryReads.emit(ils.Metrics())
	mb.metricSqlserverActivequeryRowCount.emit(ils.Metrics())
	mb.metricSqlserverActivequeryWaitTimeSeconds.emit(ils.Metrics())
	mb.metricSqlserverActivequeryWrites.emit(ils.Metrics())
	mb.metricSqlserverBufferCacheHitRatio.emit(ils.Metrics())
	mb.metricSqlserverBufferCheckpointPagesPerSec.emit(ils.Metrics())
	mb.metricSqlserverBufferPageLifeExpectancy.emit(ils.Metrics())
	mb.metricSqlserverBufferPoolHitPercent.emit(ils.Metrics())
	mb.metricSqlserverBufferpoolBatchRequestsPerSec.emit(ils.Metrics())
	mb.metricSqlserverBufferpoolPageLifeExpectancyMs.emit(ils.Metrics())
	mb.metricSqlserverConnectionsUser.emit(ils.Metrics())
	mb.metricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes.emit(ils.Metrics())
	mb.metricSqlserverDatabaseIoStallInMilliseconds.emit(ils.Metrics())
	mb.metricSqlserverDatabaseLogBytesFlushesPerSec.emit(ils.Metrics())
	mb.metricSqlserverDatabaseLogFlushWaitsPerSec.emit(ils.Metrics())
	mb.metricSqlserverDatabaseLogFlushesPerSec.emit(ils.Metrics())
	mb.metricSqlserverDatabaseLogTransactionGrowth.emit(ils.Metrics())
	mb.metricSqlserverDatabaseLogUsedSpaceMB.emit(ils.Metrics())
	mb.metricSqlserverDatabaseMaxDiskSizeInBytes.emit(ils.Metrics())
	mb.metricSqlserverDatabasePageFileAvailable.emit(ils.Metrics())
	mb.metricSqlserverDatabasePageFileTotal.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalCreateDate.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsApplicationRoles.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsOld.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsOrphanedUsers.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsRecentlyCreated.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsRoles.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsSQLUsers.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsTotal.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsUsers.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsWindowsUsers.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembersApplicationRoles.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembersCrossRole.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembersHighPrivilege.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembersUnique.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembershipActive.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembershipsActive.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembershipsCustom.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembershipsNested.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembershipsTotal.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembershipsUsers.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleNestingLevel.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRolePermissionMemberCount.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRolePermissionRiskLevel.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRolePermissionsInherited.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleRolesEmpty.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleRolesWithMembers.emit(ils.Metrics())
	mb.metricSqlserverDatabaseSizeDataSizeMB.emit(ils.Metrics())
	mb.metricSqlserverDatabaseSizeTotalSizeMB.emit(ils.Metrics())
	mb.metricSqlserverDatabaseTransactionsActive.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterAgClusterType.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterAgFailureConditionLevel.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterAgHealthCheckTimeout.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterAgReplicaRole.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterAgSynchronizationHealth.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterFlowControlTimeMs.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterLogBytesReceivedPerSec.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterLogSendQueueKb.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterRedoQueueKb.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterRedoRateKbSec.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterTransactionDelayMs.emit(ils.Metrics())
	mb.metricSqlserverIndividualQueryTotalCPUMs.emit(ils.Metrics())
	mb.metricSqlserverIndividualQueryTotalElapsedMs.emit(ils.Metrics())
	mb.metricSqlserverInstanceBufferPoolSize.emit(ils.Metrics())
	mb.metricSqlserverInstanceCompilationsPerBatch.emit(ils.Metrics())
	mb.metricSqlserverInstanceForcedParameterizationsPerSec.emit(ils.Metrics())
	mb.metricSqlserverInstanceFullScansRate.emit(ils.Metrics())
	mb.metricSqlserverInstanceLockTimeoutsRate.emit(ils.Metrics())
	mb.metricSqlserverInstanceMemoryAvailable.emit(ils.Metrics())
	mb.metricSqlserverInstanceMemoryTotal.emit(ils.Metrics())
	mb.metricSqlserverInstanceMemoryUtilization.emit(ils.Metrics())
	mb.metricSqlserverInstancePageSplitsPerBatch.emit(ils.Metrics())
	mb.metricSqlserverInstanceTargetMemoryKb.emit(ils.Metrics())
	mb.metricSqlserverInstanceTransactionsPerSec.emit(ils.Metrics())
	mb.metricSqlserverLockModeBulkUpdate.emit(ils.Metrics())
	mb.metricSqlserverLockModeExclusive.emit(ils.Metrics())
	mb.metricSqlserverLockModeIntent.emit(ils.Metrics())
	mb.metricSqlserverLockModeSchema.emit(ils.Metrics())
	mb.metricSqlserverLockModeShared.emit(ils.Metrics())
	mb.metricSqlserverLockModeSharedIntentExclusive.emit(ils.Metrics())
	mb.metricSqlserverLockModeTotal.emit(ils.Metrics())
	mb.metricSqlserverLockModeUpdate.emit(ils.Metrics())
	mb.metricSqlserverLockResourceAllocationUnit.emit(ils.Metrics())
	mb.metricSqlserverLockResourceApplication.emit(ils.Metrics())
	mb.metricSqlserverLockResourceDatabaseLevel.emit(ils.Metrics())
	mb.metricSqlserverLockResourceExtent.emit(ils.Metrics())
	mb.metricSqlserverLockResourceFile.emit(ils.Metrics())
	mb.metricSqlserverLockResourceHobt.emit(ils.Metrics())
	mb.metricSqlserverLockResourceKey.emit(ils.Metrics())
	mb.metricSqlserverLockResourceMetadata.emit(ils.Metrics())
	mb.metricSqlserverLockResourcePage.emit(ils.Metrics())
	mb.metricSqlserverLockResourceRow.emit(ils.Metrics())
	mb.metricSqlserverLockResourceTable.emit(ils.Metrics())
	mb.metricSqlserverLockResourceTotal.emit(ils.Metrics())
	mb.metricSqlserverLockedObject.emit(ils.Metrics())
	mb.metricSqlserverMemoryTarget.emit(ils.Metrics())
	mb.metricSqlserverMemoryTotal.emit(ils.Metrics())
	mb.metricSqlserverPlanAvgElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverPlanAvgLogicalReads.emit(ils.Metrics())
	mb.metricSqlserverPlanAvgLogicalWrites.emit(ils.Metrics())
	mb.metricSqlserverPlanAvgWorkerTimeMs.emit(ils.Metrics())
	mb.metricSqlserverPlanExecutionCount.emit(ils.Metrics())
	mb.metricSqlserverPlanLastDop.emit(ils.Metrics())
	mb.metricSqlserverPlanLastGrantKb.emit(ils.Metrics())
	mb.metricSqlserverPlanLastSpills.emit(ils.Metrics())
	mb.metricSqlserverPlanMaxElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverPlanMinElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverPlanTotalElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSecurityServerPrincipalsCount.emit(ils.Metrics())
	mb.metricSqlserverSecurityServerRoleMembersCount.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryAvgDiskReads.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryAvgDiskWrites.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryAvgRowsProcessed.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryHistoricalAvgCPUTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryHistoricalAvgElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryHistoricalExecutionCount.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalAvgElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalExecutionCount.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryLastDop.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryLastElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryLastGrantKb.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryLastSpills.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryLastUsedGrantKb.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryMaxElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryMaxSpills.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryMinElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryQueryText.emit(ils.Metrics())
	mb.metricSqlserverStatsConnections.emit(ils.Metrics())
	mb.metricSqlserverStatsDeadlocksPerSec.emit(ils.Metrics())
	mb.metricSqlserverStatsKillConnectionErrorsPerSec.emit(ils.Metrics())
	mb.metricSqlserverStatsLockWaitsPerSec.emit(ils.Metrics())
	mb.metricSqlserverStatsSQLCompilationsPerSec.emit(ils.Metrics())
	mb.metricSqlserverStatsSQLRecompilationsPerSec.emit(ils.Metrics())
	mb.metricSqlserverStatsUserErrorsPerSec.emit(ils.Metrics())
	mb.metricSqlserverTempdbAllocationWaitsMs.emit(ils.Metrics())
	mb.metricSqlserverTempdbCurrentWaiters.emit(ils.Metrics())
	mb.metricSqlserverTempdbDataFileCount.emit(ils.Metrics())
	mb.metricSqlserverTempdbPagelatchWaitsMs.emit(ils.Metrics())
	mb.metricSqlserverTempdbTotalSizeMb.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolCurrentTasks.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolMaxWorkers.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolRunnableTasks.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolRunningWorkers.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolUtilizationPercent.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolWaitingTasks.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolWorkQueueCount.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationChurnRate.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationFailedLoginEvents.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationLoginsPerSec.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationLogoutsPerSec.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationRate.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationRecentFailedLogins.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationTotalActivity.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationTotalFailedLogins.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationUniqueFailedSources.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsClientCount.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsClientHostsMultiProgram.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsClientProgramsMultiHost.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsClientTopHostConnections.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsClientTopProgramConnections.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsClientUniqueHosts.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsClientUniquePrograms.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsDormant.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsRunnable.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsRunning.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsSleeping.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsStatusCount.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsSuspended.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsTotal.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsUtilizationActiveRatio.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsUtilizationEfficiency.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsUtilizationIdleRatio.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsUtilizationWaitingRatio.emit(ils.Metrics())
	mb.metricSqlserverWaitStatsLatchWaitTimeMs.emit(ils.Metrics())
	mb.metricSqlserverWaitStatsLatchWaitingTasksCount.emit(ils.Metrics())
	mb.metricSqlserverWaitStatsWaitTimeMs.emit(ils.Metrics())
	mb.metricSqlserverWaitStatsWaitingTasksCount.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}
	for attr, filter := range mb.resourceAttributeIncludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && !filter.Matches(val.AsString()) {
			return
		}
	}
	for attr, filter := range mb.resourceAttributeExcludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && filter.Matches(val.AsString()) {
			return
		}
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordActiveConnectionsDataPoint adds a data point to activeConnections metric.
func (mb *MetricsBuilder) RecordActiveConnectionsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricActiveConnections.recordDataPoint(mb.startTime, ts, val)
}

// RecordInstanceBackgroundProcessesCountDataPoint adds a data point to instance.backgroundProcessesCount metric.
func (mb *MetricsBuilder) RecordInstanceBackgroundProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricInstanceBackgroundProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordInstanceBlockedProcessesCountDataPoint adds a data point to instance.blockedProcessesCount metric.
func (mb *MetricsBuilder) RecordInstanceBlockedProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricInstanceBlockedProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordInstanceDiskInBytesDataPoint adds a data point to instance.diskInBytes metric.
func (mb *MetricsBuilder) RecordInstanceDiskInBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricInstanceDiskInBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordInstanceDormantProcessesCountDataPoint adds a data point to instance.dormantProcessesCount metric.
func (mb *MetricsBuilder) RecordInstanceDormantProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricInstanceDormantProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordInstancePreconnectProcessesCountDataPoint adds a data point to instance.preconnectProcessesCount metric.
func (mb *MetricsBuilder) RecordInstancePreconnectProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricInstancePreconnectProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordInstanceRunnableProcessesCountDataPoint adds a data point to instance.runnableProcessesCount metric.
func (mb *MetricsBuilder) RecordInstanceRunnableProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricInstanceRunnableProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordInstanceRunnableTasksDataPoint adds a data point to instance.runnableTasks metric.
func (mb *MetricsBuilder) RecordInstanceRunnableTasksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricInstanceRunnableTasks.recordDataPoint(mb.startTime, ts, val)
}

// RecordInstanceRunningProcessesCountDataPoint adds a data point to instance.runningProcessesCount metric.
func (mb *MetricsBuilder) RecordInstanceRunningProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricInstanceRunningProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordInstanceSleepingProcessesCountDataPoint adds a data point to instance.sleepingProcessesCount metric.
func (mb *MetricsBuilder) RecordInstanceSleepingProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricInstanceSleepingProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordInstanceSuspendedProcessesCountDataPoint adds a data point to instance.suspendedProcessesCount metric.
func (mb *MetricsBuilder) RecordInstanceSuspendedProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricInstanceSuspendedProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverAccessPageSplitsPerSecDataPoint adds a data point to sqlserver.access.page_splits_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverAccessPageSplitsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverAccessPageSplitsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverActivequeryCPUTimeMsDataPoint adds a data point to sqlserver.activequery.cpu_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryCPUTimeMsDataPoint(ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	mb.metricSqlserverActivequeryCPUTimeMs.recordDataPoint(mb.startTime, ts, val, sessionIDAttributeValue, requestIDAttributeValue, databaseNameAttributeValue, loginNameAttributeValue, hostNameAttributeValue, programNameAttributeValue, requestCommandAttributeValue, requestStatusAttributeValue, sessionStatusAttributeValue, clientInterfaceNameAttributeValue, waitTypeAttributeValue, waitTypeDescriptionAttributeValue, waitTypeCategoryAttributeValue, waitResourceAttributeValue, waitResourceObjectNameAttributeValue, waitResourceDatabaseNameAttributeValue, waitResourceTypeAttributeValue, waitResourceDescriptionAttributeValue, waitResourceSchemaNameAttributeValue, waitResourceTableNameAttributeValue, waitResourceObjectTypeAttributeValue, waitResourceIndexNameAttributeValue, waitResourceIndexTypeAttributeValue, lastWaitTypeAttributeValue, lastWaitTypeDescriptionAttributeValue, requestStartTimeAttributeValue, collectionTimestampAttributeValue, transactionIDAttributeValue, openTransactionCountAttributeValue, transactionIsolationLevelAttributeValue, degreeOfParallelismAttributeValue, parallelWorkerCountAttributeValue, blockingSessionIDAttributeValue, blockingLoginNameAttributeValue, blockingHostNameAttributeValue, blockingProgramNameAttributeValue, blockingStatusAttributeValue, blockingIsolationLevelAttributeValue, blockingOpenTransactionCountAttributeValue, queryTextAttributeValue, queryIDAttributeValue, planHandleAttributeValue)
}

// RecordSqlserverActivequeryElapsedTimeMsDataPoint adds a data point to sqlserver.activequery.elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryElapsedTimeMsDataPoint(ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	mb.metricSqlserverActivequeryElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, sessionIDAttributeValue, requestIDAttributeValue, databaseNameAttributeValue, loginNameAttributeValue, hostNameAttributeValue, programNameAttributeValue, requestCommandAttributeValue, requestStatusAttributeValue, sessionStatusAttributeValue, clientInterfaceNameAttributeValue, waitTypeAttributeValue, waitTypeDescriptionAttributeValue, waitTypeCategoryAttributeValue, waitResourceAttributeValue, waitResourceObjectNameAttributeValue, waitResourceDatabaseNameAttributeValue, waitResourceTypeAttributeValue, waitResourceDescriptionAttributeValue, waitResourceSchemaNameAttributeValue, waitResourceTableNameAttributeValue, waitResourceObjectTypeAttributeValue, waitResourceIndexNameAttributeValue, waitResourceIndexTypeAttributeValue, lastWaitTypeAttributeValue, lastWaitTypeDescriptionAttributeValue, requestStartTimeAttributeValue, collectionTimestampAttributeValue, transactionIDAttributeValue, openTransactionCountAttributeValue, transactionIsolationLevelAttributeValue, degreeOfParallelismAttributeValue, parallelWorkerCountAttributeValue, blockingSessionIDAttributeValue, blockingLoginNameAttributeValue, blockingHostNameAttributeValue, blockingProgramNameAttributeValue, blockingStatusAttributeValue, blockingIsolationLevelAttributeValue, blockingOpenTransactionCountAttributeValue, queryTextAttributeValue, queryIDAttributeValue, planHandleAttributeValue)
}

// RecordSqlserverActivequeryGrantedQueryMemoryPagesDataPoint adds a data point to sqlserver.activequery.granted_query_memory_pages metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryGrantedQueryMemoryPagesDataPoint(ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	mb.metricSqlserverActivequeryGrantedQueryMemoryPages.recordDataPoint(mb.startTime, ts, val, sessionIDAttributeValue, requestIDAttributeValue, databaseNameAttributeValue, loginNameAttributeValue, hostNameAttributeValue, programNameAttributeValue, requestCommandAttributeValue, requestStatusAttributeValue, sessionStatusAttributeValue, clientInterfaceNameAttributeValue, waitTypeAttributeValue, waitTypeDescriptionAttributeValue, waitTypeCategoryAttributeValue, waitResourceAttributeValue, waitResourceObjectNameAttributeValue, waitResourceDatabaseNameAttributeValue, waitResourceTypeAttributeValue, waitResourceDescriptionAttributeValue, waitResourceSchemaNameAttributeValue, waitResourceTableNameAttributeValue, waitResourceObjectTypeAttributeValue, waitResourceIndexNameAttributeValue, waitResourceIndexTypeAttributeValue, lastWaitTypeAttributeValue, lastWaitTypeDescriptionAttributeValue, requestStartTimeAttributeValue, collectionTimestampAttributeValue, transactionIDAttributeValue, openTransactionCountAttributeValue, transactionIsolationLevelAttributeValue, degreeOfParallelismAttributeValue, parallelWorkerCountAttributeValue, blockingSessionIDAttributeValue, blockingLoginNameAttributeValue, blockingHostNameAttributeValue, blockingProgramNameAttributeValue, blockingStatusAttributeValue, blockingIsolationLevelAttributeValue, blockingOpenTransactionCountAttributeValue, queryTextAttributeValue, queryIDAttributeValue, planHandleAttributeValue)
}

// RecordSqlserverActivequeryLogicalReadsDataPoint adds a data point to sqlserver.activequery.logical_reads metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryLogicalReadsDataPoint(ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	mb.metricSqlserverActivequeryLogicalReads.recordDataPoint(mb.startTime, ts, val, sessionIDAttributeValue, requestIDAttributeValue, databaseNameAttributeValue, loginNameAttributeValue, hostNameAttributeValue, programNameAttributeValue, requestCommandAttributeValue, requestStatusAttributeValue, sessionStatusAttributeValue, clientInterfaceNameAttributeValue, waitTypeAttributeValue, waitTypeDescriptionAttributeValue, waitTypeCategoryAttributeValue, waitResourceAttributeValue, waitResourceObjectNameAttributeValue, waitResourceDatabaseNameAttributeValue, waitResourceTypeAttributeValue, waitResourceDescriptionAttributeValue, waitResourceSchemaNameAttributeValue, waitResourceTableNameAttributeValue, waitResourceObjectTypeAttributeValue, waitResourceIndexNameAttributeValue, waitResourceIndexTypeAttributeValue, lastWaitTypeAttributeValue, lastWaitTypeDescriptionAttributeValue, requestStartTimeAttributeValue, collectionTimestampAttributeValue, transactionIDAttributeValue, openTransactionCountAttributeValue, transactionIsolationLevelAttributeValue, degreeOfParallelismAttributeValue, parallelWorkerCountAttributeValue, blockingSessionIDAttributeValue, blockingLoginNameAttributeValue, blockingHostNameAttributeValue, blockingProgramNameAttributeValue, blockingStatusAttributeValue, blockingIsolationLevelAttributeValue, blockingOpenTransactionCountAttributeValue, queryTextAttributeValue, queryIDAttributeValue, planHandleAttributeValue)
}

// RecordSqlserverActivequeryReadsDataPoint adds a data point to sqlserver.activequery.reads metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryReadsDataPoint(ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	mb.metricSqlserverActivequeryReads.recordDataPoint(mb.startTime, ts, val, sessionIDAttributeValue, requestIDAttributeValue, databaseNameAttributeValue, loginNameAttributeValue, hostNameAttributeValue, programNameAttributeValue, requestCommandAttributeValue, requestStatusAttributeValue, sessionStatusAttributeValue, clientInterfaceNameAttributeValue, waitTypeAttributeValue, waitTypeDescriptionAttributeValue, waitTypeCategoryAttributeValue, waitResourceAttributeValue, waitResourceObjectNameAttributeValue, waitResourceDatabaseNameAttributeValue, waitResourceTypeAttributeValue, waitResourceDescriptionAttributeValue, waitResourceSchemaNameAttributeValue, waitResourceTableNameAttributeValue, waitResourceObjectTypeAttributeValue, waitResourceIndexNameAttributeValue, waitResourceIndexTypeAttributeValue, lastWaitTypeAttributeValue, lastWaitTypeDescriptionAttributeValue, requestStartTimeAttributeValue, collectionTimestampAttributeValue, transactionIDAttributeValue, openTransactionCountAttributeValue, transactionIsolationLevelAttributeValue, degreeOfParallelismAttributeValue, parallelWorkerCountAttributeValue, blockingSessionIDAttributeValue, blockingLoginNameAttributeValue, blockingHostNameAttributeValue, blockingProgramNameAttributeValue, blockingStatusAttributeValue, blockingIsolationLevelAttributeValue, blockingOpenTransactionCountAttributeValue, queryTextAttributeValue, queryIDAttributeValue, planHandleAttributeValue)
}

// RecordSqlserverActivequeryRowCountDataPoint adds a data point to sqlserver.activequery.row_count metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryRowCountDataPoint(ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	mb.metricSqlserverActivequeryRowCount.recordDataPoint(mb.startTime, ts, val, sessionIDAttributeValue, requestIDAttributeValue, databaseNameAttributeValue, loginNameAttributeValue, hostNameAttributeValue, programNameAttributeValue, requestCommandAttributeValue, requestStatusAttributeValue, sessionStatusAttributeValue, clientInterfaceNameAttributeValue, waitTypeAttributeValue, waitTypeDescriptionAttributeValue, waitTypeCategoryAttributeValue, waitResourceAttributeValue, waitResourceObjectNameAttributeValue, waitResourceDatabaseNameAttributeValue, waitResourceTypeAttributeValue, waitResourceDescriptionAttributeValue, waitResourceSchemaNameAttributeValue, waitResourceTableNameAttributeValue, waitResourceObjectTypeAttributeValue, waitResourceIndexNameAttributeValue, waitResourceIndexTypeAttributeValue, lastWaitTypeAttributeValue, lastWaitTypeDescriptionAttributeValue, requestStartTimeAttributeValue, collectionTimestampAttributeValue, transactionIDAttributeValue, openTransactionCountAttributeValue, transactionIsolationLevelAttributeValue, degreeOfParallelismAttributeValue, parallelWorkerCountAttributeValue, blockingSessionIDAttributeValue, blockingLoginNameAttributeValue, blockingHostNameAttributeValue, blockingProgramNameAttributeValue, blockingStatusAttributeValue, blockingIsolationLevelAttributeValue, blockingOpenTransactionCountAttributeValue, queryTextAttributeValue, queryIDAttributeValue, planHandleAttributeValue)
}

// RecordSqlserverActivequeryWaitTimeSecondsDataPoint adds a data point to sqlserver.activequery.wait_time_seconds metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryWaitTimeSecondsDataPoint(ts pcommon.Timestamp, val float64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	mb.metricSqlserverActivequeryWaitTimeSeconds.recordDataPoint(mb.startTime, ts, val, sessionIDAttributeValue, requestIDAttributeValue, databaseNameAttributeValue, loginNameAttributeValue, hostNameAttributeValue, programNameAttributeValue, requestCommandAttributeValue, requestStatusAttributeValue, sessionStatusAttributeValue, clientInterfaceNameAttributeValue, waitTypeAttributeValue, waitTypeDescriptionAttributeValue, waitTypeCategoryAttributeValue, waitResourceAttributeValue, waitResourceObjectNameAttributeValue, waitResourceDatabaseNameAttributeValue, waitResourceTypeAttributeValue, waitResourceDescriptionAttributeValue, waitResourceSchemaNameAttributeValue, waitResourceTableNameAttributeValue, waitResourceObjectTypeAttributeValue, waitResourceIndexNameAttributeValue, waitResourceIndexTypeAttributeValue, lastWaitTypeAttributeValue, lastWaitTypeDescriptionAttributeValue, requestStartTimeAttributeValue, collectionTimestampAttributeValue, transactionIDAttributeValue, openTransactionCountAttributeValue, transactionIsolationLevelAttributeValue, degreeOfParallelismAttributeValue, parallelWorkerCountAttributeValue, blockingSessionIDAttributeValue, blockingLoginNameAttributeValue, blockingHostNameAttributeValue, blockingProgramNameAttributeValue, blockingStatusAttributeValue, blockingIsolationLevelAttributeValue, blockingOpenTransactionCountAttributeValue, queryTextAttributeValue, queryIDAttributeValue, planHandleAttributeValue)
}

// RecordSqlserverActivequeryWritesDataPoint adds a data point to sqlserver.activequery.writes metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryWritesDataPoint(ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, programNameAttributeValue string, requestCommandAttributeValue string, requestStatusAttributeValue string, sessionStatusAttributeValue string, clientInterfaceNameAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceObjectNameAttributeValue string, waitResourceDatabaseNameAttributeValue string, waitResourceTypeAttributeValue string, waitResourceDescriptionAttributeValue string, waitResourceSchemaNameAttributeValue string, waitResourceTableNameAttributeValue string, waitResourceObjectTypeAttributeValue string, waitResourceIndexNameAttributeValue string, waitResourceIndexTypeAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, transactionIsolationLevelAttributeValue int64, degreeOfParallelismAttributeValue int64, parallelWorkerCountAttributeValue int64, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingHostNameAttributeValue string, blockingProgramNameAttributeValue string, blockingStatusAttributeValue string, blockingIsolationLevelAttributeValue int64, blockingOpenTransactionCountAttributeValue int64, queryTextAttributeValue string, queryIDAttributeValue string, planHandleAttributeValue string) {
	mb.metricSqlserverActivequeryWrites.recordDataPoint(mb.startTime, ts, val, sessionIDAttributeValue, requestIDAttributeValue, databaseNameAttributeValue, loginNameAttributeValue, hostNameAttributeValue, programNameAttributeValue, requestCommandAttributeValue, requestStatusAttributeValue, sessionStatusAttributeValue, clientInterfaceNameAttributeValue, waitTypeAttributeValue, waitTypeDescriptionAttributeValue, waitTypeCategoryAttributeValue, waitResourceAttributeValue, waitResourceObjectNameAttributeValue, waitResourceDatabaseNameAttributeValue, waitResourceTypeAttributeValue, waitResourceDescriptionAttributeValue, waitResourceSchemaNameAttributeValue, waitResourceTableNameAttributeValue, waitResourceObjectTypeAttributeValue, waitResourceIndexNameAttributeValue, waitResourceIndexTypeAttributeValue, lastWaitTypeAttributeValue, lastWaitTypeDescriptionAttributeValue, requestStartTimeAttributeValue, collectionTimestampAttributeValue, transactionIDAttributeValue, openTransactionCountAttributeValue, transactionIsolationLevelAttributeValue, degreeOfParallelismAttributeValue, parallelWorkerCountAttributeValue, blockingSessionIDAttributeValue, blockingLoginNameAttributeValue, blockingHostNameAttributeValue, blockingProgramNameAttributeValue, blockingStatusAttributeValue, blockingIsolationLevelAttributeValue, blockingOpenTransactionCountAttributeValue, queryTextAttributeValue, queryIDAttributeValue, planHandleAttributeValue)
}

// RecordSqlserverBufferCacheHitRatioDataPoint adds a data point to sqlserver.buffer.cache_hit_ratio metric.
func (mb *MetricsBuilder) RecordSqlserverBufferCacheHitRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverBufferCacheHitRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverBufferCheckpointPagesPerSecDataPoint adds a data point to sqlserver.buffer.checkpoint_pages_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverBufferCheckpointPagesPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverBufferCheckpointPagesPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverBufferPageLifeExpectancyDataPoint adds a data point to sqlserver.buffer.page_life_expectancy metric.
func (mb *MetricsBuilder) RecordSqlserverBufferPageLifeExpectancyDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverBufferPageLifeExpectancy.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverBufferPoolHitPercentDataPoint adds a data point to sqlserver.bufferPoolHitPercent metric.
func (mb *MetricsBuilder) RecordSqlserverBufferPoolHitPercentDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverBufferPoolHitPercent.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverBufferpoolBatchRequestsPerSecDataPoint adds a data point to sqlserver.bufferpool.batch_requests_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverBufferpoolBatchRequestsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverBufferpoolBatchRequestsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverBufferpoolPageLifeExpectancyMsDataPoint adds a data point to sqlserver.bufferpool.page_life_expectancy_ms metric.
func (mb *MetricsBuilder) RecordSqlserverBufferpoolPageLifeExpectancyMsDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverBufferpoolPageLifeExpectancyMs.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverConnectionsUserDataPoint adds a data point to sqlserver.connections.user metric.
func (mb *MetricsBuilder) RecordSqlserverConnectionsUserDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverConnectionsUser.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverDatabaseBufferpoolSizePerDatabaseInBytesDataPoint adds a data point to sqlserver.database.bufferpool.sizePerDatabaseInBytes metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseBufferpoolSizePerDatabaseInBytesDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseBufferpoolSizePerDatabaseInBytes.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseIoStallInMillisecondsDataPoint adds a data point to sqlserver.database.io.stallInMilliseconds metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseIoStallInMillisecondsDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseIoStallInMilliseconds.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseLogBytesFlushesPerSecDataPoint adds a data point to sqlserver.database.log.bytesFlushesPerSec metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseLogBytesFlushesPerSecDataPoint(ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseLogBytesFlushesPerSec.recordDataPoint(mb.startTime, ts, val, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseLogFlushWaitsPerSecDataPoint adds a data point to sqlserver.database.log.flushWaitsPerSec metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseLogFlushWaitsPerSecDataPoint(ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseLogFlushWaitsPerSec.recordDataPoint(mb.startTime, ts, val, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseLogFlushesPerSecDataPoint adds a data point to sqlserver.database.log.flushesPerSec metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseLogFlushesPerSecDataPoint(ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseLogFlushesPerSec.recordDataPoint(mb.startTime, ts, val, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseLogTransactionGrowthDataPoint adds a data point to sqlserver.database.log.transactionGrowth metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseLogTransactionGrowthDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseLogTransactionGrowth.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseLogUsedSpaceMBDataPoint adds a data point to sqlserver.database.log.usedSpaceMB metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseLogUsedSpaceMBDataPoint(ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseLogUsedSpaceMB.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseMaxDiskSizeInBytesDataPoint adds a data point to sqlserver.database.maxDiskSizeInBytes metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseMaxDiskSizeInBytesDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseMaxDiskSizeInBytes.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabasePageFileAvailableDataPoint adds a data point to sqlserver.database.pageFileAvailable metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePageFileAvailableDataPoint(ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabasePageFileAvailable.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabasePageFileTotalDataPoint adds a data point to sqlserver.database.pageFileTotal metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePageFileTotalDataPoint(ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabasePageFileTotal.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabasePrincipalCreateDateDataPoint adds a data point to sqlserver.database.principal.createDate metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalCreateDateDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, principalNameAttributeValue string, principalTypeAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalCreateDate.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, principalNameAttributeValue, principalTypeAttributeValue)
}

// RecordSqlserverDatabasePrincipalsApplicationRolesDataPoint adds a data point to sqlserver.database.principals.applicationRoles metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsApplicationRolesDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsApplicationRoles.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsOldDataPoint adds a data point to sqlserver.database.principals.old metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsOldDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsOld.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsOrphanedUsersDataPoint adds a data point to sqlserver.database.principals.orphanedUsers metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsOrphanedUsersDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsOrphanedUsers.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsRecentlyCreatedDataPoint adds a data point to sqlserver.database.principals.recentlyCreated metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsRecentlyCreatedDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsRecentlyCreated.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsRolesDataPoint adds a data point to sqlserver.database.principals.roles metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsRolesDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsRoles.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsSQLUsersDataPoint adds a data point to sqlserver.database.principals.sqlUsers metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsSQLUsersDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsSQLUsers.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsTotalDataPoint adds a data point to sqlserver.database.principals.total metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsTotalDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsTotal.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsUsersDataPoint adds a data point to sqlserver.database.principals.users metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsUsersDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsUsers.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsWindowsUsersDataPoint adds a data point to sqlserver.database.principals.windowsUsers metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsWindowsUsersDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsWindowsUsers.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembersApplicationRolesDataPoint adds a data point to sqlserver.database.role.members.applicationRoles metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembersApplicationRolesDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembersApplicationRoles.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembersCrossRoleDataPoint adds a data point to sqlserver.database.role.members.crossRole metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembersCrossRoleDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembersCrossRole.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembersHighPrivilegeDataPoint adds a data point to sqlserver.database.role.members.highPrivilege metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembersHighPrivilegeDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembersHighPrivilege.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembersUniqueDataPoint adds a data point to sqlserver.database.role.members.unique metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembersUniqueDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembersUnique.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembershipActiveDataPoint adds a data point to sqlserver.database.role.membership.active metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembershipActiveDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, roleNameAttributeValue string, memberNameAttributeValue string, roleTypeAttributeValue string, memberTypeAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembershipActive.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, roleNameAttributeValue, memberNameAttributeValue, roleTypeAttributeValue, memberTypeAttributeValue)
}

// RecordSqlserverDatabaseRoleMembershipsActiveDataPoint adds a data point to sqlserver.database.role.memberships.active metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembershipsActiveDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembershipsActive.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembershipsCustomDataPoint adds a data point to sqlserver.database.role.memberships.custom metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembershipsCustomDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembershipsCustom.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembershipsNestedDataPoint adds a data point to sqlserver.database.role.memberships.nested metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembershipsNestedDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembershipsNested.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembershipsTotalDataPoint adds a data point to sqlserver.database.role.memberships.total metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembershipsTotalDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembershipsTotal.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembershipsUsersDataPoint adds a data point to sqlserver.database.role.memberships.users metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembershipsUsersDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembershipsUsers.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleNestingLevelDataPoint adds a data point to sqlserver.database.role.nesting.level metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleNestingLevelDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, parentRoleNameAttributeValue string, childRoleNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleNestingLevel.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, parentRoleNameAttributeValue, childRoleNameAttributeValue)
}

// RecordSqlserverDatabaseRolePermissionMemberCountDataPoint adds a data point to sqlserver.database.role.permission.memberCount metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRolePermissionMemberCountDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, roleNameAttributeValue string, permissionScopeAttributeValue string) {
	mb.metricSqlserverDatabaseRolePermissionMemberCount.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, roleNameAttributeValue, permissionScopeAttributeValue)
}

// RecordSqlserverDatabaseRolePermissionRiskLevelDataPoint adds a data point to sqlserver.database.role.permission.riskLevel metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRolePermissionRiskLevelDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, roleNameAttributeValue string, permissionScopeAttributeValue string) {
	mb.metricSqlserverDatabaseRolePermissionRiskLevel.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, roleNameAttributeValue, permissionScopeAttributeValue)
}

// RecordSqlserverDatabaseRolePermissionsInheritedDataPoint adds a data point to sqlserver.database.role.permissions.inherited metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRolePermissionsInheritedDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, parentRoleNameAttributeValue string, childRoleNameAttributeValue string) {
	mb.metricSqlserverDatabaseRolePermissionsInherited.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, parentRoleNameAttributeValue, childRoleNameAttributeValue)
}

// RecordSqlserverDatabaseRoleRolesEmptyDataPoint adds a data point to sqlserver.database.role.roles.empty metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleRolesEmptyDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleRolesEmpty.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleRolesWithMembersDataPoint adds a data point to sqlserver.database.role.roles.withMembers metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleRolesWithMembersDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleRolesWithMembers.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseSizeDataSizeMBDataPoint adds a data point to sqlserver.database.size.dataSizeMB metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseSizeDataSizeMBDataPoint(ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseSizeDataSizeMB.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseSizeTotalSizeMBDataPoint adds a data point to sqlserver.database.size.totalSizeMB metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseSizeTotalSizeMBDataPoint(ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseSizeTotalSizeMB.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseTransactionsActiveDataPoint adds a data point to sqlserver.database.transactions.active metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseTransactionsActiveDataPoint(ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseTransactionsActive.recordDataPoint(mb.startTime, ts, val, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverFailoverClusterAgClusterTypeDataPoint adds a data point to sqlserver.failover_cluster.ag_cluster_type metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterAgClusterTypeDataPoint(ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	mb.metricSqlserverFailoverClusterAgClusterType.recordDataPoint(mb.startTime, ts, val, groupNameAttributeValue, clusterTypeDescAttributeValue)
}

// RecordSqlserverFailoverClusterAgFailureConditionLevelDataPoint adds a data point to sqlserver.failover_cluster.ag_failure_condition_level metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterAgFailureConditionLevelDataPoint(ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	mb.metricSqlserverFailoverClusterAgFailureConditionLevel.recordDataPoint(mb.startTime, ts, val, groupNameAttributeValue, clusterTypeDescAttributeValue)
}

// RecordSqlserverFailoverClusterAgHealthCheckTimeoutDataPoint adds a data point to sqlserver.failover_cluster.ag_health_check_timeout metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterAgHealthCheckTimeoutDataPoint(ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	mb.metricSqlserverFailoverClusterAgHealthCheckTimeout.recordDataPoint(mb.startTime, ts, val, groupNameAttributeValue, clusterTypeDescAttributeValue)
}

// RecordSqlserverFailoverClusterAgReplicaRoleDataPoint adds a data point to sqlserver.failover_cluster.ag_replica_role metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterAgReplicaRoleDataPoint(ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, roleDescAttributeValue string, synchronizationHealthDescAttributeValue string) {
	mb.metricSqlserverFailoverClusterAgReplicaRole.recordDataPoint(mb.startTime, ts, val, replicaServerNameAttributeValue, roleDescAttributeValue, synchronizationHealthDescAttributeValue)
}

// RecordSqlserverFailoverClusterAgSynchronizationHealthDataPoint adds a data point to sqlserver.failover_cluster.ag_synchronization_health metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterAgSynchronizationHealthDataPoint(ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, roleDescAttributeValue string, synchronizationHealthDescAttributeValue string) {
	mb.metricSqlserverFailoverClusterAgSynchronizationHealth.recordDataPoint(mb.startTime, ts, val, replicaServerNameAttributeValue, roleDescAttributeValue, synchronizationHealthDescAttributeValue)
}

// RecordSqlserverFailoverClusterFlowControlTimeMsDataPoint adds a data point to sqlserver.failover_cluster.flow_control_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterFlowControlTimeMsDataPoint(ts pcommon.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricSqlserverFailoverClusterFlowControlTimeMs.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordSqlserverFailoverClusterLogBytesReceivedPerSecDataPoint adds a data point to sqlserver.failover_cluster.log_bytes_received_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterLogBytesReceivedPerSecDataPoint(ts pcommon.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricSqlserverFailoverClusterLogBytesReceivedPerSec.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordSqlserverFailoverClusterLogSendQueueKbDataPoint adds a data point to sqlserver.failover_cluster.log_send_queue_kb metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterLogSendQueueKbDataPoint(ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, databaseNameAttributeValue string) {
	mb.metricSqlserverFailoverClusterLogSendQueueKb.recordDataPoint(mb.startTime, ts, val, replicaServerNameAttributeValue, databaseNameAttributeValue)
}

// RecordSqlserverFailoverClusterRedoQueueKbDataPoint adds a data point to sqlserver.failover_cluster.redo_queue_kb metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterRedoQueueKbDataPoint(ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, databaseNameAttributeValue string) {
	mb.metricSqlserverFailoverClusterRedoQueueKb.recordDataPoint(mb.startTime, ts, val, replicaServerNameAttributeValue, databaseNameAttributeValue)
}

// RecordSqlserverFailoverClusterRedoRateKbSecDataPoint adds a data point to sqlserver.failover_cluster.redo_rate_kb_sec metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterRedoRateKbSecDataPoint(ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, databaseNameAttributeValue string) {
	mb.metricSqlserverFailoverClusterRedoRateKbSec.recordDataPoint(mb.startTime, ts, val, replicaServerNameAttributeValue, databaseNameAttributeValue)
}

// RecordSqlserverFailoverClusterTransactionDelayMsDataPoint adds a data point to sqlserver.failover_cluster.transaction_delay_ms metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterTransactionDelayMsDataPoint(ts pcommon.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricSqlserverFailoverClusterTransactionDelayMs.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordSqlserverIndividualQueryTotalCPUMsDataPoint adds a data point to sqlserver.individual_query.total_cpu_ms metric.
func (mb *MetricsBuilder) RecordSqlserverIndividualQueryTotalCPUMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanIDAttributeValue string, queryTextAttributeValue string, creationTimeAttributeValue string, lastExecutionTimeAttributeValue string) {
	mb.metricSqlserverIndividualQueryTotalCPUMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanIDAttributeValue, queryTextAttributeValue, creationTimeAttributeValue, lastExecutionTimeAttributeValue)
}

// RecordSqlserverIndividualQueryTotalElapsedMsDataPoint adds a data point to sqlserver.individual_query.total_elapsed_ms metric.
func (mb *MetricsBuilder) RecordSqlserverIndividualQueryTotalElapsedMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanIDAttributeValue string, queryTextAttributeValue string, creationTimeAttributeValue string, lastExecutionTimeAttributeValue string) {
	mb.metricSqlserverIndividualQueryTotalElapsedMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanIDAttributeValue, queryTextAttributeValue, creationTimeAttributeValue, lastExecutionTimeAttributeValue)
}

// RecordSqlserverInstanceBufferPoolSizeDataPoint adds a data point to sqlserver.instance.buffer_pool_size metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceBufferPoolSizeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceBufferPoolSize.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceCompilationsPerBatchDataPoint adds a data point to sqlserver.instance.compilations_per_batch metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceCompilationsPerBatchDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceCompilationsPerBatch.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceForcedParameterizationsPerSecDataPoint adds a data point to sqlserver.instance.forced_parameterizations_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceForcedParameterizationsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceForcedParameterizationsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceFullScansRateDataPoint adds a data point to sqlserver.instance.full_scans_rate metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceFullScansRateDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceFullScansRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceLockTimeoutsRateDataPoint adds a data point to sqlserver.instance.lock_timeouts_rate metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceLockTimeoutsRateDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceLockTimeoutsRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceMemoryAvailableDataPoint adds a data point to sqlserver.instance.memoryAvailable metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceMemoryAvailableDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceMemoryTotalDataPoint adds a data point to sqlserver.instance.memoryTotal metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceMemoryTotalDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceMemoryTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceMemoryUtilizationDataPoint adds a data point to sqlserver.instance.memoryUtilization metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceMemoryUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceMemoryUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstancePageSplitsPerBatchDataPoint adds a data point to sqlserver.instance.page_splits_per_batch metric.
func (mb *MetricsBuilder) RecordSqlserverInstancePageSplitsPerBatchDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstancePageSplitsPerBatch.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceTargetMemoryKbDataPoint adds a data point to sqlserver.instance.target_memory_kb metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceTargetMemoryKbDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceTargetMemoryKb.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceTransactionsPerSecDataPoint adds a data point to sqlserver.instance.transactions_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceTransactionsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceTransactionsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockModeBulkUpdateDataPoint adds a data point to sqlserver.lock.mode.bulk_update metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeBulkUpdateDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeBulkUpdate.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeExclusiveDataPoint adds a data point to sqlserver.lock.mode.exclusive metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeExclusiveDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeExclusive.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeIntentDataPoint adds a data point to sqlserver.lock.mode.intent metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeIntentDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeIntent.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeSchemaDataPoint adds a data point to sqlserver.lock.mode.schema metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeSchemaDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeSchema.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeSharedDataPoint adds a data point to sqlserver.lock.mode.shared metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeSharedDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeShared.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeSharedIntentExclusiveDataPoint adds a data point to sqlserver.lock.mode.shared_intent_exclusive metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeSharedIntentExclusiveDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeSharedIntentExclusive.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeTotalDataPoint adds a data point to sqlserver.lock.mode.total metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeTotalDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeTotal.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeUpdateDataPoint adds a data point to sqlserver.lock.mode.update metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeUpdateDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeUpdate.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceAllocationUnitDataPoint adds a data point to sqlserver.lock.resource.allocation_unit metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceAllocationUnitDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceAllocationUnit.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceApplicationDataPoint adds a data point to sqlserver.lock.resource.application metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceApplicationDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceApplication.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceDatabaseLevelDataPoint adds a data point to sqlserver.lock.resource.database_level metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceDatabaseLevelDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceDatabaseLevel.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceExtentDataPoint adds a data point to sqlserver.lock.resource.extent metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceExtentDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceExtent.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceFileDataPoint adds a data point to sqlserver.lock.resource.file metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceFileDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceFile.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceHobtDataPoint adds a data point to sqlserver.lock.resource.hobt metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceHobtDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceHobt.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceKeyDataPoint adds a data point to sqlserver.lock.resource.key metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceKeyDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceKey.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceMetadataDataPoint adds a data point to sqlserver.lock.resource.metadata metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceMetadataDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceMetadata.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourcePageDataPoint adds a data point to sqlserver.lock.resource.page metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourcePageDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourcePage.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceRowDataPoint adds a data point to sqlserver.lock.resource.row metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceRowDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceRow.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceTableDataPoint adds a data point to sqlserver.lock.resource.table metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceTableDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceTable.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceTotalDataPoint adds a data point to sqlserver.lock.resource.total metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceTotalDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceTotal.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockedObjectDataPoint adds a data point to sqlserver.locked_object metric.
func (mb *MetricsBuilder) RecordSqlserverLockedObjectDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockedObject.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverMemoryTargetDataPoint adds a data point to sqlserver.memory.target metric.
func (mb *MetricsBuilder) RecordSqlserverMemoryTargetDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverMemoryTarget.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverMemoryTotalDataPoint adds a data point to sqlserver.memory.total metric.
func (mb *MetricsBuilder) RecordSqlserverMemoryTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverMemoryTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverPlanAvgElapsedTimeMsDataPoint adds a data point to sqlserver.plan.avg_elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverPlanAvgElapsedTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	mb.metricSqlserverPlanAvgElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanHashAttributeValue, sessionIDAttributeValue, requestIDAttributeValue, requestStartTimeAttributeValue, lastExecutionTimeAttributeValue, creationTimeAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue)
}

// RecordSqlserverPlanAvgLogicalReadsDataPoint adds a data point to sqlserver.plan.avg_logical_reads metric.
func (mb *MetricsBuilder) RecordSqlserverPlanAvgLogicalReadsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	mb.metricSqlserverPlanAvgLogicalReads.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanHashAttributeValue, sessionIDAttributeValue, requestIDAttributeValue, requestStartTimeAttributeValue, lastExecutionTimeAttributeValue, creationTimeAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue)
}

// RecordSqlserverPlanAvgLogicalWritesDataPoint adds a data point to sqlserver.plan.avg_logical_writes metric.
func (mb *MetricsBuilder) RecordSqlserverPlanAvgLogicalWritesDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	mb.metricSqlserverPlanAvgLogicalWrites.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanHashAttributeValue, sessionIDAttributeValue, requestIDAttributeValue, requestStartTimeAttributeValue, lastExecutionTimeAttributeValue, creationTimeAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue)
}

// RecordSqlserverPlanAvgWorkerTimeMsDataPoint adds a data point to sqlserver.plan.avg_worker_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverPlanAvgWorkerTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	mb.metricSqlserverPlanAvgWorkerTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanHashAttributeValue, sessionIDAttributeValue, requestIDAttributeValue, requestStartTimeAttributeValue, lastExecutionTimeAttributeValue, creationTimeAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue)
}

// RecordSqlserverPlanExecutionCountDataPoint adds a data point to sqlserver.plan.execution_count metric.
func (mb *MetricsBuilder) RecordSqlserverPlanExecutionCountDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	mb.metricSqlserverPlanExecutionCount.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanHashAttributeValue, sessionIDAttributeValue, requestIDAttributeValue, requestStartTimeAttributeValue, lastExecutionTimeAttributeValue, creationTimeAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue)
}

// RecordSqlserverPlanLastDopDataPoint adds a data point to sqlserver.plan.last_dop metric.
func (mb *MetricsBuilder) RecordSqlserverPlanLastDopDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	mb.metricSqlserverPlanLastDop.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanHashAttributeValue, sessionIDAttributeValue, requestIDAttributeValue, requestStartTimeAttributeValue, lastExecutionTimeAttributeValue, creationTimeAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue)
}

// RecordSqlserverPlanLastGrantKbDataPoint adds a data point to sqlserver.plan.last_grant_kb metric.
func (mb *MetricsBuilder) RecordSqlserverPlanLastGrantKbDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	mb.metricSqlserverPlanLastGrantKb.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanHashAttributeValue, sessionIDAttributeValue, requestIDAttributeValue, requestStartTimeAttributeValue, lastExecutionTimeAttributeValue, creationTimeAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue)
}

// RecordSqlserverPlanLastSpillsDataPoint adds a data point to sqlserver.plan.last_spills metric.
func (mb *MetricsBuilder) RecordSqlserverPlanLastSpillsDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	mb.metricSqlserverPlanLastSpills.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanHashAttributeValue, sessionIDAttributeValue, requestIDAttributeValue, requestStartTimeAttributeValue, lastExecutionTimeAttributeValue, creationTimeAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue)
}

// RecordSqlserverPlanMaxElapsedTimeMsDataPoint adds a data point to sqlserver.plan.max_elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverPlanMaxElapsedTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	mb.metricSqlserverPlanMaxElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanHashAttributeValue, sessionIDAttributeValue, requestIDAttributeValue, requestStartTimeAttributeValue, lastExecutionTimeAttributeValue, creationTimeAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue)
}

// RecordSqlserverPlanMinElapsedTimeMsDataPoint adds a data point to sqlserver.plan.min_elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverPlanMinElapsedTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	mb.metricSqlserverPlanMinElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanHashAttributeValue, sessionIDAttributeValue, requestIDAttributeValue, requestStartTimeAttributeValue, lastExecutionTimeAttributeValue, creationTimeAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue)
}

// RecordSqlserverPlanTotalElapsedTimeMsDataPoint adds a data point to sqlserver.plan.total_elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverPlanTotalElapsedTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanHashAttributeValue string, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string) {
	mb.metricSqlserverPlanTotalElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanHashAttributeValue, sessionIDAttributeValue, requestIDAttributeValue, requestStartTimeAttributeValue, lastExecutionTimeAttributeValue, creationTimeAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue)
}

// RecordSqlserverSecurityServerPrincipalsCountDataPoint adds a data point to sqlserver.security.server_principals_count metric.
func (mb *MetricsBuilder) RecordSqlserverSecurityServerPrincipalsCountDataPoint(ts pcommon.Timestamp, val int64, metricTypeAttributeValue string) {
	mb.metricSqlserverSecurityServerPrincipalsCount.recordDataPoint(mb.startTime, ts, val, metricTypeAttributeValue)
}

// RecordSqlserverSecurityServerRoleMembersCountDataPoint adds a data point to sqlserver.security.server_role_members_count metric.
func (mb *MetricsBuilder) RecordSqlserverSecurityServerRoleMembersCountDataPoint(ts pcommon.Timestamp, val int64, metricTypeAttributeValue string) {
	mb.metricSqlserverSecurityServerRoleMembersCount.recordDataPoint(mb.startTime, ts, val, metricTypeAttributeValue)
}

// RecordSqlserverSlowqueryAvgDiskReadsDataPoint adds a data point to sqlserver.slowquery.avg_disk_reads metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryAvgDiskReadsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryAvgDiskReads.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryAvgDiskWritesDataPoint adds a data point to sqlserver.slowquery.avg_disk_writes metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryAvgDiskWritesDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryAvgDiskWrites.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryAvgRowsProcessedDataPoint adds a data point to sqlserver.slowquery.avg_rows_processed metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryAvgRowsProcessedDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryAvgRowsProcessed.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryHistoricalAvgCPUTimeMsDataPoint adds a data point to sqlserver.slowquery.historical_avg_cpu_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryHistoricalAvgCPUTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryHistoricalAvgCPUTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryHistoricalAvgElapsedTimeMsDataPoint adds a data point to sqlserver.slowquery.historical_avg_elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryHistoricalAvgElapsedTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string, collectionTimestampAttributeValue string, lastExecutionTimestampAttributeValue string) {
	mb.metricSqlserverSlowqueryHistoricalAvgElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue, collectionTimestampAttributeValue, lastExecutionTimestampAttributeValue)
}

// RecordSqlserverSlowqueryHistoricalExecutionCountDataPoint adds a data point to sqlserver.slowquery.historical_execution_count metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryHistoricalExecutionCountDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryHistoricalExecutionCount.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryIntervalAvgElapsedTimeMsDataPoint adds a data point to sqlserver.slowquery.interval_avg_elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalAvgElapsedTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalAvgElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryIntervalExecutionCountDataPoint adds a data point to sqlserver.slowquery.interval_execution_count metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalExecutionCountDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalExecutionCount.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryLastDopDataPoint adds a data point to sqlserver.slowquery.last_dop metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryLastDopDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryLastDop.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryLastElapsedTimeMsDataPoint adds a data point to sqlserver.slowquery.last_elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryLastElapsedTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryLastElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryLastGrantKbDataPoint adds a data point to sqlserver.slowquery.last_grant_kb metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryLastGrantKbDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryLastGrantKb.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryLastSpillsDataPoint adds a data point to sqlserver.slowquery.last_spills metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryLastSpillsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryLastSpills.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryLastUsedGrantKbDataPoint adds a data point to sqlserver.slowquery.last_used_grant_kb metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryLastUsedGrantKbDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryLastUsedGrantKb.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryMaxElapsedTimeMsDataPoint adds a data point to sqlserver.slowquery.max_elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryMaxElapsedTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryMaxElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryMaxSpillsDataPoint adds a data point to sqlserver.slowquery.max_spills metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryMaxSpillsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryMaxSpills.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryMinElapsedTimeMsDataPoint adds a data point to sqlserver.slowquery.min_elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryMinElapsedTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string) {
	mb.metricSqlserverSlowqueryMinElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue)
}

// RecordSqlserverSlowqueryQueryTextDataPoint adds a data point to sqlserver.slowquery.query_text metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryQueryTextDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, databaseNameAttributeValue string, schemaNameAttributeValue string, statementTypeAttributeValue string, queryTextAttributeValue string, querySignatureAttributeValue string) {
	mb.metricSqlserverSlowqueryQueryText.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, databaseNameAttributeValue, schemaNameAttributeValue, statementTypeAttributeValue, queryTextAttributeValue, querySignatureAttributeValue)
}

// RecordSqlserverStatsConnectionsDataPoint adds a data point to sqlserver.stats.connections metric.
func (mb *MetricsBuilder) RecordSqlserverStatsConnectionsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsConnections.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverStatsDeadlocksPerSecDataPoint adds a data point to sqlserver.stats.deadlocks_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverStatsDeadlocksPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsDeadlocksPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverStatsKillConnectionErrorsPerSecDataPoint adds a data point to sqlserver.stats.kill_connection_errors_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverStatsKillConnectionErrorsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsKillConnectionErrorsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverStatsLockWaitsPerSecDataPoint adds a data point to sqlserver.stats.lock_waits_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverStatsLockWaitsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsLockWaitsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverStatsSQLCompilationsPerSecDataPoint adds a data point to sqlserver.stats.sql_compilations_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverStatsSQLCompilationsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsSQLCompilationsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverStatsSQLRecompilationsPerSecDataPoint adds a data point to sqlserver.stats.sql_recompilations_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverStatsSQLRecompilationsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsSQLRecompilationsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverStatsUserErrorsPerSecDataPoint adds a data point to sqlserver.stats.user_errors_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverStatsUserErrorsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsUserErrorsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverTempdbAllocationWaitsMsDataPoint adds a data point to sqlserver.tempdb.allocation_waits_ms metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbAllocationWaitsMsDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverTempdbAllocationWaitsMs.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, tempdbHealthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverTempdbCurrentWaitersDataPoint adds a data point to sqlserver.tempdb.current_waiters metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbCurrentWaitersDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverTempdbCurrentWaiters.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, tempdbHealthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverTempdbDataFileCountDataPoint adds a data point to sqlserver.tempdb.data_file_count metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbDataFileCountDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverTempdbDataFileCount.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, tempdbHealthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverTempdbPagelatchWaitsMsDataPoint adds a data point to sqlserver.tempdb.pagelatch_waits_ms metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbPagelatchWaitsMsDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverTempdbPagelatchWaitsMs.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, tempdbHealthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverTempdbTotalSizeMbDataPoint adds a data point to sqlserver.tempdb.total_size_mb metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbTotalSizeMbDataPoint(ts pcommon.Timestamp, val float64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverTempdbTotalSizeMb.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, tempdbHealthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolCurrentTasksDataPoint adds a data point to sqlserver.threadpool.current_tasks metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolCurrentTasksDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolCurrentTasks.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolMaxWorkersDataPoint adds a data point to sqlserver.threadpool.max_workers metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolMaxWorkersDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolMaxWorkers.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolRunnableTasksDataPoint adds a data point to sqlserver.threadpool.runnable_tasks metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolRunnableTasksDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolRunnableTasks.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolRunningWorkersDataPoint adds a data point to sqlserver.threadpool.running_workers metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolRunningWorkersDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolRunningWorkers.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolUtilizationPercentDataPoint adds a data point to sqlserver.threadpool.utilization_percent metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolUtilizationPercentDataPoint(ts pcommon.Timestamp, val float64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolUtilizationPercent.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolWaitingTasksDataPoint adds a data point to sqlserver.threadpool.waiting_tasks metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolWaitingTasksDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolWaitingTasks.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolWorkQueueCountDataPoint adds a data point to sqlserver.threadpool.work_queue_count metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolWorkQueueCountDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolWorkQueueCount.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverUserConnectionsAuthenticationChurnRateDataPoint adds a data point to sqlserver.user_connections.authentication.churn_rate metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationChurnRateDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverUserConnectionsAuthenticationChurnRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationFailedLoginEventsDataPoint adds a data point to sqlserver.user_connections.authentication.failed_login_events metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationFailedLoginEventsDataPoint(ts pcommon.Timestamp, val int64, eventTypeAttributeValue string, descriptionAttributeValue string, startTimeAttributeValue string, clientIPAttributeValue string, logDateAttributeValue string, processInfoAttributeValue string, errorTextAttributeValue string) {
	mb.metricSqlserverUserConnectionsAuthenticationFailedLoginEvents.recordDataPoint(mb.startTime, ts, val, eventTypeAttributeValue, descriptionAttributeValue, startTimeAttributeValue, clientIPAttributeValue, logDateAttributeValue, processInfoAttributeValue, errorTextAttributeValue)
}

// RecordSqlserverUserConnectionsAuthenticationLoginsPerSecDataPoint adds a data point to sqlserver.user_connections.authentication.logins_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationLoginsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsAuthenticationLoginsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationLogoutsPerSecDataPoint adds a data point to sqlserver.user_connections.authentication.logouts_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationLogoutsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsAuthenticationLogoutsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationRateDataPoint adds a data point to sqlserver.user_connections.authentication.rate metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationRateDataPoint(ts pcommon.Timestamp, val int64, counterNameAttributeValue string) {
	mb.metricSqlserverUserConnectionsAuthenticationRate.recordDataPoint(mb.startTime, ts, val, counterNameAttributeValue)
}

// RecordSqlserverUserConnectionsAuthenticationRecentFailedLoginsDataPoint adds a data point to sqlserver.user_connections.authentication.recent_failed_logins metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationRecentFailedLoginsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsAuthenticationRecentFailedLogins.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationTotalActivityDataPoint adds a data point to sqlserver.user_connections.authentication.total_activity metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationTotalActivityDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsAuthenticationTotalActivity.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationTotalFailedLoginsDataPoint adds a data point to sqlserver.user_connections.authentication.total_failed_logins metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationTotalFailedLoginsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsAuthenticationTotalFailedLogins.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationUniqueFailedSourcesDataPoint adds a data point to sqlserver.user_connections.authentication.unique_failed_sources metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationUniqueFailedSourcesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsAuthenticationUniqueFailedSources.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationUniqueFailedUsersDataPoint adds a data point to sqlserver.user_connections.authentication.unique_failed_users metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationUniqueFailedUsersDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsClientCountDataPoint adds a data point to sqlserver.user_connections.client.count metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsClientCountDataPoint(ts pcommon.Timestamp, val int64, hostNameAttributeValue string, programNameAttributeValue string) {
	mb.metricSqlserverUserConnectionsClientCount.recordDataPoint(mb.startTime, ts, val, hostNameAttributeValue, programNameAttributeValue)
}

// RecordSqlserverUserConnectionsClientHostsMultiProgramDataPoint adds a data point to sqlserver.user_connections.client.hosts_multi_program metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsClientHostsMultiProgramDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsClientHostsMultiProgram.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsClientProgramsMultiHostDataPoint adds a data point to sqlserver.user_connections.client.programs_multi_host metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsClientProgramsMultiHostDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsClientProgramsMultiHost.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsClientTopHostConnectionsDataPoint adds a data point to sqlserver.user_connections.client.top_host_connections metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsClientTopHostConnectionsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsClientTopHostConnections.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsClientTopProgramConnectionsDataPoint adds a data point to sqlserver.user_connections.client.top_program_connections metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsClientTopProgramConnectionsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsClientTopProgramConnections.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsClientUniqueHostsDataPoint adds a data point to sqlserver.user_connections.client.unique_hosts metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsClientUniqueHostsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsClientUniqueHosts.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsClientUniqueProgramsDataPoint adds a data point to sqlserver.user_connections.client.unique_programs metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsClientUniqueProgramsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsClientUniquePrograms.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsDormantDataPoint adds a data point to sqlserver.user_connections.dormant metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsDormantDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsDormant.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsRunnableDataPoint adds a data point to sqlserver.user_connections.runnable metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsRunnableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsRunnable.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsRunningDataPoint adds a data point to sqlserver.user_connections.running metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsRunningDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsRunning.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsSleepingDataPoint adds a data point to sqlserver.user_connections.sleeping metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsSleepingDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsSleeping.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsStatusCountDataPoint adds a data point to sqlserver.user_connections.status.count metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsStatusCountDataPoint(ts pcommon.Timestamp, val int64, statusAttributeValue string) {
	mb.metricSqlserverUserConnectionsStatusCount.recordDataPoint(mb.startTime, ts, val, statusAttributeValue)
}

// RecordSqlserverUserConnectionsSuspendedDataPoint adds a data point to sqlserver.user_connections.suspended metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsSuspendedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsSuspended.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsTotalDataPoint adds a data point to sqlserver.user_connections.total metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsUtilizationActiveRatioDataPoint adds a data point to sqlserver.user_connections.utilization.active_ratio metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsUtilizationActiveRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverUserConnectionsUtilizationActiveRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsUtilizationEfficiencyDataPoint adds a data point to sqlserver.user_connections.utilization.efficiency metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsUtilizationEfficiencyDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverUserConnectionsUtilizationEfficiency.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsUtilizationIdleRatioDataPoint adds a data point to sqlserver.user_connections.utilization.idle_ratio metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsUtilizationIdleRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverUserConnectionsUtilizationIdleRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsUtilizationWaitingRatioDataPoint adds a data point to sqlserver.user_connections.utilization.waiting_ratio metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsUtilizationWaitingRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverUserConnectionsUtilizationWaitingRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverWaitStatsLatchWaitTimeMsDataPoint adds a data point to sqlserver.wait_stats.latch.wait_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverWaitStatsLatchWaitTimeMsDataPoint(ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	mb.metricSqlserverWaitStatsLatchWaitTimeMs.recordDataPoint(mb.startTime, ts, val, waitTypeAttributeValue)
}

// RecordSqlserverWaitStatsLatchWaitingTasksCountDataPoint adds a data point to sqlserver.wait_stats.latch.waiting_tasks_count metric.
func (mb *MetricsBuilder) RecordSqlserverWaitStatsLatchWaitingTasksCountDataPoint(ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	mb.metricSqlserverWaitStatsLatchWaitingTasksCount.recordDataPoint(mb.startTime, ts, val, waitTypeAttributeValue)
}

// RecordSqlserverWaitStatsWaitTimeMsDataPoint adds a data point to sqlserver.wait_stats.wait_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverWaitStatsWaitTimeMsDataPoint(ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	mb.metricSqlserverWaitStatsWaitTimeMs.recordDataPoint(mb.startTime, ts, val, waitTypeAttributeValue)
}

// RecordSqlserverWaitStatsWaitingTasksCountDataPoint adds a data point to sqlserver.wait_stats.waiting_tasks_count metric.
func (mb *MetricsBuilder) RecordSqlserverWaitStatsWaitingTasksCountDataPoint(ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	mb.metricSqlserverWaitStatsWaitingTasksCount.recordDataPoint(mb.startTime, ts, val, waitTypeAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
