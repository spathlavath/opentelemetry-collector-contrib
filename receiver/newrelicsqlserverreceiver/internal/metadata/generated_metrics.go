// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/filter"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

var MetricsInfo = metricsInfo{
	SqlserverAccessPageSplitsPerSec: metricInfo{
		Name: "sqlserver.access.page_splits_per_sec",
	},
	SqlserverActivequeryWaitTimeSeconds: metricInfo{
		Name: "sqlserver.activequery.wait_time_seconds",
	},
	SqlserverBlockingQueryDetails: metricInfo{
		Name: "sqlserver.blocking_query.details",
	},
	SqlserverBufferCacheHitRatio: metricInfo{
		Name: "sqlserver.buffer.cache_hit_ratio",
	},
	SqlserverBufferCheckpointPagesPerSec: metricInfo{
		Name: "sqlserver.buffer.checkpoint_pages_per_sec",
	},
	SqlserverBufferPageLifeExpectancy: metricInfo{
		Name: "sqlserver.buffer.page_life_expectancy",
	},
	SqlserverBufferpoolBatchRequestsPerSec: metricInfo{
		Name: "sqlserver.bufferpool.batch_requests_per_sec",
	},
	SqlserverBufferpoolPageLifeExpectancyMs: metricInfo{
		Name: "sqlserver.bufferpool.page_life_expectancy_ms",
	},
	SqlserverConnectionsUser: metricInfo{
		Name: "sqlserver.connections.user",
	},
	SqlserverDatabaseBufferpoolSizePerDatabaseBytes: metricInfo{
		Name: "sqlserver.database.bufferpool.size_per_database_bytes",
	},
	SqlserverDatabaseIoStallMs: metricInfo{
		Name: "sqlserver.database.io.stall_ms",
	},
	SqlserverDatabaseLogBytesFlushedPerSec: metricInfo{
		Name: "sqlserver.database.log.bytes_flushed_per_sec",
	},
	SqlserverDatabaseLogFlushWaitsPerSec: metricInfo{
		Name: "sqlserver.database.log.flush_waits_per_sec",
	},
	SqlserverDatabaseLogFlushesPerSec: metricInfo{
		Name: "sqlserver.database.log.flushes_per_sec",
	},
	SqlserverDatabaseLogTransactionGrowth: metricInfo{
		Name: "sqlserver.database.log.transaction_growth",
	},
	SqlserverDatabaseLogUsedSpaceMb: metricInfo{
		Name: "sqlserver.database.log.used_space_mb",
	},
	SqlserverDatabaseMaxDiskSizeBytes: metricInfo{
		Name: "sqlserver.database.max_disk_size_bytes",
	},
	SqlserverDatabasePageFileAvailableBytes: metricInfo{
		Name: "sqlserver.database.page_file_available_bytes",
	},
	SqlserverDatabasePageFileTotalBytes: metricInfo{
		Name: "sqlserver.database.page_file_total_bytes",
	},
	SqlserverDatabasePrincipalsApplicationRoles: metricInfo{
		Name: "sqlserver.database.principals.applicationRoles",
	},
	SqlserverDatabasePrincipalsOld: metricInfo{
		Name: "sqlserver.database.principals.old",
	},
	SqlserverDatabasePrincipalsOrphanedUsers: metricInfo{
		Name: "sqlserver.database.principals.orphanedUsers",
	},
	SqlserverDatabasePrincipalsRecentlyCreated: metricInfo{
		Name: "sqlserver.database.principals.recentlyCreated",
	},
	SqlserverDatabasePrincipalsRoles: metricInfo{
		Name: "sqlserver.database.principals.roles",
	},
	SqlserverDatabasePrincipalsSQLUsers: metricInfo{
		Name: "sqlserver.database.principals.sqlUsers",
	},
	SqlserverDatabasePrincipalsTotal: metricInfo{
		Name: "sqlserver.database.principals.total",
	},
	SqlserverDatabasePrincipalsUsers: metricInfo{
		Name: "sqlserver.database.principals.users",
	},
	SqlserverDatabasePrincipalsWindowsUsers: metricInfo{
		Name: "sqlserver.database.principals.windowsUsers",
	},
	SqlserverDatabaseRoleMembersApplicationRoles: metricInfo{
		Name: "sqlserver.database.role.members.applicationRoles",
	},
	SqlserverDatabaseRoleMembersCrossRole: metricInfo{
		Name: "sqlserver.database.role.members.crossRole",
	},
	SqlserverDatabaseRoleMembersHighPrivilege: metricInfo{
		Name: "sqlserver.database.role.members.highPrivilege",
	},
	SqlserverDatabaseRoleMembersUnique: metricInfo{
		Name: "sqlserver.database.role.members.unique",
	},
	SqlserverDatabaseRoleMembershipsActive: metricInfo{
		Name: "sqlserver.database.role.memberships.active",
	},
	SqlserverDatabaseRoleMembershipsCustom: metricInfo{
		Name: "sqlserver.database.role.memberships.custom",
	},
	SqlserverDatabaseRoleMembershipsNested: metricInfo{
		Name: "sqlserver.database.role.memberships.nested",
	},
	SqlserverDatabaseRoleMembershipsTotal: metricInfo{
		Name: "sqlserver.database.role.memberships.total",
	},
	SqlserverDatabaseRoleMembershipsUsers: metricInfo{
		Name: "sqlserver.database.role.memberships.users",
	},
	SqlserverDatabaseRolePermissionMemberCount: metricInfo{
		Name: "sqlserver.database.role.permission.memberCount",
	},
	SqlserverDatabaseRolePermissionRiskLevel: metricInfo{
		Name: "sqlserver.database.role.permission.riskLevel",
	},
	SqlserverDatabaseRoleRolesEmpty: metricInfo{
		Name: "sqlserver.database.role.roles.empty",
	},
	SqlserverDatabaseRoleRolesWithMembers: metricInfo{
		Name: "sqlserver.database.role.roles.withMembers",
	},
	SqlserverDatabaseSizeDataMb: metricInfo{
		Name: "sqlserver.database.size.data_mb",
	},
	SqlserverDatabaseSizeTotalMb: metricInfo{
		Name: "sqlserver.database.size.total_mb",
	},
	SqlserverDatabaseTransactionsActive: metricInfo{
		Name: "sqlserver.database.transactions.active",
	},
	SqlserverExecutionPlan: metricInfo{
		Name: "sqlserver.execution.plan",
	},
	SqlserverFailoverClusterAgClusterType: metricInfo{
		Name: "sqlserver.failover_cluster.ag_cluster_type",
	},
	SqlserverFailoverClusterAgFailureConditionLevel: metricInfo{
		Name: "sqlserver.failover_cluster.ag_failure_condition_level",
	},
	SqlserverFailoverClusterAgHealthCheckTimeout: metricInfo{
		Name: "sqlserver.failover_cluster.ag_health_check_timeout",
	},
	SqlserverFailoverClusterAgReplicaRole: metricInfo{
		Name: "sqlserver.failover_cluster.ag_replica_role",
	},
	SqlserverFailoverClusterAgRequiredSyncSecondaries: metricInfo{
		Name: "sqlserver.failover_cluster.ag_required_sync_secondaries",
	},
	SqlserverFailoverClusterAgSynchronizationHealth: metricInfo{
		Name: "sqlserver.failover_cluster.ag_synchronization_health",
	},
	SqlserverFailoverClusterFlowControlTimeMs: metricInfo{
		Name: "sqlserver.failover_cluster.flow_control_time_ms",
	},
	SqlserverFailoverClusterLogBytesReceivedPerSec: metricInfo{
		Name: "sqlserver.failover_cluster.log_bytes_received_per_sec",
	},
	SqlserverFailoverClusterLogSendQueueKb: metricInfo{
		Name: "sqlserver.failover_cluster.log_send_queue_kb",
	},
	SqlserverFailoverClusterRedoQueueKb: metricInfo{
		Name: "sqlserver.failover_cluster.redo_queue_kb",
	},
	SqlserverFailoverClusterRedoRateKbSec: metricInfo{
		Name: "sqlserver.failover_cluster.redo_rate_kb_sec",
	},
	SqlserverFailoverClusterTransactionDelayMs: metricInfo{
		Name: "sqlserver.failover_cluster.transaction_delay_ms",
	},
	SqlserverIndividualQueryTotalCPUMs: metricInfo{
		Name: "sqlserver.individual_query.total_cpu_ms",
	},
	SqlserverIndividualQueryTotalElapsedMs: metricInfo{
		Name: "sqlserver.individual_query.total_elapsed_ms",
	},
	SqlserverInstanceBackgroundProcessesCount: metricInfo{
		Name: "sqlserver.instance.background_processes_count",
	},
	SqlserverInstanceBlockedProcessesCount: metricInfo{
		Name: "sqlserver.instance.blocked_processes_count",
	},
	SqlserverInstanceBufferPoolHitPercent: metricInfo{
		Name: "sqlserver.instance.buffer_pool_hit_percent",
	},
	SqlserverInstanceBufferPoolSize: metricInfo{
		Name: "sqlserver.instance.buffer_pool_size",
	},
	SqlserverInstanceCompilationsPerBatch: metricInfo{
		Name: "sqlserver.instance.compilations_per_batch",
	},
	SqlserverInstanceConnectionsActive: metricInfo{
		Name: "sqlserver.instance.connections_active",
	},
	SqlserverInstanceDiskInBytes: metricInfo{
		Name: "sqlserver.instance.disk_in_bytes",
	},
	SqlserverInstanceDormantProcessesCount: metricInfo{
		Name: "sqlserver.instance.dormant_processes_count",
	},
	SqlserverInstanceForcedParameterizationsPerSec: metricInfo{
		Name: "sqlserver.instance.forced_parameterizations_per_sec",
	},
	SqlserverInstanceFullScansRate: metricInfo{
		Name: "sqlserver.instance.full_scans_rate",
	},
	SqlserverInstanceLockTimeoutsRate: metricInfo{
		Name: "sqlserver.instance.lock_timeouts_rate",
	},
	SqlserverInstanceMemoryAvailable: metricInfo{
		Name: "sqlserver.instance.memory_available",
	},
	SqlserverInstanceMemoryTotal: metricInfo{
		Name: "sqlserver.instance.memory_total",
	},
	SqlserverInstanceMemoryUtilizationPercent: metricInfo{
		Name: "sqlserver.instance.memory_utilization_percent",
	},
	SqlserverInstancePageSplitsPerBatch: metricInfo{
		Name: "sqlserver.instance.page_splits_per_batch",
	},
	SqlserverInstancePreconnectProcessesCount: metricInfo{
		Name: "sqlserver.instance.preconnect_processes_count",
	},
	SqlserverInstanceRunnableProcessesCount: metricInfo{
		Name: "sqlserver.instance.runnable_processes_count",
	},
	SqlserverInstanceRunnableTasks: metricInfo{
		Name: "sqlserver.instance.runnable_tasks",
	},
	SqlserverInstanceRunningProcessesCount: metricInfo{
		Name: "sqlserver.instance.running_processes_count",
	},
	SqlserverInstanceSleepingProcessesCount: metricInfo{
		Name: "sqlserver.instance.sleeping_processes_count",
	},
	SqlserverInstanceSuspendedProcessesCount: metricInfo{
		Name: "sqlserver.instance.suspended_processes_count",
	},
	SqlserverInstanceTargetMemoryKb: metricInfo{
		Name: "sqlserver.instance.target_memory_kb",
	},
	SqlserverInstanceTransactionsPerSec: metricInfo{
		Name: "sqlserver.instance.transactions_per_sec",
	},
	SqlserverLockModeBulkUpdate: metricInfo{
		Name: "sqlserver.lock.mode.bulk_update",
	},
	SqlserverLockModeExclusive: metricInfo{
		Name: "sqlserver.lock.mode.exclusive",
	},
	SqlserverLockModeIntent: metricInfo{
		Name: "sqlserver.lock.mode.intent",
	},
	SqlserverLockModeSchema: metricInfo{
		Name: "sqlserver.lock.mode.schema",
	},
	SqlserverLockModeShared: metricInfo{
		Name: "sqlserver.lock.mode.shared",
	},
	SqlserverLockModeSharedIntentExclusive: metricInfo{
		Name: "sqlserver.lock.mode.shared_intent_exclusive",
	},
	SqlserverLockModeTotal: metricInfo{
		Name: "sqlserver.lock.mode.total",
	},
	SqlserverLockModeUpdate: metricInfo{
		Name: "sqlserver.lock.mode.update",
	},
	SqlserverLockResourceAllocationUnit: metricInfo{
		Name: "sqlserver.lock.resource.allocation_unit",
	},
	SqlserverLockResourceApplication: metricInfo{
		Name: "sqlserver.lock.resource.application",
	},
	SqlserverLockResourceDatabaseLevel: metricInfo{
		Name: "sqlserver.lock.resource.database_level",
	},
	SqlserverLockResourceExtent: metricInfo{
		Name: "sqlserver.lock.resource.extent",
	},
	SqlserverLockResourceFile: metricInfo{
		Name: "sqlserver.lock.resource.file",
	},
	SqlserverLockResourceHobt: metricInfo{
		Name: "sqlserver.lock.resource.hobt",
	},
	SqlserverLockResourceKey: metricInfo{
		Name: "sqlserver.lock.resource.key",
	},
	SqlserverLockResourceMetadata: metricInfo{
		Name: "sqlserver.lock.resource.metadata",
	},
	SqlserverLockResourcePage: metricInfo{
		Name: "sqlserver.lock.resource.page",
	},
	SqlserverLockResourceRow: metricInfo{
		Name: "sqlserver.lock.resource.row",
	},
	SqlserverLockResourceTable: metricInfo{
		Name: "sqlserver.lock.resource.table",
	},
	SqlserverLockResourceTotal: metricInfo{
		Name: "sqlserver.lock.resource.total",
	},
	SqlserverLockedObject: metricInfo{
		Name: "sqlserver.locked_object",
	},
	SqlserverMemoryTarget: metricInfo{
		Name: "sqlserver.memory.target",
	},
	SqlserverMemoryTotal: metricInfo{
		Name: "sqlserver.memory.total",
	},
	SqlserverPlanAvgElapsedTimeMs: metricInfo{
		Name: "sqlserver.plan.avg_elapsed_time_ms",
	},
	SqlserverSecurityServerPrincipalsCount: metricInfo{
		Name: "sqlserver.security.server_principals_count",
	},
	SqlserverSecurityServerRoleMembersCount: metricInfo{
		Name: "sqlserver.security.server_role_members_count",
	},
	SqlserverSlowqueryAvgElapsedTimeMs: metricInfo{
		Name: "sqlserver.slowquery.avg_elapsed_time_ms",
	},
	SqlserverSlowqueryHistoricalExecutionCount: metricInfo{
		Name: "sqlserver.slowquery.historical_execution_count",
	},
	SqlserverSlowqueryHistoricalLogicalReads: metricInfo{
		Name: "sqlserver.slowquery.historical_logical_reads",
	},
	SqlserverSlowqueryHistoricalPhysicalReads: metricInfo{
		Name: "sqlserver.slowquery.historical_physical_reads",
	},
	SqlserverSlowqueryHistoricalRows: metricInfo{
		Name: "sqlserver.slowquery.historical_rows",
	},
	SqlserverSlowqueryHistoricalWaitTimeMs: metricInfo{
		Name: "sqlserver.slowquery.historical_wait_time_ms",
	},
	SqlserverSlowqueryHistoricalWorkerTimeMs: metricInfo{
		Name: "sqlserver.slowquery.historical_worker_time_ms",
	},
	SqlserverSlowqueryIntervalAvgElapsedTimeMs: metricInfo{
		Name: "sqlserver.slowquery.interval_avg_elapsed_time_ms",
	},
	SqlserverSlowqueryIntervalAvgLogicalReads: metricInfo{
		Name: "sqlserver.slowquery.interval_avg_logical_reads",
	},
	SqlserverSlowqueryIntervalAvgPhysicalReads: metricInfo{
		Name: "sqlserver.slowquery.interval_avg_physical_reads",
	},
	SqlserverSlowqueryIntervalAvgRows: metricInfo{
		Name: "sqlserver.slowquery.interval_avg_rows",
	},
	SqlserverSlowqueryIntervalAvgWaitTimeMs: metricInfo{
		Name: "sqlserver.slowquery.interval_avg_wait_time_ms",
	},
	SqlserverSlowqueryIntervalAvgWorkerTimeMs: metricInfo{
		Name: "sqlserver.slowquery.interval_avg_worker_time_ms",
	},
	SqlserverSlowqueryIntervalElapsedTimeMs: metricInfo{
		Name: "sqlserver.slowquery.interval_elapsed_time_ms",
	},
	SqlserverSlowqueryIntervalExecutionCount: metricInfo{
		Name: "sqlserver.slowquery.interval_execution_count",
	},
	SqlserverSlowqueryIntervalLogicalReads: metricInfo{
		Name: "sqlserver.slowquery.interval_logical_reads",
	},
	SqlserverSlowqueryIntervalPhysicalReads: metricInfo{
		Name: "sqlserver.slowquery.interval_physical_reads",
	},
	SqlserverSlowqueryIntervalRows: metricInfo{
		Name: "sqlserver.slowquery.interval_rows",
	},
	SqlserverSlowqueryIntervalWaitTimeMs: metricInfo{
		Name: "sqlserver.slowquery.interval_wait_time_ms",
	},
	SqlserverSlowqueryIntervalWorkerTimeMs: metricInfo{
		Name: "sqlserver.slowquery.interval_worker_time_ms",
	},
	SqlserverSlowqueryQueryDetails: metricInfo{
		Name: "sqlserver.slowquery.query_details",
	},
	SqlserverStatsConnections: metricInfo{
		Name: "sqlserver.stats.connections",
	},
	SqlserverStatsDeadlocksPerSec: metricInfo{
		Name: "sqlserver.stats.deadlocks_per_sec",
	},
	SqlserverStatsKillConnectionErrorsPerSec: metricInfo{
		Name: "sqlserver.stats.kill_connection_errors_per_sec",
	},
	SqlserverStatsLockWaitsPerSec: metricInfo{
		Name: "sqlserver.stats.lock_waits_per_sec",
	},
	SqlserverStatsSQLCompilationsPerSec: metricInfo{
		Name: "sqlserver.stats.sql_compilations_per_sec",
	},
	SqlserverStatsSQLRecompilationsPerSec: metricInfo{
		Name: "sqlserver.stats.sql_recompilations_per_sec",
	},
	SqlserverStatsUserErrorsPerSec: metricInfo{
		Name: "sqlserver.stats.user_errors_per_sec",
	},
	SqlserverTempdbAllocationWaitsMs: metricInfo{
		Name: "sqlserver.tempdb.allocation_waits_ms",
	},
	SqlserverTempdbCurrentWaiters: metricInfo{
		Name: "sqlserver.tempdb.current_waiters",
	},
	SqlserverTempdbDataFileCount: metricInfo{
		Name: "sqlserver.tempdb.data_file_count",
	},
	SqlserverTempdbPagelatchWaitsMs: metricInfo{
		Name: "sqlserver.tempdb.pagelatch_waits_ms",
	},
	SqlserverTempdbTotalSizeMb: metricInfo{
		Name: "sqlserver.tempdb.total_size_mb",
	},
	SqlserverThreadpoolCurrentTasks: metricInfo{
		Name: "sqlserver.threadpool.current_tasks",
	},
	SqlserverThreadpoolMaxWorkers: metricInfo{
		Name: "sqlserver.threadpool.max_workers",
	},
	SqlserverThreadpoolRunnableTasks: metricInfo{
		Name: "sqlserver.threadpool.runnable_tasks",
	},
	SqlserverThreadpoolRunningWorkers: metricInfo{
		Name: "sqlserver.threadpool.running_workers",
	},
	SqlserverThreadpoolUtilizationPercent: metricInfo{
		Name: "sqlserver.threadpool.utilization_percent",
	},
	SqlserverThreadpoolWaitingTasks: metricInfo{
		Name: "sqlserver.threadpool.waiting_tasks",
	},
	SqlserverThreadpoolWorkQueueCount: metricInfo{
		Name: "sqlserver.threadpool.work_queue_count",
	},
	SqlserverUserConnectionsAuthenticationChurnRate: metricInfo{
		Name: "sqlserver.user_connections.authentication.churn_rate",
	},
	SqlserverUserConnectionsAuthenticationLoginsPerSec: metricInfo{
		Name: "sqlserver.user_connections.authentication.logins_per_sec",
	},
	SqlserverUserConnectionsAuthenticationRecentFailedLogins: metricInfo{
		Name: "sqlserver.user_connections.authentication.recent_failed_logins",
	},
	SqlserverUserConnectionsAuthenticationTotalFailedLogins: metricInfo{
		Name: "sqlserver.user_connections.authentication.total_failed_logins",
	},
	SqlserverUserConnectionsAuthenticationUniqueFailedSources: metricInfo{
		Name: "sqlserver.user_connections.authentication.unique_failed_sources",
	},
	SqlserverUserConnectionsAuthenticationUniqueFailedUsers: metricInfo{
		Name: "sqlserver.user_connections.authentication.unique_failed_users",
	},
	SqlserverUserConnectionsClientCount: metricInfo{
		Name: "sqlserver.user_connections.client.count",
	},
	SqlserverUserConnectionsClientUniqueHosts: metricInfo{
		Name: "sqlserver.user_connections.client.unique_hosts",
	},
	SqlserverUserConnectionsClientUniquePrograms: metricInfo{
		Name: "sqlserver.user_connections.client.unique_programs",
	},
	SqlserverUserConnectionsRunnable: metricInfo{
		Name: "sqlserver.user_connections.runnable",
	},
	SqlserverUserConnectionsRunning: metricInfo{
		Name: "sqlserver.user_connections.running",
	},
	SqlserverUserConnectionsSleeping: metricInfo{
		Name: "sqlserver.user_connections.sleeping",
	},
	SqlserverUserConnectionsSuspended: metricInfo{
		Name: "sqlserver.user_connections.suspended",
	},
	SqlserverUserConnectionsTotal: metricInfo{
		Name: "sqlserver.user_connections.total",
	},
	SqlserverUserConnectionsUtilizationActiveRatio: metricInfo{
		Name: "sqlserver.user_connections.utilization.active_ratio",
	},
	SqlserverUserConnectionsUtilizationIdleRatio: metricInfo{
		Name: "sqlserver.user_connections.utilization.idle_ratio",
	},
	SqlserverWaitStatsLatchWaitTimeMs: metricInfo{
		Name: "sqlserver.wait_stats.latch.wait_time_ms",
	},
	SqlserverWaitStatsLatchWaitingTasksCount: metricInfo{
		Name: "sqlserver.wait_stats.latch.waiting_tasks_count",
	},
	SqlserverWaitStatsWaitTimeMs: metricInfo{
		Name: "sqlserver.wait_stats.wait_time_ms",
	},
	SqlserverWaitStatsWaitingTasksCount: metricInfo{
		Name: "sqlserver.wait_stats.waiting_tasks_count",
	},
}

type metricsInfo struct {
	SqlserverAccessPageSplitsPerSec                           metricInfo
	SqlserverActivequeryWaitTimeSeconds                       metricInfo
	SqlserverBlockingQueryDetails                             metricInfo
	SqlserverBufferCacheHitRatio                              metricInfo
	SqlserverBufferCheckpointPagesPerSec                      metricInfo
	SqlserverBufferPageLifeExpectancy                         metricInfo
	SqlserverBufferpoolBatchRequestsPerSec                    metricInfo
	SqlserverBufferpoolPageLifeExpectancyMs                   metricInfo
	SqlserverConnectionsUser                                  metricInfo
	SqlserverDatabaseBufferpoolSizePerDatabaseBytes           metricInfo
	SqlserverDatabaseIoStallMs                                metricInfo
	SqlserverDatabaseLogBytesFlushedPerSec                    metricInfo
	SqlserverDatabaseLogFlushWaitsPerSec                      metricInfo
	SqlserverDatabaseLogFlushesPerSec                         metricInfo
	SqlserverDatabaseLogTransactionGrowth                     metricInfo
	SqlserverDatabaseLogUsedSpaceMb                           metricInfo
	SqlserverDatabaseMaxDiskSizeBytes                         metricInfo
	SqlserverDatabasePageFileAvailableBytes                   metricInfo
	SqlserverDatabasePageFileTotalBytes                       metricInfo
	SqlserverDatabasePrincipalsApplicationRoles               metricInfo
	SqlserverDatabasePrincipalsOld                            metricInfo
	SqlserverDatabasePrincipalsOrphanedUsers                  metricInfo
	SqlserverDatabasePrincipalsRecentlyCreated                metricInfo
	SqlserverDatabasePrincipalsRoles                          metricInfo
	SqlserverDatabasePrincipalsSQLUsers                       metricInfo
	SqlserverDatabasePrincipalsTotal                          metricInfo
	SqlserverDatabasePrincipalsUsers                          metricInfo
	SqlserverDatabasePrincipalsWindowsUsers                   metricInfo
	SqlserverDatabaseRoleMembersApplicationRoles              metricInfo
	SqlserverDatabaseRoleMembersCrossRole                     metricInfo
	SqlserverDatabaseRoleMembersHighPrivilege                 metricInfo
	SqlserverDatabaseRoleMembersUnique                        metricInfo
	SqlserverDatabaseRoleMembershipsActive                    metricInfo
	SqlserverDatabaseRoleMembershipsCustom                    metricInfo
	SqlserverDatabaseRoleMembershipsNested                    metricInfo
	SqlserverDatabaseRoleMembershipsTotal                     metricInfo
	SqlserverDatabaseRoleMembershipsUsers                     metricInfo
	SqlserverDatabaseRolePermissionMemberCount                metricInfo
	SqlserverDatabaseRolePermissionRiskLevel                  metricInfo
	SqlserverDatabaseRoleRolesEmpty                           metricInfo
	SqlserverDatabaseRoleRolesWithMembers                     metricInfo
	SqlserverDatabaseSizeDataMb                               metricInfo
	SqlserverDatabaseSizeTotalMb                              metricInfo
	SqlserverDatabaseTransactionsActive                       metricInfo
	SqlserverExecutionPlan                                    metricInfo
	SqlserverFailoverClusterAgClusterType                     metricInfo
	SqlserverFailoverClusterAgFailureConditionLevel           metricInfo
	SqlserverFailoverClusterAgHealthCheckTimeout              metricInfo
	SqlserverFailoverClusterAgReplicaRole                     metricInfo
	SqlserverFailoverClusterAgRequiredSyncSecondaries         metricInfo
	SqlserverFailoverClusterAgSynchronizationHealth           metricInfo
	SqlserverFailoverClusterFlowControlTimeMs                 metricInfo
	SqlserverFailoverClusterLogBytesReceivedPerSec            metricInfo
	SqlserverFailoverClusterLogSendQueueKb                    metricInfo
	SqlserverFailoverClusterRedoQueueKb                       metricInfo
	SqlserverFailoverClusterRedoRateKbSec                     metricInfo
	SqlserverFailoverClusterTransactionDelayMs                metricInfo
	SqlserverIndividualQueryTotalCPUMs                        metricInfo
	SqlserverIndividualQueryTotalElapsedMs                    metricInfo
	SqlserverInstanceBackgroundProcessesCount                 metricInfo
	SqlserverInstanceBlockedProcessesCount                    metricInfo
	SqlserverInstanceBufferPoolHitPercent                     metricInfo
	SqlserverInstanceBufferPoolSize                           metricInfo
	SqlserverInstanceCompilationsPerBatch                     metricInfo
	SqlserverInstanceConnectionsActive                        metricInfo
	SqlserverInstanceDiskInBytes                              metricInfo
	SqlserverInstanceDormantProcessesCount                    metricInfo
	SqlserverInstanceForcedParameterizationsPerSec            metricInfo
	SqlserverInstanceFullScansRate                            metricInfo
	SqlserverInstanceLockTimeoutsRate                         metricInfo
	SqlserverInstanceMemoryAvailable                          metricInfo
	SqlserverInstanceMemoryTotal                              metricInfo
	SqlserverInstanceMemoryUtilizationPercent                 metricInfo
	SqlserverInstancePageSplitsPerBatch                       metricInfo
	SqlserverInstancePreconnectProcessesCount                 metricInfo
	SqlserverInstanceRunnableProcessesCount                   metricInfo
	SqlserverInstanceRunnableTasks                            metricInfo
	SqlserverInstanceRunningProcessesCount                    metricInfo
	SqlserverInstanceSleepingProcessesCount                   metricInfo
	SqlserverInstanceSuspendedProcessesCount                  metricInfo
	SqlserverInstanceTargetMemoryKb                           metricInfo
	SqlserverInstanceTransactionsPerSec                       metricInfo
	SqlserverLockModeBulkUpdate                               metricInfo
	SqlserverLockModeExclusive                                metricInfo
	SqlserverLockModeIntent                                   metricInfo
	SqlserverLockModeSchema                                   metricInfo
	SqlserverLockModeShared                                   metricInfo
	SqlserverLockModeSharedIntentExclusive                    metricInfo
	SqlserverLockModeTotal                                    metricInfo
	SqlserverLockModeUpdate                                   metricInfo
	SqlserverLockResourceAllocationUnit                       metricInfo
	SqlserverLockResourceApplication                          metricInfo
	SqlserverLockResourceDatabaseLevel                        metricInfo
	SqlserverLockResourceExtent                               metricInfo
	SqlserverLockResourceFile                                 metricInfo
	SqlserverLockResourceHobt                                 metricInfo
	SqlserverLockResourceKey                                  metricInfo
	SqlserverLockResourceMetadata                             metricInfo
	SqlserverLockResourcePage                                 metricInfo
	SqlserverLockResourceRow                                  metricInfo
	SqlserverLockResourceTable                                metricInfo
	SqlserverLockResourceTotal                                metricInfo
	SqlserverLockedObject                                     metricInfo
	SqlserverMemoryTarget                                     metricInfo
	SqlserverMemoryTotal                                      metricInfo
	SqlserverPlanAvgElapsedTimeMs                             metricInfo
	SqlserverSecurityServerPrincipalsCount                    metricInfo
	SqlserverSecurityServerRoleMembersCount                   metricInfo
	SqlserverSlowqueryAvgElapsedTimeMs                        metricInfo
	SqlserverSlowqueryHistoricalExecutionCount                metricInfo
	SqlserverSlowqueryHistoricalLogicalReads                  metricInfo
	SqlserverSlowqueryHistoricalPhysicalReads                 metricInfo
	SqlserverSlowqueryHistoricalRows                          metricInfo
	SqlserverSlowqueryHistoricalWaitTimeMs                    metricInfo
	SqlserverSlowqueryHistoricalWorkerTimeMs                  metricInfo
	SqlserverSlowqueryIntervalAvgElapsedTimeMs                metricInfo
	SqlserverSlowqueryIntervalAvgLogicalReads                 metricInfo
	SqlserverSlowqueryIntervalAvgPhysicalReads                metricInfo
	SqlserverSlowqueryIntervalAvgRows                         metricInfo
	SqlserverSlowqueryIntervalAvgWaitTimeMs                   metricInfo
	SqlserverSlowqueryIntervalAvgWorkerTimeMs                 metricInfo
	SqlserverSlowqueryIntervalElapsedTimeMs                   metricInfo
	SqlserverSlowqueryIntervalExecutionCount                  metricInfo
	SqlserverSlowqueryIntervalLogicalReads                    metricInfo
	SqlserverSlowqueryIntervalPhysicalReads                   metricInfo
	SqlserverSlowqueryIntervalRows                            metricInfo
	SqlserverSlowqueryIntervalWaitTimeMs                      metricInfo
	SqlserverSlowqueryIntervalWorkerTimeMs                    metricInfo
	SqlserverSlowqueryQueryDetails                            metricInfo
	SqlserverStatsConnections                                 metricInfo
	SqlserverStatsDeadlocksPerSec                             metricInfo
	SqlserverStatsKillConnectionErrorsPerSec                  metricInfo
	SqlserverStatsLockWaitsPerSec                             metricInfo
	SqlserverStatsSQLCompilationsPerSec                       metricInfo
	SqlserverStatsSQLRecompilationsPerSec                     metricInfo
	SqlserverStatsUserErrorsPerSec                            metricInfo
	SqlserverTempdbAllocationWaitsMs                          metricInfo
	SqlserverTempdbCurrentWaiters                             metricInfo
	SqlserverTempdbDataFileCount                              metricInfo
	SqlserverTempdbPagelatchWaitsMs                           metricInfo
	SqlserverTempdbTotalSizeMb                                metricInfo
	SqlserverThreadpoolCurrentTasks                           metricInfo
	SqlserverThreadpoolMaxWorkers                             metricInfo
	SqlserverThreadpoolRunnableTasks                          metricInfo
	SqlserverThreadpoolRunningWorkers                         metricInfo
	SqlserverThreadpoolUtilizationPercent                     metricInfo
	SqlserverThreadpoolWaitingTasks                           metricInfo
	SqlserverThreadpoolWorkQueueCount                         metricInfo
	SqlserverUserConnectionsAuthenticationChurnRate           metricInfo
	SqlserverUserConnectionsAuthenticationLoginsPerSec        metricInfo
	SqlserverUserConnectionsAuthenticationRecentFailedLogins  metricInfo
	SqlserverUserConnectionsAuthenticationTotalFailedLogins   metricInfo
	SqlserverUserConnectionsAuthenticationUniqueFailedSources metricInfo
	SqlserverUserConnectionsAuthenticationUniqueFailedUsers   metricInfo
	SqlserverUserConnectionsClientCount                       metricInfo
	SqlserverUserConnectionsClientUniqueHosts                 metricInfo
	SqlserverUserConnectionsClientUniquePrograms              metricInfo
	SqlserverUserConnectionsRunnable                          metricInfo
	SqlserverUserConnectionsRunning                           metricInfo
	SqlserverUserConnectionsSleeping                          metricInfo
	SqlserverUserConnectionsSuspended                         metricInfo
	SqlserverUserConnectionsTotal                             metricInfo
	SqlserverUserConnectionsUtilizationActiveRatio            metricInfo
	SqlserverUserConnectionsUtilizationIdleRatio              metricInfo
	SqlserverWaitStatsLatchWaitTimeMs                         metricInfo
	SqlserverWaitStatsLatchWaitingTasksCount                  metricInfo
	SqlserverWaitStatsWaitTimeMs                              metricInfo
	SqlserverWaitStatsWaitingTasksCount                       metricInfo
}

type metricInfo struct {
	Name string
}

type metricSqlserverAccessPageSplitsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.access.page_splits_per_sec metric with initial data.
func (m *metricSqlserverAccessPageSplitsPerSec) init() {
	m.data.SetName("sqlserver.access.page_splits_per_sec")
	m.data.SetDescription("Page splits per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverAccessPageSplitsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverAccessPageSplitsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverAccessPageSplitsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverAccessPageSplitsPerSec(cfg MetricConfig) metricSqlserverAccessPageSplitsPerSec {
	m := metricSqlserverAccessPageSplitsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverActivequeryWaitTimeSeconds struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.activequery.wait_time_seconds metric with initial data.
func (m *metricSqlserverActivequeryWaitTimeSeconds) init() {
	m.data.SetName("sqlserver.activequery.wait_time_seconds")
	m.data.SetDescription("Wait time for currently executing query")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverActivequeryWaitTimeSeconds) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, queryIDAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceTypeAttributeValue string, waitResourceObjectNameAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, planHandleAttributeValue string, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingQueryHashAttributeValue string, blockingNrServiceGUIDAttributeValue string, blockingNormalisedSQLHashAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("login_name", loginNameAttributeValue)
	dp.Attributes().PutStr("host_name", hostNameAttributeValue)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
	dp.Attributes().PutStr("wait_type_description", waitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("wait_type_category", waitTypeCategoryAttributeValue)
	dp.Attributes().PutStr("wait_resource", waitResourceAttributeValue)
	dp.Attributes().PutStr("wait_resource_type", waitResourceTypeAttributeValue)
	dp.Attributes().PutStr("wait_resource_object_name", waitResourceObjectNameAttributeValue)
	dp.Attributes().PutStr("last_wait_type", lastWaitTypeAttributeValue)
	dp.Attributes().PutStr("last_wait_type_description", lastWaitTypeDescriptionAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
	dp.Attributes().PutInt("transaction_id", transactionIDAttributeValue)
	dp.Attributes().PutInt("open_transaction_count", openTransactionCountAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutInt("blocking_session_id", blockingSessionIDAttributeValue)
	dp.Attributes().PutStr("blocking_login_name", blockingLoginNameAttributeValue)
	dp.Attributes().PutStr("blocking_query_hash", blockingQueryHashAttributeValue)
	dp.Attributes().PutStr("blocking_nr_service_guid", blockingNrServiceGUIDAttributeValue)
	dp.Attributes().PutStr("blocking_normalised_sql_hash", blockingNormalisedSQLHashAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverActivequeryWaitTimeSeconds) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverActivequeryWaitTimeSeconds) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverActivequeryWaitTimeSeconds(cfg MetricConfig) metricSqlserverActivequeryWaitTimeSeconds {
	m := metricSqlserverActivequeryWaitTimeSeconds{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBlockingQueryDetails struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.blocking_query.details metric with initial data.
func (m *metricSqlserverBlockingQueryDetails) init() {
	m.data.SetName("sqlserver.blocking_query.details")
	m.data.SetDescription("Blocking query details for correlation with active queries (emitted as custom events)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverBlockingQueryDetails) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, blockingSessionIDAttributeValue int64, blockingQueryTextAttributeValue string, blockingNrServiceGUIDAttributeValue string, blockingNormalisedSQLHashAttributeValue string, newrelicEventTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutInt("session_id", sessionIDAttributeValue)
	dp.Attributes().PutInt("request_id", requestIDAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutInt("blocking_session_id", blockingSessionIDAttributeValue)
	dp.Attributes().PutStr("blocking_query_text", blockingQueryTextAttributeValue)
	dp.Attributes().PutStr("blocking_nr_service_guid", blockingNrServiceGUIDAttributeValue)
	dp.Attributes().PutStr("blocking_normalised_sql_hash", blockingNormalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("newrelic.event.type", newrelicEventTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBlockingQueryDetails) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBlockingQueryDetails) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBlockingQueryDetails(cfg MetricConfig) metricSqlserverBlockingQueryDetails {
	m := metricSqlserverBlockingQueryDetails{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBufferCacheHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.buffer.cache_hit_ratio metric with initial data.
func (m *metricSqlserverBufferCacheHitRatio) init() {
	m.data.SetName("sqlserver.buffer.cache_hit_ratio")
	m.data.SetDescription("Buffer cache hit ratio percentage")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBufferCacheHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBufferCacheHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBufferCacheHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBufferCacheHitRatio(cfg MetricConfig) metricSqlserverBufferCacheHitRatio {
	m := metricSqlserverBufferCacheHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBufferCheckpointPagesPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.buffer.checkpoint_pages_per_sec metric with initial data.
func (m *metricSqlserverBufferCheckpointPagesPerSec) init() {
	m.data.SetName("sqlserver.buffer.checkpoint_pages_per_sec")
	m.data.SetDescription("Checkpoint pages per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBufferCheckpointPagesPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBufferCheckpointPagesPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBufferCheckpointPagesPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBufferCheckpointPagesPerSec(cfg MetricConfig) metricSqlserverBufferCheckpointPagesPerSec {
	m := metricSqlserverBufferCheckpointPagesPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBufferPageLifeExpectancy struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.buffer.page_life_expectancy metric with initial data.
func (m *metricSqlserverBufferPageLifeExpectancy) init() {
	m.data.SetName("sqlserver.buffer.page_life_expectancy")
	m.data.SetDescription("Page life expectancy in seconds")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBufferPageLifeExpectancy) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBufferPageLifeExpectancy) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBufferPageLifeExpectancy) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBufferPageLifeExpectancy(cfg MetricConfig) metricSqlserverBufferPageLifeExpectancy {
	m := metricSqlserverBufferPageLifeExpectancy{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBufferpoolBatchRequestsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.bufferpool.batch_requests_per_sec metric with initial data.
func (m *metricSqlserverBufferpoolBatchRequestsPerSec) init() {
	m.data.SetName("sqlserver.bufferpool.batch_requests_per_sec")
	m.data.SetDescription("Batch requests per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBufferpoolBatchRequestsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBufferpoolBatchRequestsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBufferpoolBatchRequestsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBufferpoolBatchRequestsPerSec(cfg MetricConfig) metricSqlserverBufferpoolBatchRequestsPerSec {
	m := metricSqlserverBufferpoolBatchRequestsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBufferpoolPageLifeExpectancyMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.bufferpool.page_life_expectancy_ms metric with initial data.
func (m *metricSqlserverBufferpoolPageLifeExpectancyMs) init() {
	m.data.SetName("sqlserver.bufferpool.page_life_expectancy_ms")
	m.data.SetDescription("Page life expectancy in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBufferpoolPageLifeExpectancyMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBufferpoolPageLifeExpectancyMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBufferpoolPageLifeExpectancyMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBufferpoolPageLifeExpectancyMs(cfg MetricConfig) metricSqlserverBufferpoolPageLifeExpectancyMs {
	m := metricSqlserverBufferpoolPageLifeExpectancyMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverConnectionsUser struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.connections.user metric with initial data.
func (m *metricSqlserverConnectionsUser) init() {
	m.data.SetName("sqlserver.connections.user")
	m.data.SetDescription("Number of user connections")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverConnectionsUser) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverConnectionsUser) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverConnectionsUser) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverConnectionsUser(cfg MetricConfig) metricSqlserverConnectionsUser {
	m := metricSqlserverConnectionsUser{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseBufferpoolSizePerDatabaseBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.bufferpool.size_per_database_bytes metric with initial data.
func (m *metricSqlserverDatabaseBufferpoolSizePerDatabaseBytes) init() {
	m.data.SetName("sqlserver.database.bufferpool.size_per_database_bytes")
	m.data.SetDescription("Size of the SQL Server buffer pool allocated for the database")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseBufferpoolSizePerDatabaseBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseBufferpoolSizePerDatabaseBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseBufferpoolSizePerDatabaseBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseBufferpoolSizePerDatabaseBytes(cfg MetricConfig) metricSqlserverDatabaseBufferpoolSizePerDatabaseBytes {
	m := metricSqlserverDatabaseBufferpoolSizePerDatabaseBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseIoStallMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.io.stall_ms metric with initial data.
func (m *metricSqlserverDatabaseIoStallMs) init() {
	m.data.SetName("sqlserver.database.io.stall_ms")
	m.data.SetDescription("Total IO stall time for the SQL Server database")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseIoStallMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseIoStallMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseIoStallMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseIoStallMs(cfg MetricConfig) metricSqlserverDatabaseIoStallMs {
	m := metricSqlserverDatabaseIoStallMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseLogBytesFlushedPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.log.bytes_flushed_per_sec metric with initial data.
func (m *metricSqlserverDatabaseLogBytesFlushedPerSec) init() {
	m.data.SetName("sqlserver.database.log.bytes_flushed_per_sec")
	m.data.SetDescription("Number of log bytes flushed per second")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseLogBytesFlushedPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseLogBytesFlushedPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseLogBytesFlushedPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseLogBytesFlushedPerSec(cfg MetricConfig) metricSqlserverDatabaseLogBytesFlushedPerSec {
	m := metricSqlserverDatabaseLogBytesFlushedPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseLogFlushWaitsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.log.flush_waits_per_sec metric with initial data.
func (m *metricSqlserverDatabaseLogFlushWaitsPerSec) init() {
	m.data.SetName("sqlserver.database.log.flush_waits_per_sec")
	m.data.SetDescription("Number of flush wait operations per second")
	m.data.SetUnit("{operations}/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseLogFlushWaitsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseLogFlushWaitsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseLogFlushWaitsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseLogFlushWaitsPerSec(cfg MetricConfig) metricSqlserverDatabaseLogFlushWaitsPerSec {
	m := metricSqlserverDatabaseLogFlushWaitsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseLogFlushesPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.log.flushes_per_sec metric with initial data.
func (m *metricSqlserverDatabaseLogFlushesPerSec) init() {
	m.data.SetName("sqlserver.database.log.flushes_per_sec")
	m.data.SetDescription("Number of log flush operations per second")
	m.data.SetUnit("{operations}/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseLogFlushesPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseLogFlushesPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseLogFlushesPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseLogFlushesPerSec(cfg MetricConfig) metricSqlserverDatabaseLogFlushesPerSec {
	m := metricSqlserverDatabaseLogFlushesPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseLogTransactionGrowth struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.log.transaction_growth metric with initial data.
func (m *metricSqlserverDatabaseLogTransactionGrowth) init() {
	m.data.SetName("sqlserver.database.log.transaction_growth")
	m.data.SetDescription("Number of log growth events for the SQL Server database")
	m.data.SetUnit("{events}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseLogTransactionGrowth) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseLogTransactionGrowth) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseLogTransactionGrowth) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseLogTransactionGrowth(cfg MetricConfig) metricSqlserverDatabaseLogTransactionGrowth {
	m := metricSqlserverDatabaseLogTransactionGrowth{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseLogUsedSpaceMb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.log.used_space_mb metric with initial data.
func (m *metricSqlserverDatabaseLogUsedSpaceMb) init() {
	m.data.SetName("sqlserver.database.log.used_space_mb")
	m.data.SetDescription("Used log space in megabytes")
	m.data.SetUnit("MBy")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseLogUsedSpaceMb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseLogUsedSpaceMb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseLogUsedSpaceMb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseLogUsedSpaceMb(cfg MetricConfig) metricSqlserverDatabaseLogUsedSpaceMb {
	m := metricSqlserverDatabaseLogUsedSpaceMb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseMaxDiskSizeBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.max_disk_size_bytes metric with initial data.
func (m *metricSqlserverDatabaseMaxDiskSizeBytes) init() {
	m.data.SetName("sqlserver.database.max_disk_size_bytes")
	m.data.SetDescription("Maximum disk size allowed for the SQL Server database")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseMaxDiskSizeBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseMaxDiskSizeBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseMaxDiskSizeBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseMaxDiskSizeBytes(cfg MetricConfig) metricSqlserverDatabaseMaxDiskSizeBytes {
	m := metricSqlserverDatabaseMaxDiskSizeBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePageFileAvailableBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.page_file_available_bytes metric with initial data.
func (m *metricSqlserverDatabasePageFileAvailableBytes) init() {
	m.data.SetName("sqlserver.database.page_file_available_bytes")
	m.data.SetDescription("Available page file space (reserved space not used) for the SQL Server database")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePageFileAvailableBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePageFileAvailableBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePageFileAvailableBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePageFileAvailableBytes(cfg MetricConfig) metricSqlserverDatabasePageFileAvailableBytes {
	m := metricSqlserverDatabasePageFileAvailableBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePageFileTotalBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.page_file_total_bytes metric with initial data.
func (m *metricSqlserverDatabasePageFileTotalBytes) init() {
	m.data.SetName("sqlserver.database.page_file_total_bytes")
	m.data.SetDescription("Total page file space (total reserved space) for the SQL Server database")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePageFileTotalBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePageFileTotalBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePageFileTotalBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePageFileTotalBytes(cfg MetricConfig) metricSqlserverDatabasePageFileTotalBytes {
	m := metricSqlserverDatabasePageFileTotalBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsApplicationRoles struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.applicationRoles metric with initial data.
func (m *metricSqlserverDatabasePrincipalsApplicationRoles) init() {
	m.data.SetName("sqlserver.database.principals.applicationRoles")
	m.data.SetDescription("Number of application roles")
	m.data.SetUnit("{roles}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsApplicationRoles) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsApplicationRoles) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsApplicationRoles) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsApplicationRoles(cfg MetricConfig) metricSqlserverDatabasePrincipalsApplicationRoles {
	m := metricSqlserverDatabasePrincipalsApplicationRoles{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsOld struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.old metric with initial data.
func (m *metricSqlserverDatabasePrincipalsOld) init() {
	m.data.SetName("sqlserver.database.principals.old")
	m.data.SetDescription("Number of old principals (older than 365 days)")
	m.data.SetUnit("{principals}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsOld) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsOld) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsOld) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsOld(cfg MetricConfig) metricSqlserverDatabasePrincipalsOld {
	m := metricSqlserverDatabasePrincipalsOld{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsOrphanedUsers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.orphanedUsers metric with initial data.
func (m *metricSqlserverDatabasePrincipalsOrphanedUsers) init() {
	m.data.SetName("sqlserver.database.principals.orphanedUsers")
	m.data.SetDescription("Number of orphaned users without server login")
	m.data.SetUnit("{users}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsOrphanedUsers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsOrphanedUsers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsOrphanedUsers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsOrphanedUsers(cfg MetricConfig) metricSqlserverDatabasePrincipalsOrphanedUsers {
	m := metricSqlserverDatabasePrincipalsOrphanedUsers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsRecentlyCreated struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.recentlyCreated metric with initial data.
func (m *metricSqlserverDatabasePrincipalsRecentlyCreated) init() {
	m.data.SetName("sqlserver.database.principals.recentlyCreated")
	m.data.SetDescription("Number of recently created principals (last 30 days)")
	m.data.SetUnit("{principals}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsRecentlyCreated) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsRecentlyCreated) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsRecentlyCreated) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsRecentlyCreated(cfg MetricConfig) metricSqlserverDatabasePrincipalsRecentlyCreated {
	m := metricSqlserverDatabasePrincipalsRecentlyCreated{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsRoles struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.roles metric with initial data.
func (m *metricSqlserverDatabasePrincipalsRoles) init() {
	m.data.SetName("sqlserver.database.principals.roles")
	m.data.SetDescription("Number of database roles")
	m.data.SetUnit("{roles}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsRoles) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsRoles) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsRoles) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsRoles(cfg MetricConfig) metricSqlserverDatabasePrincipalsRoles {
	m := metricSqlserverDatabasePrincipalsRoles{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsSQLUsers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.sqlUsers metric with initial data.
func (m *metricSqlserverDatabasePrincipalsSQLUsers) init() {
	m.data.SetName("sqlserver.database.principals.sqlUsers")
	m.data.SetDescription("Number of SQL authentication users")
	m.data.SetUnit("{users}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsSQLUsers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsSQLUsers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsSQLUsers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsSQLUsers(cfg MetricConfig) metricSqlserverDatabasePrincipalsSQLUsers {
	m := metricSqlserverDatabasePrincipalsSQLUsers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.total metric with initial data.
func (m *metricSqlserverDatabasePrincipalsTotal) init() {
	m.data.SetName("sqlserver.database.principals.total")
	m.data.SetDescription("Total number of database principals")
	m.data.SetUnit("{principals}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsTotal(cfg MetricConfig) metricSqlserverDatabasePrincipalsTotal {
	m := metricSqlserverDatabasePrincipalsTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsUsers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.users metric with initial data.
func (m *metricSqlserverDatabasePrincipalsUsers) init() {
	m.data.SetName("sqlserver.database.principals.users")
	m.data.SetDescription("Number of database users")
	m.data.SetUnit("{users}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsUsers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsUsers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsUsers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsUsers(cfg MetricConfig) metricSqlserverDatabasePrincipalsUsers {
	m := metricSqlserverDatabasePrincipalsUsers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabasePrincipalsWindowsUsers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.principals.windowsUsers metric with initial data.
func (m *metricSqlserverDatabasePrincipalsWindowsUsers) init() {
	m.data.SetName("sqlserver.database.principals.windowsUsers")
	m.data.SetDescription("Number of Windows authentication users")
	m.data.SetUnit("{users}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabasePrincipalsWindowsUsers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabasePrincipalsWindowsUsers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabasePrincipalsWindowsUsers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabasePrincipalsWindowsUsers(cfg MetricConfig) metricSqlserverDatabasePrincipalsWindowsUsers {
	m := metricSqlserverDatabasePrincipalsWindowsUsers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembersApplicationRoles struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.members.applicationRoles metric with initial data.
func (m *metricSqlserverDatabaseRoleMembersApplicationRoles) init() {
	m.data.SetName("sqlserver.database.role.members.applicationRoles")
	m.data.SetDescription("Number of application role members")
	m.data.SetUnit("{members}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembersApplicationRoles) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembersApplicationRoles) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembersApplicationRoles) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembersApplicationRoles(cfg MetricConfig) metricSqlserverDatabaseRoleMembersApplicationRoles {
	m := metricSqlserverDatabaseRoleMembersApplicationRoles{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembersCrossRole struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.members.crossRole metric with initial data.
func (m *metricSqlserverDatabaseRoleMembersCrossRole) init() {
	m.data.SetName("sqlserver.database.role.members.crossRole")
	m.data.SetDescription("Number of cross-role members")
	m.data.SetUnit("{members}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembersCrossRole) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembersCrossRole) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembersCrossRole) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembersCrossRole(cfg MetricConfig) metricSqlserverDatabaseRoleMembersCrossRole {
	m := metricSqlserverDatabaseRoleMembersCrossRole{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembersHighPrivilege struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.members.highPrivilege metric with initial data.
func (m *metricSqlserverDatabaseRoleMembersHighPrivilege) init() {
	m.data.SetName("sqlserver.database.role.members.highPrivilege")
	m.data.SetDescription("Number of high privilege role members")
	m.data.SetUnit("{members}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembersHighPrivilege) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembersHighPrivilege) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembersHighPrivilege) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembersHighPrivilege(cfg MetricConfig) metricSqlserverDatabaseRoleMembersHighPrivilege {
	m := metricSqlserverDatabaseRoleMembersHighPrivilege{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembersUnique struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.members.unique metric with initial data.
func (m *metricSqlserverDatabaseRoleMembersUnique) init() {
	m.data.SetName("sqlserver.database.role.members.unique")
	m.data.SetDescription("Number of unique members in roles")
	m.data.SetUnit("{members}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembersUnique) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembersUnique) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembersUnique) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembersUnique(cfg MetricConfig) metricSqlserverDatabaseRoleMembersUnique {
	m := metricSqlserverDatabaseRoleMembersUnique{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembershipsActive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.memberships.active metric with initial data.
func (m *metricSqlserverDatabaseRoleMembershipsActive) init() {
	m.data.SetName("sqlserver.database.role.memberships.active")
	m.data.SetDescription("Number of active role memberships")
	m.data.SetUnit("{memberships}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembershipsActive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembershipsActive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembershipsActive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembershipsActive(cfg MetricConfig) metricSqlserverDatabaseRoleMembershipsActive {
	m := metricSqlserverDatabaseRoleMembershipsActive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembershipsCustom struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.memberships.custom metric with initial data.
func (m *metricSqlserverDatabaseRoleMembershipsCustom) init() {
	m.data.SetName("sqlserver.database.role.memberships.custom")
	m.data.SetDescription("Number of custom role memberships")
	m.data.SetUnit("{memberships}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembershipsCustom) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembershipsCustom) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembershipsCustom) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembershipsCustom(cfg MetricConfig) metricSqlserverDatabaseRoleMembershipsCustom {
	m := metricSqlserverDatabaseRoleMembershipsCustom{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembershipsNested struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.memberships.nested metric with initial data.
func (m *metricSqlserverDatabaseRoleMembershipsNested) init() {
	m.data.SetName("sqlserver.database.role.memberships.nested")
	m.data.SetDescription("Number of nested role memberships")
	m.data.SetUnit("{memberships}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembershipsNested) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembershipsNested) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembershipsNested) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembershipsNested(cfg MetricConfig) metricSqlserverDatabaseRoleMembershipsNested {
	m := metricSqlserverDatabaseRoleMembershipsNested{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembershipsTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.memberships.total metric with initial data.
func (m *metricSqlserverDatabaseRoleMembershipsTotal) init() {
	m.data.SetName("sqlserver.database.role.memberships.total")
	m.data.SetDescription("Total number of role memberships")
	m.data.SetUnit("{memberships}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembershipsTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembershipsTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembershipsTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembershipsTotal(cfg MetricConfig) metricSqlserverDatabaseRoleMembershipsTotal {
	m := metricSqlserverDatabaseRoleMembershipsTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleMembershipsUsers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.memberships.users metric with initial data.
func (m *metricSqlserverDatabaseRoleMembershipsUsers) init() {
	m.data.SetName("sqlserver.database.role.memberships.users")
	m.data.SetDescription("Number of user role memberships")
	m.data.SetUnit("{memberships}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleMembershipsUsers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleMembershipsUsers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleMembershipsUsers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleMembershipsUsers(cfg MetricConfig) metricSqlserverDatabaseRoleMembershipsUsers {
	m := metricSqlserverDatabaseRoleMembershipsUsers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRolePermissionMemberCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.permission.memberCount metric with initial data.
func (m *metricSqlserverDatabaseRolePermissionMemberCount) init() {
	m.data.SetName("sqlserver.database.role.permission.memberCount")
	m.data.SetDescription("Number of members in role")
	m.data.SetUnit("{members}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRolePermissionMemberCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, roleNameAttributeValue string, permissionScopeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("role_name", roleNameAttributeValue)
	dp.Attributes().PutStr("permission_scope", permissionScopeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRolePermissionMemberCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRolePermissionMemberCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRolePermissionMemberCount(cfg MetricConfig) metricSqlserverDatabaseRolePermissionMemberCount {
	m := metricSqlserverDatabaseRolePermissionMemberCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRolePermissionRiskLevel struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.permission.riskLevel metric with initial data.
func (m *metricSqlserverDatabaseRolePermissionRiskLevel) init() {
	m.data.SetName("sqlserver.database.role.permission.riskLevel")
	m.data.SetDescription("Role risk level")
	m.data.SetUnit("{level}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRolePermissionRiskLevel) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, roleNameAttributeValue string, permissionScopeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("role_name", roleNameAttributeValue)
	dp.Attributes().PutStr("permission_scope", permissionScopeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRolePermissionRiskLevel) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRolePermissionRiskLevel) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRolePermissionRiskLevel(cfg MetricConfig) metricSqlserverDatabaseRolePermissionRiskLevel {
	m := metricSqlserverDatabaseRolePermissionRiskLevel{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleRolesEmpty struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.roles.empty metric with initial data.
func (m *metricSqlserverDatabaseRoleRolesEmpty) init() {
	m.data.SetName("sqlserver.database.role.roles.empty")
	m.data.SetDescription("Number of empty roles")
	m.data.SetUnit("{roles}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleRolesEmpty) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleRolesEmpty) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleRolesEmpty) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleRolesEmpty(cfg MetricConfig) metricSqlserverDatabaseRoleRolesEmpty {
	m := metricSqlserverDatabaseRoleRolesEmpty{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseRoleRolesWithMembers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.role.roles.withMembers metric with initial data.
func (m *metricSqlserverDatabaseRoleRolesWithMembers) init() {
	m.data.SetName("sqlserver.database.role.roles.withMembers")
	m.data.SetDescription("Number of unique roles with members")
	m.data.SetUnit("{roles}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseRoleRolesWithMembers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseRoleRolesWithMembers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseRoleRolesWithMembers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseRoleRolesWithMembers(cfg MetricConfig) metricSqlserverDatabaseRoleRolesWithMembers {
	m := metricSqlserverDatabaseRoleRolesWithMembers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseSizeDataMb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.size.data_mb metric with initial data.
func (m *metricSqlserverDatabaseSizeDataMb) init() {
	m.data.SetName("sqlserver.database.size.data_mb")
	m.data.SetDescription("Total data file size excluding log files")
	m.data.SetUnit("MBy")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseSizeDataMb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseSizeDataMb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseSizeDataMb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseSizeDataMb(cfg MetricConfig) metricSqlserverDatabaseSizeDataMb {
	m := metricSqlserverDatabaseSizeDataMb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseSizeTotalMb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.size.total_mb metric with initial data.
func (m *metricSqlserverDatabaseSizeTotalMb) init() {
	m.data.SetName("sqlserver.database.size.total_mb")
	m.data.SetDescription("Total database size including data and log files")
	m.data.SetUnit("MBy")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseSizeTotalMb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseSizeTotalMb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseSizeTotalMb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseSizeTotalMb(cfg MetricConfig) metricSqlserverDatabaseSizeTotalMb {
	m := metricSqlserverDatabaseSizeTotalMb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverDatabaseTransactionsActive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.database.transactions.active metric with initial data.
func (m *metricSqlserverDatabaseTransactionsActive) init() {
	m.data.SetName("sqlserver.database.transactions.active")
	m.data.SetDescription("Number of active transactions")
	m.data.SetUnit("{transactions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverDatabaseTransactionsActive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("metric_source", metricSourceAttributeValue)
	dp.Attributes().PutStr("engine_edition", engineEditionAttributeValue)
	dp.Attributes().PutInt("engine_edition_id", engineEditionIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverDatabaseTransactionsActive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverDatabaseTransactionsActive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverDatabaseTransactionsActive(cfg MetricConfig) metricSqlserverDatabaseTransactionsActive {
	m := metricSqlserverDatabaseTransactionsActive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverExecutionPlan struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.execution.plan metric with initial data.
func (m *metricSqlserverExecutionPlan) init() {
	m.data.SetName("sqlserver.execution.plan")
	m.data.SetDescription("SQL Server execution plan operator with detailed cost estimates, performance metrics, and resource usage")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverExecutionPlan) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, nodeIDAttributeValue int64, parentNodeIDAttributeValue int64, physicalOpAttributeValue string, logicalOpAttributeValue string, inputTypeAttributeValue string, schemaNameAttributeValue string, tableNameAttributeValue string, indexNameAttributeValue string, referencedColumnsAttributeValue string, estimateRowsAttributeValue float64, estimateIoAttributeValue float64, estimateCPUAttributeValue float64, avgRowSizeAttributeValue float64, totalSubtreeCostAttributeValue float64, estimatedOperatorCostAttributeValue float64, estimatedExecutionModeAttributeValue string, grantedMemoryKbAttributeValue int64, spillOccurredAttributeValue bool, noJoinPredicateAttributeValue bool, totalWorkerTimeAttributeValue float64, totalElapsedTimeAttributeValue float64, totalLogicalReadsAttributeValue int64, executionCountAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, newrelicEventTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutInt("node_id", nodeIDAttributeValue)
	dp.Attributes().PutInt("parent_node_id", parentNodeIDAttributeValue)
	dp.Attributes().PutStr("physical_op", physicalOpAttributeValue)
	dp.Attributes().PutStr("logical_op", logicalOpAttributeValue)
	dp.Attributes().PutStr("input_type", inputTypeAttributeValue)
	dp.Attributes().PutStr("schema_name", schemaNameAttributeValue)
	dp.Attributes().PutStr("table_name", tableNameAttributeValue)
	dp.Attributes().PutStr("index_name", indexNameAttributeValue)
	dp.Attributes().PutStr("referenced_columns", referencedColumnsAttributeValue)
	dp.Attributes().PutDouble("estimate_rows", estimateRowsAttributeValue)
	dp.Attributes().PutDouble("estimate_io", estimateIoAttributeValue)
	dp.Attributes().PutDouble("estimate_cpu", estimateCPUAttributeValue)
	dp.Attributes().PutDouble("avg_row_size", avgRowSizeAttributeValue)
	dp.Attributes().PutDouble("total_subtree_cost", totalSubtreeCostAttributeValue)
	dp.Attributes().PutDouble("estimated_operator_cost", estimatedOperatorCostAttributeValue)
	dp.Attributes().PutStr("estimated_execution_mode", estimatedExecutionModeAttributeValue)
	dp.Attributes().PutInt("granted_memory_kb", grantedMemoryKbAttributeValue)
	dp.Attributes().PutBool("spill_occurred", spillOccurredAttributeValue)
	dp.Attributes().PutBool("no_join_predicate", noJoinPredicateAttributeValue)
	dp.Attributes().PutDouble("total_worker_time", totalWorkerTimeAttributeValue)
	dp.Attributes().PutDouble("total_elapsed_time", totalElapsedTimeAttributeValue)
	dp.Attributes().PutInt("total_logical_reads", totalLogicalReadsAttributeValue)
	dp.Attributes().PutInt("execution_count", executionCountAttributeValue)
	dp.Attributes().PutStr("request_start_time", requestStartTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
	dp.Attributes().PutStr("newrelic.event.type", newrelicEventTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverExecutionPlan) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverExecutionPlan) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverExecutionPlan(cfg MetricConfig) metricSqlserverExecutionPlan {
	m := metricSqlserverExecutionPlan{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterAgClusterType struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.ag_cluster_type metric with initial data.
func (m *metricSqlserverFailoverClusterAgClusterType) init() {
	m.data.SetName("sqlserver.failover_cluster.ag_cluster_type")
	m.data.SetDescription("Cluster type for the availability group (WSFC, EXTERNAL, NONE)")
	m.data.SetUnit("{status}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterAgClusterType) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("group_name", groupNameAttributeValue)
	dp.Attributes().PutStr("cluster_type_desc", clusterTypeDescAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterAgClusterType) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterAgClusterType) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterAgClusterType(cfg MetricConfig) metricSqlserverFailoverClusterAgClusterType {
	m := metricSqlserverFailoverClusterAgClusterType{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterAgFailureConditionLevel struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.ag_failure_condition_level metric with initial data.
func (m *metricSqlserverFailoverClusterAgFailureConditionLevel) init() {
	m.data.SetName("sqlserver.failover_cluster.ag_failure_condition_level")
	m.data.SetDescription("Automatic failover condition level for the availability group (1-5)")
	m.data.SetUnit("{level}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterAgFailureConditionLevel) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("group_name", groupNameAttributeValue)
	dp.Attributes().PutStr("cluster_type_desc", clusterTypeDescAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterAgFailureConditionLevel) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterAgFailureConditionLevel) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterAgFailureConditionLevel(cfg MetricConfig) metricSqlserverFailoverClusterAgFailureConditionLevel {
	m := metricSqlserverFailoverClusterAgFailureConditionLevel{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterAgHealthCheckTimeout struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.ag_health_check_timeout metric with initial data.
func (m *metricSqlserverFailoverClusterAgHealthCheckTimeout) init() {
	m.data.SetName("sqlserver.failover_cluster.ag_health_check_timeout")
	m.data.SetDescription("Health check timeout for the availability group in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterAgHealthCheckTimeout) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("group_name", groupNameAttributeValue)
	dp.Attributes().PutStr("cluster_type_desc", clusterTypeDescAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterAgHealthCheckTimeout) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterAgHealthCheckTimeout) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterAgHealthCheckTimeout(cfg MetricConfig) metricSqlserverFailoverClusterAgHealthCheckTimeout {
	m := metricSqlserverFailoverClusterAgHealthCheckTimeout{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterAgReplicaRole struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.ag_replica_role metric with initial data.
func (m *metricSqlserverFailoverClusterAgReplicaRole) init() {
	m.data.SetName("sqlserver.failover_cluster.ag_replica_role")
	m.data.SetDescription("Current role of the replica within the Availability Group (PRIMARY or SECONDARY)")
	m.data.SetUnit("{status}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterAgReplicaRole) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, roleDescAttributeValue string, synchronizationHealthDescAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("replica_server_name", replicaServerNameAttributeValue)
	dp.Attributes().PutStr("role_desc", roleDescAttributeValue)
	dp.Attributes().PutStr("synchronization_health_desc", synchronizationHealthDescAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterAgReplicaRole) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterAgReplicaRole) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterAgReplicaRole(cfg MetricConfig) metricSqlserverFailoverClusterAgReplicaRole {
	m := metricSqlserverFailoverClusterAgReplicaRole{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterAgRequiredSyncSecondaries struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.ag_required_sync_secondaries metric with initial data.
func (m *metricSqlserverFailoverClusterAgRequiredSyncSecondaries) init() {
	m.data.SetName("sqlserver.failover_cluster.ag_required_sync_secondaries")
	m.data.SetDescription("Number of synchronous secondary replicas required to commit transactions")
	m.data.SetUnit("{replicas}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterAgRequiredSyncSecondaries) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("group_name", groupNameAttributeValue)
	dp.Attributes().PutStr("cluster_type_desc", clusterTypeDescAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterAgRequiredSyncSecondaries) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterAgRequiredSyncSecondaries) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterAgRequiredSyncSecondaries(cfg MetricConfig) metricSqlserverFailoverClusterAgRequiredSyncSecondaries {
	m := metricSqlserverFailoverClusterAgRequiredSyncSecondaries{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterAgSynchronizationHealth struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.ag_synchronization_health metric with initial data.
func (m *metricSqlserverFailoverClusterAgSynchronizationHealth) init() {
	m.data.SetName("sqlserver.failover_cluster.ag_synchronization_health")
	m.data.SetDescription("Health of data synchronization between primary and secondary replica (HEALTHY, PARTIALLY_HEALTHY, NOT_HEALTHY)")
	m.data.SetUnit("{status}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterAgSynchronizationHealth) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, roleDescAttributeValue string, synchronizationHealthDescAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("replica_server_name", replicaServerNameAttributeValue)
	dp.Attributes().PutStr("role_desc", roleDescAttributeValue)
	dp.Attributes().PutStr("synchronization_health_desc", synchronizationHealthDescAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterAgSynchronizationHealth) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterAgSynchronizationHealth) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterAgSynchronizationHealth(cfg MetricConfig) metricSqlserverFailoverClusterAgSynchronizationHealth {
	m := metricSqlserverFailoverClusterAgSynchronizationHealth{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterFlowControlTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.flow_control_time_ms metric with initial data.
func (m *metricSqlserverFailoverClusterFlowControlTimeMs) init() {
	m.data.SetName("sqlserver.failover_cluster.flow_control_time_ms")
	m.data.SetDescription("Time spent in flow control by log records from primary replica in milliseconds per second")
	m.data.SetUnit("ms/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterFlowControlTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("instance_name", instanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterFlowControlTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterFlowControlTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterFlowControlTimeMs(cfg MetricConfig) metricSqlserverFailoverClusterFlowControlTimeMs {
	m := metricSqlserverFailoverClusterFlowControlTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterLogBytesReceivedPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.log_bytes_received_per_sec metric with initial data.
func (m *metricSqlserverFailoverClusterLogBytesReceivedPerSec) init() {
	m.data.SetName("sqlserver.failover_cluster.log_bytes_received_per_sec")
	m.data.SetDescription("Rate of log records received by secondary replica from primary replica in bytes per second")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterLogBytesReceivedPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("instance_name", instanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterLogBytesReceivedPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterLogBytesReceivedPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterLogBytesReceivedPerSec(cfg MetricConfig) metricSqlserverFailoverClusterLogBytesReceivedPerSec {
	m := metricSqlserverFailoverClusterLogBytesReceivedPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterLogSendQueueKb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.log_send_queue_kb metric with initial data.
func (m *metricSqlserverFailoverClusterLogSendQueueKb) init() {
	m.data.SetName("sqlserver.failover_cluster.log_send_queue_kb")
	m.data.SetDescription("Amount of log records in the log send queue waiting to be sent to the secondary replica in kilobytes")
	m.data.SetUnit("KBy")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterLogSendQueueKb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("replica_server_name", replicaServerNameAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterLogSendQueueKb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterLogSendQueueKb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterLogSendQueueKb(cfg MetricConfig) metricSqlserverFailoverClusterLogSendQueueKb {
	m := metricSqlserverFailoverClusterLogSendQueueKb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterRedoQueueKb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.redo_queue_kb metric with initial data.
func (m *metricSqlserverFailoverClusterRedoQueueKb) init() {
	m.data.SetName("sqlserver.failover_cluster.redo_queue_kb")
	m.data.SetDescription("Amount of log records in the redo queue waiting to be redone on the secondary replica in kilobytes")
	m.data.SetUnit("KBy")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterRedoQueueKb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("replica_server_name", replicaServerNameAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterRedoQueueKb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterRedoQueueKb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterRedoQueueKb(cfg MetricConfig) metricSqlserverFailoverClusterRedoQueueKb {
	m := metricSqlserverFailoverClusterRedoQueueKb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterRedoRateKbSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.redo_rate_kb_sec metric with initial data.
func (m *metricSqlserverFailoverClusterRedoRateKbSec) init() {
	m.data.SetName("sqlserver.failover_cluster.redo_rate_kb_sec")
	m.data.SetDescription("Rate at which log records are being redone on the secondary replica in kilobytes per second")
	m.data.SetUnit("KBy/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterRedoRateKbSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("replica_server_name", replicaServerNameAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterRedoRateKbSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterRedoRateKbSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterRedoRateKbSec(cfg MetricConfig) metricSqlserverFailoverClusterRedoRateKbSec {
	m := metricSqlserverFailoverClusterRedoRateKbSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverFailoverClusterTransactionDelayMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.failover_cluster.transaction_delay_ms metric with initial data.
func (m *metricSqlserverFailoverClusterTransactionDelayMs) init() {
	m.data.SetName("sqlserver.failover_cluster.transaction_delay_ms")
	m.data.SetDescription("Average delay for transactions on the secondary replica in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverFailoverClusterTransactionDelayMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, instanceNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("instance_name", instanceNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverFailoverClusterTransactionDelayMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverFailoverClusterTransactionDelayMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverFailoverClusterTransactionDelayMs(cfg MetricConfig) metricSqlserverFailoverClusterTransactionDelayMs {
	m := metricSqlserverFailoverClusterTransactionDelayMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverIndividualQueryTotalCPUMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.individual_query.total_cpu_ms metric with initial data.
func (m *metricSqlserverIndividualQueryTotalCPUMs) init() {
	m.data.SetName("sqlserver.individual_query.total_cpu_ms")
	m.data.SetDescription("Total CPU time in milliseconds for individual query analysis")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverIndividualQueryTotalCPUMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanIDAttributeValue string, queryTextAttributeValue string, creationTimeAttributeValue string, lastExecutionTimeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_id", queryPlanIDAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverIndividualQueryTotalCPUMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverIndividualQueryTotalCPUMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverIndividualQueryTotalCPUMs(cfg MetricConfig) metricSqlserverIndividualQueryTotalCPUMs {
	m := metricSqlserverIndividualQueryTotalCPUMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverIndividualQueryTotalElapsedMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.individual_query.total_elapsed_ms metric with initial data.
func (m *metricSqlserverIndividualQueryTotalElapsedMs) init() {
	m.data.SetName("sqlserver.individual_query.total_elapsed_ms")
	m.data.SetDescription("Total elapsed time in milliseconds for individual query analysis")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverIndividualQueryTotalElapsedMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanIDAttributeValue string, queryTextAttributeValue string, creationTimeAttributeValue string, lastExecutionTimeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_plan_id", queryPlanIDAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverIndividualQueryTotalElapsedMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverIndividualQueryTotalElapsedMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverIndividualQueryTotalElapsedMs(cfg MetricConfig) metricSqlserverIndividualQueryTotalElapsedMs {
	m := metricSqlserverIndividualQueryTotalElapsedMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceBackgroundProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.background_processes_count metric with initial data.
func (m *metricSqlserverInstanceBackgroundProcessesCount) init() {
	m.data.SetName("sqlserver.instance.background_processes_count")
	m.data.SetDescription("Number of background processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceBackgroundProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceBackgroundProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceBackgroundProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceBackgroundProcessesCount(cfg MetricConfig) metricSqlserverInstanceBackgroundProcessesCount {
	m := metricSqlserverInstanceBackgroundProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceBlockedProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.blocked_processes_count metric with initial data.
func (m *metricSqlserverInstanceBlockedProcessesCount) init() {
	m.data.SetName("sqlserver.instance.blocked_processes_count")
	m.data.SetDescription("Number of blocked processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceBlockedProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceBlockedProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceBlockedProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceBlockedProcessesCount(cfg MetricConfig) metricSqlserverInstanceBlockedProcessesCount {
	m := metricSqlserverInstanceBlockedProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceBufferPoolHitPercent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.buffer_pool_hit_percent metric with initial data.
func (m *metricSqlserverInstanceBufferPoolHitPercent) init() {
	m.data.SetName("sqlserver.instance.buffer_pool_hit_percent")
	m.data.SetDescription("Buffer pool hit percentage")
	m.data.SetUnit("Percent")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceBufferPoolHitPercent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceBufferPoolHitPercent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceBufferPoolHitPercent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceBufferPoolHitPercent(cfg MetricConfig) metricSqlserverInstanceBufferPoolHitPercent {
	m := metricSqlserverInstanceBufferPoolHitPercent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceBufferPoolSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.buffer_pool_size metric with initial data.
func (m *metricSqlserverInstanceBufferPoolSize) init() {
	m.data.SetName("sqlserver.instance.buffer_pool_size")
	m.data.SetDescription("Buffer pool size")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceBufferPoolSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceBufferPoolSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceBufferPoolSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceBufferPoolSize(cfg MetricConfig) metricSqlserverInstanceBufferPoolSize {
	m := metricSqlserverInstanceBufferPoolSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceCompilationsPerBatch struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.compilations_per_batch metric with initial data.
func (m *metricSqlserverInstanceCompilationsPerBatch) init() {
	m.data.SetName("sqlserver.instance.compilations_per_batch")
	m.data.SetDescription("SQL compilations per batch request")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceCompilationsPerBatch) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceCompilationsPerBatch) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceCompilationsPerBatch) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceCompilationsPerBatch(cfg MetricConfig) metricSqlserverInstanceCompilationsPerBatch {
	m := metricSqlserverInstanceCompilationsPerBatch{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceConnectionsActive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.connections_active metric with initial data.
func (m *metricSqlserverInstanceConnectionsActive) init() {
	m.data.SetName("sqlserver.instance.connections_active")
	m.data.SetDescription("Number of active connections")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceConnectionsActive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceConnectionsActive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceConnectionsActive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceConnectionsActive(cfg MetricConfig) metricSqlserverInstanceConnectionsActive {
	m := metricSqlserverInstanceConnectionsActive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceDiskInBytes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.disk_in_bytes metric with initial data.
func (m *metricSqlserverInstanceDiskInBytes) init() {
	m.data.SetName("sqlserver.instance.disk_in_bytes")
	m.data.SetDescription("Total disk space in bytes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceDiskInBytes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceDiskInBytes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceDiskInBytes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceDiskInBytes(cfg MetricConfig) metricSqlserverInstanceDiskInBytes {
	m := metricSqlserverInstanceDiskInBytes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceDormantProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.dormant_processes_count metric with initial data.
func (m *metricSqlserverInstanceDormantProcessesCount) init() {
	m.data.SetName("sqlserver.instance.dormant_processes_count")
	m.data.SetDescription("Number of dormant processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceDormantProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceDormantProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceDormantProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceDormantProcessesCount(cfg MetricConfig) metricSqlserverInstanceDormantProcessesCount {
	m := metricSqlserverInstanceDormantProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceForcedParameterizationsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.forced_parameterizations_per_sec metric with initial data.
func (m *metricSqlserverInstanceForcedParameterizationsPerSec) init() {
	m.data.SetName("sqlserver.instance.forced_parameterizations_per_sec")
	m.data.SetDescription("Forced parameterizations per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceForcedParameterizationsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceForcedParameterizationsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceForcedParameterizationsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceForcedParameterizationsPerSec(cfg MetricConfig) metricSqlserverInstanceForcedParameterizationsPerSec {
	m := metricSqlserverInstanceForcedParameterizationsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceFullScansRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.full_scans_rate metric with initial data.
func (m *metricSqlserverInstanceFullScansRate) init() {
	m.data.SetName("sqlserver.instance.full_scans_rate")
	m.data.SetDescription("Full table/index scans per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceFullScansRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceFullScansRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceFullScansRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceFullScansRate(cfg MetricConfig) metricSqlserverInstanceFullScansRate {
	m := metricSqlserverInstanceFullScansRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceLockTimeoutsRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.lock_timeouts_rate metric with initial data.
func (m *metricSqlserverInstanceLockTimeoutsRate) init() {
	m.data.SetName("sqlserver.instance.lock_timeouts_rate")
	m.data.SetDescription("Number of lock timeouts per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceLockTimeoutsRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceLockTimeoutsRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceLockTimeoutsRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceLockTimeoutsRate(cfg MetricConfig) metricSqlserverInstanceLockTimeoutsRate {
	m := metricSqlserverInstanceLockTimeoutsRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.memory_available metric with initial data.
func (m *metricSqlserverInstanceMemoryAvailable) init() {
	m.data.SetName("sqlserver.instance.memory_available")
	m.data.SetDescription("Available physical memory on the system")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceMemoryAvailable(cfg MetricConfig) metricSqlserverInstanceMemoryAvailable {
	m := metricSqlserverInstanceMemoryAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceMemoryTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.memory_total metric with initial data.
func (m *metricSqlserverInstanceMemoryTotal) init() {
	m.data.SetName("sqlserver.instance.memory_total")
	m.data.SetDescription("Total physical memory on the system")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceMemoryTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceMemoryTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceMemoryTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceMemoryTotal(cfg MetricConfig) metricSqlserverInstanceMemoryTotal {
	m := metricSqlserverInstanceMemoryTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceMemoryUtilizationPercent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.memory_utilization_percent metric with initial data.
func (m *metricSqlserverInstanceMemoryUtilizationPercent) init() {
	m.data.SetName("sqlserver.instance.memory_utilization_percent")
	m.data.SetDescription("Percentage of memory utilization")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceMemoryUtilizationPercent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceMemoryUtilizationPercent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceMemoryUtilizationPercent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceMemoryUtilizationPercent(cfg MetricConfig) metricSqlserverInstanceMemoryUtilizationPercent {
	m := metricSqlserverInstanceMemoryUtilizationPercent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstancePageSplitsPerBatch struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.page_splits_per_batch metric with initial data.
func (m *metricSqlserverInstancePageSplitsPerBatch) init() {
	m.data.SetName("sqlserver.instance.page_splits_per_batch")
	m.data.SetDescription("Page splits per batch request")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstancePageSplitsPerBatch) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstancePageSplitsPerBatch) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstancePageSplitsPerBatch) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstancePageSplitsPerBatch(cfg MetricConfig) metricSqlserverInstancePageSplitsPerBatch {
	m := metricSqlserverInstancePageSplitsPerBatch{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstancePreconnectProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.preconnect_processes_count metric with initial data.
func (m *metricSqlserverInstancePreconnectProcessesCount) init() {
	m.data.SetName("sqlserver.instance.preconnect_processes_count")
	m.data.SetDescription("Number of preconnect processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstancePreconnectProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstancePreconnectProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstancePreconnectProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstancePreconnectProcessesCount(cfg MetricConfig) metricSqlserverInstancePreconnectProcessesCount {
	m := metricSqlserverInstancePreconnectProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceRunnableProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.runnable_processes_count metric with initial data.
func (m *metricSqlserverInstanceRunnableProcessesCount) init() {
	m.data.SetName("sqlserver.instance.runnable_processes_count")
	m.data.SetDescription("Number of runnable processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceRunnableProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceRunnableProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceRunnableProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceRunnableProcessesCount(cfg MetricConfig) metricSqlserverInstanceRunnableProcessesCount {
	m := metricSqlserverInstanceRunnableProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceRunnableTasks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.runnable_tasks metric with initial data.
func (m *metricSqlserverInstanceRunnableTasks) init() {
	m.data.SetName("sqlserver.instance.runnable_tasks")
	m.data.SetDescription("Number of runnable tasks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceRunnableTasks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceRunnableTasks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceRunnableTasks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceRunnableTasks(cfg MetricConfig) metricSqlserverInstanceRunnableTasks {
	m := metricSqlserverInstanceRunnableTasks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceRunningProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.running_processes_count metric with initial data.
func (m *metricSqlserverInstanceRunningProcessesCount) init() {
	m.data.SetName("sqlserver.instance.running_processes_count")
	m.data.SetDescription("Number of running processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceRunningProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceRunningProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceRunningProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceRunningProcessesCount(cfg MetricConfig) metricSqlserverInstanceRunningProcessesCount {
	m := metricSqlserverInstanceRunningProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceSleepingProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.sleeping_processes_count metric with initial data.
func (m *metricSqlserverInstanceSleepingProcessesCount) init() {
	m.data.SetName("sqlserver.instance.sleeping_processes_count")
	m.data.SetDescription("Number of sleeping processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceSleepingProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceSleepingProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceSleepingProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceSleepingProcessesCount(cfg MetricConfig) metricSqlserverInstanceSleepingProcessesCount {
	m := metricSqlserverInstanceSleepingProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceSuspendedProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.suspended_processes_count metric with initial data.
func (m *metricSqlserverInstanceSuspendedProcessesCount) init() {
	m.data.SetName("sqlserver.instance.suspended_processes_count")
	m.data.SetDescription("Number of suspended processes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceSuspendedProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceSuspendedProcessesCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceSuspendedProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceSuspendedProcessesCount(cfg MetricConfig) metricSqlserverInstanceSuspendedProcessesCount {
	m := metricSqlserverInstanceSuspendedProcessesCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceTargetMemoryKb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.target_memory_kb metric with initial data.
func (m *metricSqlserverInstanceTargetMemoryKb) init() {
	m.data.SetName("sqlserver.instance.target_memory_kb")
	m.data.SetDescription("Target server memory in KB")
	m.data.SetUnit("kb")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceTargetMemoryKb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceTargetMemoryKb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceTargetMemoryKb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceTargetMemoryKb(cfg MetricConfig) metricSqlserverInstanceTargetMemoryKb {
	m := metricSqlserverInstanceTargetMemoryKb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverInstanceTransactionsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.instance.transactions_per_sec metric with initial data.
func (m *metricSqlserverInstanceTransactionsPerSec) init() {
	m.data.SetName("sqlserver.instance.transactions_per_sec")
	m.data.SetDescription("Transactions per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverInstanceTransactionsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverInstanceTransactionsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverInstanceTransactionsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverInstanceTransactionsPerSec(cfg MetricConfig) metricSqlserverInstanceTransactionsPerSec {
	m := metricSqlserverInstanceTransactionsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeBulkUpdate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.bulk_update metric with initial data.
func (m *metricSqlserverLockModeBulkUpdate) init() {
	m.data.SetName("sqlserver.lock.mode.bulk_update")
	m.data.SetDescription("Number of bulk update locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeBulkUpdate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeBulkUpdate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeBulkUpdate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeBulkUpdate(cfg MetricConfig) metricSqlserverLockModeBulkUpdate {
	m := metricSqlserverLockModeBulkUpdate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeExclusive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.exclusive metric with initial data.
func (m *metricSqlserverLockModeExclusive) init() {
	m.data.SetName("sqlserver.lock.mode.exclusive")
	m.data.SetDescription("Number of exclusive locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeExclusive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeExclusive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeExclusive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeExclusive(cfg MetricConfig) metricSqlserverLockModeExclusive {
	m := metricSqlserverLockModeExclusive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeIntent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.intent metric with initial data.
func (m *metricSqlserverLockModeIntent) init() {
	m.data.SetName("sqlserver.lock.mode.intent")
	m.data.SetDescription("Number of intent locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeIntent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeIntent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeIntent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeIntent(cfg MetricConfig) metricSqlserverLockModeIntent {
	m := metricSqlserverLockModeIntent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeSchema struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.schema metric with initial data.
func (m *metricSqlserverLockModeSchema) init() {
	m.data.SetName("sqlserver.lock.mode.schema")
	m.data.SetDescription("Number of schema locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeSchema) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeSchema) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeSchema) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeSchema(cfg MetricConfig) metricSqlserverLockModeSchema {
	m := metricSqlserverLockModeSchema{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeShared struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.shared metric with initial data.
func (m *metricSqlserverLockModeShared) init() {
	m.data.SetName("sqlserver.lock.mode.shared")
	m.data.SetDescription("Number of shared locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeShared) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeShared) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeShared) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeShared(cfg MetricConfig) metricSqlserverLockModeShared {
	m := metricSqlserverLockModeShared{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeSharedIntentExclusive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.shared_intent_exclusive metric with initial data.
func (m *metricSqlserverLockModeSharedIntentExclusive) init() {
	m.data.SetName("sqlserver.lock.mode.shared_intent_exclusive")
	m.data.SetDescription("Number of shared intent exclusive locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeSharedIntentExclusive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeSharedIntentExclusive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeSharedIntentExclusive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeSharedIntentExclusive(cfg MetricConfig) metricSqlserverLockModeSharedIntentExclusive {
	m := metricSqlserverLockModeSharedIntentExclusive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.total metric with initial data.
func (m *metricSqlserverLockModeTotal) init() {
	m.data.SetName("sqlserver.lock.mode.total")
	m.data.SetDescription("Total active locks by mode")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeTotal(cfg MetricConfig) metricSqlserverLockModeTotal {
	m := metricSqlserverLockModeTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockModeUpdate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.mode.update metric with initial data.
func (m *metricSqlserverLockModeUpdate) init() {
	m.data.SetName("sqlserver.lock.mode.update")
	m.data.SetDescription("Number of update locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockModeUpdate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockModeUpdate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockModeUpdate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockModeUpdate(cfg MetricConfig) metricSqlserverLockModeUpdate {
	m := metricSqlserverLockModeUpdate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceAllocationUnit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.allocation_unit metric with initial data.
func (m *metricSqlserverLockResourceAllocationUnit) init() {
	m.data.SetName("sqlserver.lock.resource.allocation_unit")
	m.data.SetDescription("Number of allocation unit locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceAllocationUnit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceAllocationUnit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceAllocationUnit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceAllocationUnit(cfg MetricConfig) metricSqlserverLockResourceAllocationUnit {
	m := metricSqlserverLockResourceAllocationUnit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceApplication struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.application metric with initial data.
func (m *metricSqlserverLockResourceApplication) init() {
	m.data.SetName("sqlserver.lock.resource.application")
	m.data.SetDescription("Number of application locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceApplication) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceApplication) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceApplication) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceApplication(cfg MetricConfig) metricSqlserverLockResourceApplication {
	m := metricSqlserverLockResourceApplication{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceDatabaseLevel struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.database_level metric with initial data.
func (m *metricSqlserverLockResourceDatabaseLevel) init() {
	m.data.SetName("sqlserver.lock.resource.database_level")
	m.data.SetDescription("Number of database-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceDatabaseLevel) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceDatabaseLevel) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceDatabaseLevel) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceDatabaseLevel(cfg MetricConfig) metricSqlserverLockResourceDatabaseLevel {
	m := metricSqlserverLockResourceDatabaseLevel{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceExtent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.extent metric with initial data.
func (m *metricSqlserverLockResourceExtent) init() {
	m.data.SetName("sqlserver.lock.resource.extent")
	m.data.SetDescription("Number of extent-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceExtent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceExtent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceExtent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceExtent(cfg MetricConfig) metricSqlserverLockResourceExtent {
	m := metricSqlserverLockResourceExtent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceFile struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.file metric with initial data.
func (m *metricSqlserverLockResourceFile) init() {
	m.data.SetName("sqlserver.lock.resource.file")
	m.data.SetDescription("Number of file-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceFile) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceFile) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceFile) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceFile(cfg MetricConfig) metricSqlserverLockResourceFile {
	m := metricSqlserverLockResourceFile{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceHobt struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.hobt metric with initial data.
func (m *metricSqlserverLockResourceHobt) init() {
	m.data.SetName("sqlserver.lock.resource.hobt")
	m.data.SetDescription("Number of heap or B-tree locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceHobt) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceHobt) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceHobt) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceHobt(cfg MetricConfig) metricSqlserverLockResourceHobt {
	m := metricSqlserverLockResourceHobt{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceKey struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.key metric with initial data.
func (m *metricSqlserverLockResourceKey) init() {
	m.data.SetName("sqlserver.lock.resource.key")
	m.data.SetDescription("Number of key-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceKey) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceKey) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceKey) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceKey(cfg MetricConfig) metricSqlserverLockResourceKey {
	m := metricSqlserverLockResourceKey{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceMetadata struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.metadata metric with initial data.
func (m *metricSqlserverLockResourceMetadata) init() {
	m.data.SetName("sqlserver.lock.resource.metadata")
	m.data.SetDescription("Number of metadata locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceMetadata) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceMetadata) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceMetadata) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceMetadata(cfg MetricConfig) metricSqlserverLockResourceMetadata {
	m := metricSqlserverLockResourceMetadata{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourcePage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.page metric with initial data.
func (m *metricSqlserverLockResourcePage) init() {
	m.data.SetName("sqlserver.lock.resource.page")
	m.data.SetDescription("Number of page-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourcePage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourcePage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourcePage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourcePage(cfg MetricConfig) metricSqlserverLockResourcePage {
	m := metricSqlserverLockResourcePage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceRow struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.row metric with initial data.
func (m *metricSqlserverLockResourceRow) init() {
	m.data.SetName("sqlserver.lock.resource.row")
	m.data.SetDescription("Number of row-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceRow) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceRow) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceRow) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceRow(cfg MetricConfig) metricSqlserverLockResourceRow {
	m := metricSqlserverLockResourceRow{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceTable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.table metric with initial data.
func (m *metricSqlserverLockResourceTable) init() {
	m.data.SetName("sqlserver.lock.resource.table")
	m.data.SetDescription("Number of table-level locks")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceTable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceTable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceTable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceTable(cfg MetricConfig) metricSqlserverLockResourceTable {
	m := metricSqlserverLockResourceTable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockResourceTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.resource.total metric with initial data.
func (m *metricSqlserverLockResourceTotal) init() {
	m.data.SetName("sqlserver.lock.resource.total")
	m.data.SetDescription("Total active locks in the database")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverLockResourceTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockResourceTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockResourceTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockResourceTotal(cfg MetricConfig) metricSqlserverLockResourceTotal {
	m := metricSqlserverLockResourceTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockedObject struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.locked_object metric with initial data.
func (m *metricSqlserverLockedObject) init() {
	m.data.SetName("sqlserver.locked_object")
	m.data.SetDescription("Database object locked by a session")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockedObject) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockedObject) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockedObject) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockedObject(cfg MetricConfig) metricSqlserverLockedObject {
	m := metricSqlserverLockedObject{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverMemoryTarget struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.memory.target metric with initial data.
func (m *metricSqlserverMemoryTarget) init() {
	m.data.SetName("sqlserver.memory.target")
	m.data.SetDescription("Target server memory in KB")
	m.data.SetUnit("kBy")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverMemoryTarget) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverMemoryTarget) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverMemoryTarget) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverMemoryTarget(cfg MetricConfig) metricSqlserverMemoryTarget {
	m := metricSqlserverMemoryTarget{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverMemoryTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.memory.total metric with initial data.
func (m *metricSqlserverMemoryTotal) init() {
	m.data.SetName("sqlserver.memory.total")
	m.data.SetDescription("Total server memory in KB")
	m.data.SetUnit("kBy")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverMemoryTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverMemoryTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverMemoryTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverMemoryTotal(cfg MetricConfig) metricSqlserverMemoryTotal {
	m := metricSqlserverMemoryTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPlanAvgElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.plan.avg_elapsed_time_ms metric with initial data.
func (m *metricSqlserverPlanAvgElapsedTimeMs) init() {
	m.data.SetName("sqlserver.plan.avg_elapsed_time_ms")
	m.data.SetDescription("Average elapsed time per execution of this plan (historical) - Used in NRQL queries")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverPlanAvgElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("last_execution_time", lastExecutionTimeAttributeValue)
	dp.Attributes().PutStr("creation_time", creationTimeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPlanAvgElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPlanAvgElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPlanAvgElapsedTimeMs(cfg MetricConfig) metricSqlserverPlanAvgElapsedTimeMs {
	m := metricSqlserverPlanAvgElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSecurityServerPrincipalsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.security.server_principals_count metric with initial data.
func (m *metricSqlserverSecurityServerPrincipalsCount) init() {
	m.data.SetName("sqlserver.security.server_principals_count")
	m.data.SetDescription("Total number of server principals (logins)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSecurityServerPrincipalsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, metricTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("metric.type", metricTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSecurityServerPrincipalsCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSecurityServerPrincipalsCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSecurityServerPrincipalsCount(cfg MetricConfig) metricSqlserverSecurityServerPrincipalsCount {
	m := metricSqlserverSecurityServerPrincipalsCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSecurityServerRoleMembersCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.security.server_role_members_count metric with initial data.
func (m *metricSqlserverSecurityServerRoleMembersCount) init() {
	m.data.SetName("sqlserver.security.server_role_members_count")
	m.data.SetDescription("Total number of server role members")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSecurityServerRoleMembersCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, metricTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("metric.type", metricTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSecurityServerRoleMembersCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSecurityServerRoleMembersCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSecurityServerRoleMembersCount(cfg MetricConfig) metricSqlserverSecurityServerRoleMembersCount {
	m := metricSqlserverSecurityServerRoleMembersCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryAvgElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.avg_elapsed_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryAvgElapsedTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.avg_elapsed_time_ms")
	m.data.SetDescription("Average elapsed time per execution in milliseconds (cumulative since plan cached)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryAvgElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryAvgElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryAvgElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryAvgElapsedTimeMs(cfg MetricConfig) metricSqlserverSlowqueryAvgElapsedTimeMs {
	m := metricSqlserverSlowqueryAvgElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryHistoricalExecutionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.historical_execution_count metric with initial data.
func (m *metricSqlserverSlowqueryHistoricalExecutionCount) init() {
	m.data.SetName("sqlserver.slowquery.historical_execution_count")
	m.data.SetDescription("Historical execution count (cumulative since plan cached)")
	m.data.SetUnit("{executions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryHistoricalExecutionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryHistoricalExecutionCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryHistoricalExecutionCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryHistoricalExecutionCount(cfg MetricConfig) metricSqlserverSlowqueryHistoricalExecutionCount {
	m := metricSqlserverSlowqueryHistoricalExecutionCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryHistoricalLogicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.historical_logical_reads metric with initial data.
func (m *metricSqlserverSlowqueryHistoricalLogicalReads) init() {
	m.data.SetName("sqlserver.slowquery.historical_logical_reads")
	m.data.SetDescription("Historical total logical reads (cumulative since plan cached)")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryHistoricalLogicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryHistoricalLogicalReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryHistoricalLogicalReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryHistoricalLogicalReads(cfg MetricConfig) metricSqlserverSlowqueryHistoricalLogicalReads {
	m := metricSqlserverSlowqueryHistoricalLogicalReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryHistoricalPhysicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.historical_physical_reads metric with initial data.
func (m *metricSqlserverSlowqueryHistoricalPhysicalReads) init() {
	m.data.SetName("sqlserver.slowquery.historical_physical_reads")
	m.data.SetDescription("Historical total physical reads (cumulative since plan cached)")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryHistoricalPhysicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryHistoricalPhysicalReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryHistoricalPhysicalReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryHistoricalPhysicalReads(cfg MetricConfig) metricSqlserverSlowqueryHistoricalPhysicalReads {
	m := metricSqlserverSlowqueryHistoricalPhysicalReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryHistoricalRows struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.historical_rows metric with initial data.
func (m *metricSqlserverSlowqueryHistoricalRows) init() {
	m.data.SetName("sqlserver.slowquery.historical_rows")
	m.data.SetDescription("Historical total rows returned (cumulative since plan cached)")
	m.data.SetUnit("{rows}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryHistoricalRows) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryHistoricalRows) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryHistoricalRows) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryHistoricalRows(cfg MetricConfig) metricSqlserverSlowqueryHistoricalRows {
	m := metricSqlserverSlowqueryHistoricalRows{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryHistoricalWaitTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.historical_wait_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryHistoricalWaitTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.historical_wait_time_ms")
	m.data.SetDescription("Historical total wait time in milliseconds (elapsed_time - worker_time, cumulative since plan cached)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryHistoricalWaitTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryHistoricalWaitTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryHistoricalWaitTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryHistoricalWaitTimeMs(cfg MetricConfig) metricSqlserverSlowqueryHistoricalWaitTimeMs {
	m := metricSqlserverSlowqueryHistoricalWaitTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryHistoricalWorkerTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.historical_worker_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryHistoricalWorkerTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.historical_worker_time_ms")
	m.data.SetDescription("Historical total worker (CPU) time in milliseconds (cumulative since plan cached)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryHistoricalWorkerTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryHistoricalWorkerTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryHistoricalWorkerTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryHistoricalWorkerTimeMs(cfg MetricConfig) metricSqlserverSlowqueryHistoricalWorkerTimeMs {
	m := metricSqlserverSlowqueryHistoricalWorkerTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalAvgElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_avg_elapsed_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryIntervalAvgElapsedTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.interval_avg_elapsed_time_ms")
	m.data.SetDescription("Interval average elapsed time in milliseconds (delta for this collection interval)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalAvgElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalAvgElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalAvgElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalAvgElapsedTimeMs(cfg MetricConfig) metricSqlserverSlowqueryIntervalAvgElapsedTimeMs {
	m := metricSqlserverSlowqueryIntervalAvgElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalAvgLogicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_avg_logical_reads metric with initial data.
func (m *metricSqlserverSlowqueryIntervalAvgLogicalReads) init() {
	m.data.SetName("sqlserver.slowquery.interval_avg_logical_reads")
	m.data.SetDescription("Interval average logical reads per execution")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalAvgLogicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalAvgLogicalReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalAvgLogicalReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalAvgLogicalReads(cfg MetricConfig) metricSqlserverSlowqueryIntervalAvgLogicalReads {
	m := metricSqlserverSlowqueryIntervalAvgLogicalReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalAvgPhysicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_avg_physical_reads metric with initial data.
func (m *metricSqlserverSlowqueryIntervalAvgPhysicalReads) init() {
	m.data.SetName("sqlserver.slowquery.interval_avg_physical_reads")
	m.data.SetDescription("Interval average physical reads per execution")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalAvgPhysicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalAvgPhysicalReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalAvgPhysicalReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalAvgPhysicalReads(cfg MetricConfig) metricSqlserverSlowqueryIntervalAvgPhysicalReads {
	m := metricSqlserverSlowqueryIntervalAvgPhysicalReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalAvgRows struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_avg_rows metric with initial data.
func (m *metricSqlserverSlowqueryIntervalAvgRows) init() {
	m.data.SetName("sqlserver.slowquery.interval_avg_rows")
	m.data.SetDescription("Interval average rows returned per execution")
	m.data.SetUnit("{rows}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalAvgRows) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalAvgRows) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalAvgRows) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalAvgRows(cfg MetricConfig) metricSqlserverSlowqueryIntervalAvgRows {
	m := metricSqlserverSlowqueryIntervalAvgRows{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalAvgWaitTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_avg_wait_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryIntervalAvgWaitTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.interval_avg_wait_time_ms")
	m.data.SetDescription("Interval average wait time per execution in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalAvgWaitTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalAvgWaitTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalAvgWaitTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalAvgWaitTimeMs(cfg MetricConfig) metricSqlserverSlowqueryIntervalAvgWaitTimeMs {
	m := metricSqlserverSlowqueryIntervalAvgWaitTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalAvgWorkerTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_avg_worker_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryIntervalAvgWorkerTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.interval_avg_worker_time_ms")
	m.data.SetDescription("Interval average worker (CPU) time per execution in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalAvgWorkerTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalAvgWorkerTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalAvgWorkerTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalAvgWorkerTimeMs(cfg MetricConfig) metricSqlserverSlowqueryIntervalAvgWorkerTimeMs {
	m := metricSqlserverSlowqueryIntervalAvgWorkerTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalElapsedTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_elapsed_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryIntervalElapsedTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.interval_elapsed_time_ms")
	m.data.SetDescription("Interval total elapsed time in milliseconds (delta for this collection interval)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalElapsedTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalElapsedTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalElapsedTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalElapsedTimeMs(cfg MetricConfig) metricSqlserverSlowqueryIntervalElapsedTimeMs {
	m := metricSqlserverSlowqueryIntervalElapsedTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalExecutionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_execution_count metric with initial data.
func (m *metricSqlserverSlowqueryIntervalExecutionCount) init() {
	m.data.SetName("sqlserver.slowquery.interval_execution_count")
	m.data.SetDescription("Interval execution count (delta for this collection interval)")
	m.data.SetUnit("{executions}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalExecutionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalExecutionCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalExecutionCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalExecutionCount(cfg MetricConfig) metricSqlserverSlowqueryIntervalExecutionCount {
	m := metricSqlserverSlowqueryIntervalExecutionCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalLogicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_logical_reads metric with initial data.
func (m *metricSqlserverSlowqueryIntervalLogicalReads) init() {
	m.data.SetName("sqlserver.slowquery.interval_logical_reads")
	m.data.SetDescription("Interval logical reads (delta for this collection interval)")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalLogicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalLogicalReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalLogicalReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalLogicalReads(cfg MetricConfig) metricSqlserverSlowqueryIntervalLogicalReads {
	m := metricSqlserverSlowqueryIntervalLogicalReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalPhysicalReads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_physical_reads metric with initial data.
func (m *metricSqlserverSlowqueryIntervalPhysicalReads) init() {
	m.data.SetName("sqlserver.slowquery.interval_physical_reads")
	m.data.SetDescription("Interval physical reads (delta for this collection interval)")
	m.data.SetUnit("{reads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalPhysicalReads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalPhysicalReads) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalPhysicalReads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalPhysicalReads(cfg MetricConfig) metricSqlserverSlowqueryIntervalPhysicalReads {
	m := metricSqlserverSlowqueryIntervalPhysicalReads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalRows struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_rows metric with initial data.
func (m *metricSqlserverSlowqueryIntervalRows) init() {
	m.data.SetName("sqlserver.slowquery.interval_rows")
	m.data.SetDescription("Interval rows returned (delta for this collection interval)")
	m.data.SetUnit("{rows}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalRows) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalRows) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalRows) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalRows(cfg MetricConfig) metricSqlserverSlowqueryIntervalRows {
	m := metricSqlserverSlowqueryIntervalRows{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalWaitTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_wait_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryIntervalWaitTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.interval_wait_time_ms")
	m.data.SetDescription("Interval wait time in milliseconds (delta for this collection interval)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalWaitTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalWaitTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalWaitTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalWaitTimeMs(cfg MetricConfig) metricSqlserverSlowqueryIntervalWaitTimeMs {
	m := metricSqlserverSlowqueryIntervalWaitTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryIntervalWorkerTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.interval_worker_time_ms metric with initial data.
func (m *metricSqlserverSlowqueryIntervalWorkerTimeMs) init() {
	m.data.SetName("sqlserver.slowquery.interval_worker_time_ms")
	m.data.SetDescription("Interval worker (CPU) time in milliseconds (delta for this collection interval)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryIntervalWorkerTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryIntervalWorkerTimeMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryIntervalWorkerTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryIntervalWorkerTimeMs(cfg MetricConfig) metricSqlserverSlowqueryIntervalWorkerTimeMs {
	m := metricSqlserverSlowqueryIntervalWorkerTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverSlowqueryQueryDetails struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.slowquery.query_details metric with initial data.
func (m *metricSqlserverSlowqueryQueryDetails) init() {
	m.data.SetName("sqlserver.slowquery.query_details")
	m.data.SetDescription("Query details including text and timestamps for slow queries")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverSlowqueryQueryDetails) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, planHandleAttributeValue string, queryTextAttributeValue string, collectionTimestampAttributeValue string, lastExecutionTimestampAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string, newrelicEventTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("query_id", queryIDAttributeValue)
	dp.Attributes().PutStr("database_name", databaseNameAttributeValue)
	dp.Attributes().PutStr("plan_handle", planHandleAttributeValue)
	dp.Attributes().PutStr("query_text", queryTextAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
	dp.Attributes().PutStr("last_execution_timestamp", lastExecutionTimestampAttributeValue)
	dp.Attributes().PutStr("normalised_sql_hash", normalisedSQLHashAttributeValue)
	dp.Attributes().PutStr("nr_service_guid", nrServiceGUIDAttributeValue)
	dp.Attributes().PutStr("newrelic.event.type", newrelicEventTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverSlowqueryQueryDetails) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverSlowqueryQueryDetails) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverSlowqueryQueryDetails(cfg MetricConfig) metricSqlserverSlowqueryQueryDetails {
	m := metricSqlserverSlowqueryQueryDetails{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsConnections struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.connections metric with initial data.
func (m *metricSqlserverStatsConnections) init() {
	m.data.SetName("sqlserver.stats.connections")
	m.data.SetDescription("Current user connections")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsConnections) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsConnections) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsConnections) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsConnections(cfg MetricConfig) metricSqlserverStatsConnections {
	m := metricSqlserverStatsConnections{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsDeadlocksPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.deadlocks_per_sec metric with initial data.
func (m *metricSqlserverStatsDeadlocksPerSec) init() {
	m.data.SetName("sqlserver.stats.deadlocks_per_sec")
	m.data.SetDescription("Deadlocks per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsDeadlocksPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsDeadlocksPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsDeadlocksPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsDeadlocksPerSec(cfg MetricConfig) metricSqlserverStatsDeadlocksPerSec {
	m := metricSqlserverStatsDeadlocksPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsKillConnectionErrorsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.kill_connection_errors_per_sec metric with initial data.
func (m *metricSqlserverStatsKillConnectionErrorsPerSec) init() {
	m.data.SetName("sqlserver.stats.kill_connection_errors_per_sec")
	m.data.SetDescription("Kill connection errors per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsKillConnectionErrorsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsKillConnectionErrorsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsKillConnectionErrorsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsKillConnectionErrorsPerSec(cfg MetricConfig) metricSqlserverStatsKillConnectionErrorsPerSec {
	m := metricSqlserverStatsKillConnectionErrorsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsLockWaitsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.lock_waits_per_sec metric with initial data.
func (m *metricSqlserverStatsLockWaitsPerSec) init() {
	m.data.SetName("sqlserver.stats.lock_waits_per_sec")
	m.data.SetDescription("Lock waits per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsLockWaitsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsLockWaitsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsLockWaitsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsLockWaitsPerSec(cfg MetricConfig) metricSqlserverStatsLockWaitsPerSec {
	m := metricSqlserverStatsLockWaitsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsSQLCompilationsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.sql_compilations_per_sec metric with initial data.
func (m *metricSqlserverStatsSQLCompilationsPerSec) init() {
	m.data.SetName("sqlserver.stats.sql_compilations_per_sec")
	m.data.SetDescription("SQL compilations per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsSQLCompilationsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsSQLCompilationsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsSQLCompilationsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsSQLCompilationsPerSec(cfg MetricConfig) metricSqlserverStatsSQLCompilationsPerSec {
	m := metricSqlserverStatsSQLCompilationsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsSQLRecompilationsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.sql_recompilations_per_sec metric with initial data.
func (m *metricSqlserverStatsSQLRecompilationsPerSec) init() {
	m.data.SetName("sqlserver.stats.sql_recompilations_per_sec")
	m.data.SetDescription("SQL recompilations per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsSQLRecompilationsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsSQLRecompilationsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsSQLRecompilationsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsSQLRecompilationsPerSec(cfg MetricConfig) metricSqlserverStatsSQLRecompilationsPerSec {
	m := metricSqlserverStatsSQLRecompilationsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverStatsUserErrorsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.stats.user_errors_per_sec metric with initial data.
func (m *metricSqlserverStatsUserErrorsPerSec) init() {
	m.data.SetName("sqlserver.stats.user_errors_per_sec")
	m.data.SetDescription("User errors per second")
	m.data.SetUnit("1/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverStatsUserErrorsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverStatsUserErrorsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverStatsUserErrorsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverStatsUserErrorsPerSec(cfg MetricConfig) metricSqlserverStatsUserErrorsPerSec {
	m := metricSqlserverStatsUserErrorsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbAllocationWaitsMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.allocation_waits_ms metric with initial data.
func (m *metricSqlserverTempdbAllocationWaitsMs) init() {
	m.data.SetName("sqlserver.tempdb.allocation_waits_ms")
	m.data.SetDescription("Total allocation-related wait time (GAM, SGAM, PFS)")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverTempdbAllocationWaitsMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("tempdb_health_status", tempdbHealthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbAllocationWaitsMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbAllocationWaitsMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbAllocationWaitsMs(cfg MetricConfig) metricSqlserverTempdbAllocationWaitsMs {
	m := metricSqlserverTempdbAllocationWaitsMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbCurrentWaiters struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.current_waiters metric with initial data.
func (m *metricSqlserverTempdbCurrentWaiters) init() {
	m.data.SetName("sqlserver.tempdb.current_waiters")
	m.data.SetDescription("Number of tasks currently waiting on TempDB page latches")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverTempdbCurrentWaiters) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("tempdb_health_status", tempdbHealthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbCurrentWaiters) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbCurrentWaiters) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbCurrentWaiters(cfg MetricConfig) metricSqlserverTempdbCurrentWaiters {
	m := metricSqlserverTempdbCurrentWaiters{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbDataFileCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.data_file_count metric with initial data.
func (m *metricSqlserverTempdbDataFileCount) init() {
	m.data.SetName("sqlserver.tempdb.data_file_count")
	m.data.SetDescription("Number of TempDB data files")
	m.data.SetUnit("{files}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverTempdbDataFileCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("tempdb_health_status", tempdbHealthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbDataFileCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbDataFileCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbDataFileCount(cfg MetricConfig) metricSqlserverTempdbDataFileCount {
	m := metricSqlserverTempdbDataFileCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbPagelatchWaitsMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.pagelatch_waits_ms metric with initial data.
func (m *metricSqlserverTempdbPagelatchWaitsMs) init() {
	m.data.SetName("sqlserver.tempdb.pagelatch_waits_ms")
	m.data.SetDescription("Total page latch wait time since server start")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverTempdbPagelatchWaitsMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("tempdb_health_status", tempdbHealthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbPagelatchWaitsMs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbPagelatchWaitsMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbPagelatchWaitsMs(cfg MetricConfig) metricSqlserverTempdbPagelatchWaitsMs {
	m := metricSqlserverTempdbPagelatchWaitsMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTempdbTotalSizeMb struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.tempdb.total_size_mb metric with initial data.
func (m *metricSqlserverTempdbTotalSizeMb) init() {
	m.data.SetName("sqlserver.tempdb.total_size_mb")
	m.data.SetDescription("Total size of TempDB data files")
	m.data.SetUnit("MB")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverTempdbTotalSizeMb) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("tempdb_health_status", tempdbHealthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTempdbTotalSizeMb) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTempdbTotalSizeMb) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTempdbTotalSizeMb(cfg MetricConfig) metricSqlserverTempdbTotalSizeMb {
	m := metricSqlserverTempdbTotalSizeMb{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolCurrentTasks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.current_tasks metric with initial data.
func (m *metricSqlserverThreadpoolCurrentTasks) init() {
	m.data.SetName("sqlserver.threadpool.current_tasks")
	m.data.SetDescription("Total tasks currently assigned to schedulers")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolCurrentTasks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolCurrentTasks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolCurrentTasks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolCurrentTasks(cfg MetricConfig) metricSqlserverThreadpoolCurrentTasks {
	m := metricSqlserverThreadpoolCurrentTasks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolMaxWorkers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.max_workers metric with initial data.
func (m *metricSqlserverThreadpoolMaxWorkers) init() {
	m.data.SetName("sqlserver.threadpool.max_workers")
	m.data.SetDescription("Maximum configured worker threads")
	m.data.SetUnit("{threads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolMaxWorkers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolMaxWorkers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolMaxWorkers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolMaxWorkers(cfg MetricConfig) metricSqlserverThreadpoolMaxWorkers {
	m := metricSqlserverThreadpoolMaxWorkers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolRunnableTasks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.runnable_tasks metric with initial data.
func (m *metricSqlserverThreadpoolRunnableTasks) init() {
	m.data.SetName("sqlserver.threadpool.runnable_tasks")
	m.data.SetDescription("Tasks ready to run but waiting for CPU time")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolRunnableTasks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolRunnableTasks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolRunnableTasks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolRunnableTasks(cfg MetricConfig) metricSqlserverThreadpoolRunnableTasks {
	m := metricSqlserverThreadpoolRunnableTasks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolRunningWorkers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.running_workers metric with initial data.
func (m *metricSqlserverThreadpoolRunningWorkers) init() {
	m.data.SetName("sqlserver.threadpool.running_workers")
	m.data.SetDescription("Number of worker threads currently running")
	m.data.SetUnit("{threads}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolRunningWorkers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolRunningWorkers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolRunningWorkers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolRunningWorkers(cfg MetricConfig) metricSqlserverThreadpoolRunningWorkers {
	m := metricSqlserverThreadpoolRunningWorkers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolUtilizationPercent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.utilization_percent metric with initial data.
func (m *metricSqlserverThreadpoolUtilizationPercent) init() {
	m.data.SetName("sqlserver.threadpool.utilization_percent")
	m.data.SetDescription("Percentage of worker threads currently in use")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolUtilizationPercent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolUtilizationPercent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolUtilizationPercent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolUtilizationPercent(cfg MetricConfig) metricSqlserverThreadpoolUtilizationPercent {
	m := metricSqlserverThreadpoolUtilizationPercent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolWaitingTasks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.waiting_tasks metric with initial data.
func (m *metricSqlserverThreadpoolWaitingTasks) init() {
	m.data.SetName("sqlserver.threadpool.waiting_tasks")
	m.data.SetDescription("Number of tasks currently waiting for threadpool worker threads")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolWaitingTasks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolWaitingTasks) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolWaitingTasks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolWaitingTasks(cfg MetricConfig) metricSqlserverThreadpoolWaitingTasks {
	m := metricSqlserverThreadpoolWaitingTasks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverThreadpoolWorkQueueCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.threadpool.work_queue_count metric with initial data.
func (m *metricSqlserverThreadpoolWorkQueueCount) init() {
	m.data.SetName("sqlserver.threadpool.work_queue_count")
	m.data.SetDescription("Total number of tasks in scheduler work queues")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverThreadpoolWorkQueueCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("sql_hostname", sqlHostnameAttributeValue)
	dp.Attributes().PutStr("health_status", healthStatusAttributeValue)
	dp.Attributes().PutStr("collection_timestamp", collectionTimestampAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverThreadpoolWorkQueueCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverThreadpoolWorkQueueCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverThreadpoolWorkQueueCount(cfg MetricConfig) metricSqlserverThreadpoolWorkQueueCount {
	m := metricSqlserverThreadpoolWorkQueueCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationChurnRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.churn_rate metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationChurnRate) init() {
	m.data.SetName("sqlserver.user_connections.authentication.churn_rate")
	m.data.SetDescription("Connection churn rate (logout/login ratio as percentage)")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationChurnRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationChurnRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationChurnRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationChurnRate(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationChurnRate {
	m := metricSqlserverUserConnectionsAuthenticationChurnRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationLoginsPerSec struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.logins_per_sec metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationLoginsPerSec) init() {
	m.data.SetName("sqlserver.user_connections.authentication.logins_per_sec")
	m.data.SetDescription("Current login rate per second")
	m.data.SetUnit("{logins}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationLoginsPerSec) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationLoginsPerSec) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationLoginsPerSec) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationLoginsPerSec(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationLoginsPerSec {
	m := metricSqlserverUserConnectionsAuthenticationLoginsPerSec{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationRecentFailedLogins struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.recent_failed_logins metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationRecentFailedLogins) init() {
	m.data.SetName("sqlserver.user_connections.authentication.recent_failed_logins")
	m.data.SetDescription("Count of failed logins in the last hour")
	m.data.SetUnit("{attempts}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationRecentFailedLogins) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationRecentFailedLogins) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationRecentFailedLogins) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationRecentFailedLogins(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationRecentFailedLogins {
	m := metricSqlserverUserConnectionsAuthenticationRecentFailedLogins{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationTotalFailedLogins struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.total_failed_logins metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationTotalFailedLogins) init() {
	m.data.SetName("sqlserver.user_connections.authentication.total_failed_logins")
	m.data.SetDescription("Total count of failed login attempts in current error log")
	m.data.SetUnit("{attempts}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationTotalFailedLogins) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationTotalFailedLogins) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationTotalFailedLogins) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationTotalFailedLogins(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationTotalFailedLogins {
	m := metricSqlserverUserConnectionsAuthenticationTotalFailedLogins{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationUniqueFailedSources struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.unique_failed_sources metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedSources) init() {
	m.data.SetName("sqlserver.user_connections.authentication.unique_failed_sources")
	m.data.SetDescription("Count of distinct source IPs with failed logins")
	m.data.SetUnit("{sources}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedSources) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedSources) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedSources) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationUniqueFailedSources(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationUniqueFailedSources {
	m := metricSqlserverUserConnectionsAuthenticationUniqueFailedSources{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.authentication.unique_failed_users metric with initial data.
func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers) init() {
	m.data.SetName("sqlserver.user_connections.authentication.unique_failed_users")
	m.data.SetDescription("Count of distinct usernames with failed logins")
	m.data.SetUnit("{users}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsAuthenticationUniqueFailedUsers(cfg MetricConfig) metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers {
	m := metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsClientCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.client.count metric with initial data.
func (m *metricSqlserverUserConnectionsClientCount) init() {
	m.data.SetName("sqlserver.user_connections.client.count")
	m.data.SetDescription("Number of connections grouped by client host and program")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverUserConnectionsClientCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostNameAttributeValue string, programNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("host_name", hostNameAttributeValue)
	dp.Attributes().PutStr("program_name", programNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsClientCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsClientCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsClientCount(cfg MetricConfig) metricSqlserverUserConnectionsClientCount {
	m := metricSqlserverUserConnectionsClientCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsClientUniqueHosts struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.client.unique_hosts metric with initial data.
func (m *metricSqlserverUserConnectionsClientUniqueHosts) init() {
	m.data.SetName("sqlserver.user_connections.client.unique_hosts")
	m.data.SetDescription("Count of unique client hosts with active connections")
	m.data.SetUnit("{hosts}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsClientUniqueHosts) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsClientUniqueHosts) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsClientUniqueHosts) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsClientUniqueHosts(cfg MetricConfig) metricSqlserverUserConnectionsClientUniqueHosts {
	m := metricSqlserverUserConnectionsClientUniqueHosts{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsClientUniquePrograms struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.client.unique_programs metric with initial data.
func (m *metricSqlserverUserConnectionsClientUniquePrograms) init() {
	m.data.SetName("sqlserver.user_connections.client.unique_programs")
	m.data.SetDescription("Count of unique programs with active connections")
	m.data.SetUnit("{programs}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsClientUniquePrograms) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsClientUniquePrograms) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsClientUniquePrograms) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsClientUniquePrograms(cfg MetricConfig) metricSqlserverUserConnectionsClientUniquePrograms {
	m := metricSqlserverUserConnectionsClientUniquePrograms{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsRunnable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.runnable metric with initial data.
func (m *metricSqlserverUserConnectionsRunnable) init() {
	m.data.SetName("sqlserver.user_connections.runnable")
	m.data.SetDescription("Number of runnable user connections")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsRunnable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsRunnable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsRunnable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsRunnable(cfg MetricConfig) metricSqlserverUserConnectionsRunnable {
	m := metricSqlserverUserConnectionsRunnable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsRunning struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.running metric with initial data.
func (m *metricSqlserverUserConnectionsRunning) init() {
	m.data.SetName("sqlserver.user_connections.running")
	m.data.SetDescription("Number of running user connections")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsRunning) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsRunning) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsRunning) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsRunning(cfg MetricConfig) metricSqlserverUserConnectionsRunning {
	m := metricSqlserverUserConnectionsRunning{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsSleeping struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.sleeping metric with initial data.
func (m *metricSqlserverUserConnectionsSleeping) init() {
	m.data.SetName("sqlserver.user_connections.sleeping")
	m.data.SetDescription("Number of sleeping user connections")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsSleeping) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsSleeping) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsSleeping) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsSleeping(cfg MetricConfig) metricSqlserverUserConnectionsSleeping {
	m := metricSqlserverUserConnectionsSleeping{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsSuspended struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.suspended metric with initial data.
func (m *metricSqlserverUserConnectionsSuspended) init() {
	m.data.SetName("sqlserver.user_connections.suspended")
	m.data.SetDescription("Number of suspended user connections")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsSuspended) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsSuspended) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsSuspended) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsSuspended(cfg MetricConfig) metricSqlserverUserConnectionsSuspended {
	m := metricSqlserverUserConnectionsSuspended{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.total metric with initial data.
func (m *metricSqlserverUserConnectionsTotal) init() {
	m.data.SetName("sqlserver.user_connections.total")
	m.data.SetDescription("Total number of user connections across all statuses")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsTotal) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsTotal(cfg MetricConfig) metricSqlserverUserConnectionsTotal {
	m := metricSqlserverUserConnectionsTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsUtilizationActiveRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.utilization.active_ratio metric with initial data.
func (m *metricSqlserverUserConnectionsUtilizationActiveRatio) init() {
	m.data.SetName("sqlserver.user_connections.utilization.active_ratio")
	m.data.SetDescription("Ratio of active connections to total connections")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsUtilizationActiveRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsUtilizationActiveRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsUtilizationActiveRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsUtilizationActiveRatio(cfg MetricConfig) metricSqlserverUserConnectionsUtilizationActiveRatio {
	m := metricSqlserverUserConnectionsUtilizationActiveRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionsUtilizationIdleRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user_connections.utilization.idle_ratio metric with initial data.
func (m *metricSqlserverUserConnectionsUtilizationIdleRatio) init() {
	m.data.SetName("sqlserver.user_connections.utilization.idle_ratio")
	m.data.SetDescription("Ratio of idle connections to total connections")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionsUtilizationIdleRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionsUtilizationIdleRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionsUtilizationIdleRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionsUtilizationIdleRatio(cfg MetricConfig) metricSqlserverUserConnectionsUtilizationIdleRatio {
	m := metricSqlserverUserConnectionsUtilizationIdleRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverWaitStatsLatchWaitTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.wait_stats.latch.wait_time_ms metric with initial data.
func (m *metricSqlserverWaitStatsLatchWaitTimeMs) init() {
	m.data.SetName("sqlserver.wait_stats.latch.wait_time_ms")
	m.data.SetDescription("Latch wait time in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverWaitStatsLatchWaitTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverWaitStatsLatchWaitTimeMs) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverWaitStatsLatchWaitTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverWaitStatsLatchWaitTimeMs(cfg MetricConfig) metricSqlserverWaitStatsLatchWaitTimeMs {
	m := metricSqlserverWaitStatsLatchWaitTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverWaitStatsLatchWaitingTasksCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.wait_stats.latch.waiting_tasks_count metric with initial data.
func (m *metricSqlserverWaitStatsLatchWaitingTasksCount) init() {
	m.data.SetName("sqlserver.wait_stats.latch.waiting_tasks_count")
	m.data.SetDescription("Number of tasks waiting on latches")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverWaitStatsLatchWaitingTasksCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverWaitStatsLatchWaitingTasksCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverWaitStatsLatchWaitingTasksCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverWaitStatsLatchWaitingTasksCount(cfg MetricConfig) metricSqlserverWaitStatsLatchWaitingTasksCount {
	m := metricSqlserverWaitStatsLatchWaitingTasksCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverWaitStatsWaitTimeMs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.wait_stats.wait_time_ms metric with initial data.
func (m *metricSqlserverWaitStatsWaitTimeMs) init() {
	m.data.SetName("sqlserver.wait_stats.wait_time_ms")
	m.data.SetDescription("Total wait time in milliseconds")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverWaitStatsWaitTimeMs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverWaitStatsWaitTimeMs) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverWaitStatsWaitTimeMs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverWaitStatsWaitTimeMs(cfg MetricConfig) metricSqlserverWaitStatsWaitTimeMs {
	m := metricSqlserverWaitStatsWaitTimeMs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverWaitStatsWaitingTasksCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.wait_stats.waiting_tasks_count metric with initial data.
func (m *metricSqlserverWaitStatsWaitingTasksCount) init() {
	m.data.SetName("sqlserver.wait_stats.waiting_tasks_count")
	m.data.SetDescription("Number of tasks currently waiting")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverWaitStatsWaitingTasksCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("wait_type", waitTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverWaitStatsWaitingTasksCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverWaitStatsWaitingTasksCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverWaitStatsWaitingTasksCount(cfg MetricConfig) metricSqlserverWaitStatsWaitingTasksCount {
	m := metricSqlserverWaitStatsWaitingTasksCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                                                          MetricsBuilderConfig // config of the metrics builder.
	startTime                                                       pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                                                 int                  // maximum observed number of metrics per resource.
	metricsBuffer                                                   pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                                                       component.BuildInfo  // contains version information.
	resourceAttributeIncludeFilter                                  map[string]filter.Filter
	resourceAttributeExcludeFilter                                  map[string]filter.Filter
	metricSqlserverAccessPageSplitsPerSec                           metricSqlserverAccessPageSplitsPerSec
	metricSqlserverActivequeryWaitTimeSeconds                       metricSqlserverActivequeryWaitTimeSeconds
	metricSqlserverBlockingQueryDetails                             metricSqlserverBlockingQueryDetails
	metricSqlserverBufferCacheHitRatio                              metricSqlserverBufferCacheHitRatio
	metricSqlserverBufferCheckpointPagesPerSec                      metricSqlserverBufferCheckpointPagesPerSec
	metricSqlserverBufferPageLifeExpectancy                         metricSqlserverBufferPageLifeExpectancy
	metricSqlserverBufferpoolBatchRequestsPerSec                    metricSqlserverBufferpoolBatchRequestsPerSec
	metricSqlserverBufferpoolPageLifeExpectancyMs                   metricSqlserverBufferpoolPageLifeExpectancyMs
	metricSqlserverConnectionsUser                                  metricSqlserverConnectionsUser
	metricSqlserverDatabaseBufferpoolSizePerDatabaseBytes           metricSqlserverDatabaseBufferpoolSizePerDatabaseBytes
	metricSqlserverDatabaseIoStallMs                                metricSqlserverDatabaseIoStallMs
	metricSqlserverDatabaseLogBytesFlushedPerSec                    metricSqlserverDatabaseLogBytesFlushedPerSec
	metricSqlserverDatabaseLogFlushWaitsPerSec                      metricSqlserverDatabaseLogFlushWaitsPerSec
	metricSqlserverDatabaseLogFlushesPerSec                         metricSqlserverDatabaseLogFlushesPerSec
	metricSqlserverDatabaseLogTransactionGrowth                     metricSqlserverDatabaseLogTransactionGrowth
	metricSqlserverDatabaseLogUsedSpaceMb                           metricSqlserverDatabaseLogUsedSpaceMb
	metricSqlserverDatabaseMaxDiskSizeBytes                         metricSqlserverDatabaseMaxDiskSizeBytes
	metricSqlserverDatabasePageFileAvailableBytes                   metricSqlserverDatabasePageFileAvailableBytes
	metricSqlserverDatabasePageFileTotalBytes                       metricSqlserverDatabasePageFileTotalBytes
	metricSqlserverDatabasePrincipalsApplicationRoles               metricSqlserverDatabasePrincipalsApplicationRoles
	metricSqlserverDatabasePrincipalsOld                            metricSqlserverDatabasePrincipalsOld
	metricSqlserverDatabasePrincipalsOrphanedUsers                  metricSqlserverDatabasePrincipalsOrphanedUsers
	metricSqlserverDatabasePrincipalsRecentlyCreated                metricSqlserverDatabasePrincipalsRecentlyCreated
	metricSqlserverDatabasePrincipalsRoles                          metricSqlserverDatabasePrincipalsRoles
	metricSqlserverDatabasePrincipalsSQLUsers                       metricSqlserverDatabasePrincipalsSQLUsers
	metricSqlserverDatabasePrincipalsTotal                          metricSqlserverDatabasePrincipalsTotal
	metricSqlserverDatabasePrincipalsUsers                          metricSqlserverDatabasePrincipalsUsers
	metricSqlserverDatabasePrincipalsWindowsUsers                   metricSqlserverDatabasePrincipalsWindowsUsers
	metricSqlserverDatabaseRoleMembersApplicationRoles              metricSqlserverDatabaseRoleMembersApplicationRoles
	metricSqlserverDatabaseRoleMembersCrossRole                     metricSqlserverDatabaseRoleMembersCrossRole
	metricSqlserverDatabaseRoleMembersHighPrivilege                 metricSqlserverDatabaseRoleMembersHighPrivilege
	metricSqlserverDatabaseRoleMembersUnique                        metricSqlserverDatabaseRoleMembersUnique
	metricSqlserverDatabaseRoleMembershipsActive                    metricSqlserverDatabaseRoleMembershipsActive
	metricSqlserverDatabaseRoleMembershipsCustom                    metricSqlserverDatabaseRoleMembershipsCustom
	metricSqlserverDatabaseRoleMembershipsNested                    metricSqlserverDatabaseRoleMembershipsNested
	metricSqlserverDatabaseRoleMembershipsTotal                     metricSqlserverDatabaseRoleMembershipsTotal
	metricSqlserverDatabaseRoleMembershipsUsers                     metricSqlserverDatabaseRoleMembershipsUsers
	metricSqlserverDatabaseRolePermissionMemberCount                metricSqlserverDatabaseRolePermissionMemberCount
	metricSqlserverDatabaseRolePermissionRiskLevel                  metricSqlserverDatabaseRolePermissionRiskLevel
	metricSqlserverDatabaseRoleRolesEmpty                           metricSqlserverDatabaseRoleRolesEmpty
	metricSqlserverDatabaseRoleRolesWithMembers                     metricSqlserverDatabaseRoleRolesWithMembers
	metricSqlserverDatabaseSizeDataMb                               metricSqlserverDatabaseSizeDataMb
	metricSqlserverDatabaseSizeTotalMb                              metricSqlserverDatabaseSizeTotalMb
	metricSqlserverDatabaseTransactionsActive                       metricSqlserverDatabaseTransactionsActive
	metricSqlserverExecutionPlan                                    metricSqlserverExecutionPlan
	metricSqlserverFailoverClusterAgClusterType                     metricSqlserverFailoverClusterAgClusterType
	metricSqlserverFailoverClusterAgFailureConditionLevel           metricSqlserverFailoverClusterAgFailureConditionLevel
	metricSqlserverFailoverClusterAgHealthCheckTimeout              metricSqlserverFailoverClusterAgHealthCheckTimeout
	metricSqlserverFailoverClusterAgReplicaRole                     metricSqlserverFailoverClusterAgReplicaRole
	metricSqlserverFailoverClusterAgRequiredSyncSecondaries         metricSqlserverFailoverClusterAgRequiredSyncSecondaries
	metricSqlserverFailoverClusterAgSynchronizationHealth           metricSqlserverFailoverClusterAgSynchronizationHealth
	metricSqlserverFailoverClusterFlowControlTimeMs                 metricSqlserverFailoverClusterFlowControlTimeMs
	metricSqlserverFailoverClusterLogBytesReceivedPerSec            metricSqlserverFailoverClusterLogBytesReceivedPerSec
	metricSqlserverFailoverClusterLogSendQueueKb                    metricSqlserverFailoverClusterLogSendQueueKb
	metricSqlserverFailoverClusterRedoQueueKb                       metricSqlserverFailoverClusterRedoQueueKb
	metricSqlserverFailoverClusterRedoRateKbSec                     metricSqlserverFailoverClusterRedoRateKbSec
	metricSqlserverFailoverClusterTransactionDelayMs                metricSqlserverFailoverClusterTransactionDelayMs
	metricSqlserverIndividualQueryTotalCPUMs                        metricSqlserverIndividualQueryTotalCPUMs
	metricSqlserverIndividualQueryTotalElapsedMs                    metricSqlserverIndividualQueryTotalElapsedMs
	metricSqlserverInstanceBackgroundProcessesCount                 metricSqlserverInstanceBackgroundProcessesCount
	metricSqlserverInstanceBlockedProcessesCount                    metricSqlserverInstanceBlockedProcessesCount
	metricSqlserverInstanceBufferPoolHitPercent                     metricSqlserverInstanceBufferPoolHitPercent
	metricSqlserverInstanceBufferPoolSize                           metricSqlserverInstanceBufferPoolSize
	metricSqlserverInstanceCompilationsPerBatch                     metricSqlserverInstanceCompilationsPerBatch
	metricSqlserverInstanceConnectionsActive                        metricSqlserverInstanceConnectionsActive
	metricSqlserverInstanceDiskInBytes                              metricSqlserverInstanceDiskInBytes
	metricSqlserverInstanceDormantProcessesCount                    metricSqlserverInstanceDormantProcessesCount
	metricSqlserverInstanceForcedParameterizationsPerSec            metricSqlserverInstanceForcedParameterizationsPerSec
	metricSqlserverInstanceFullScansRate                            metricSqlserverInstanceFullScansRate
	metricSqlserverInstanceLockTimeoutsRate                         metricSqlserverInstanceLockTimeoutsRate
	metricSqlserverInstanceMemoryAvailable                          metricSqlserverInstanceMemoryAvailable
	metricSqlserverInstanceMemoryTotal                              metricSqlserverInstanceMemoryTotal
	metricSqlserverInstanceMemoryUtilizationPercent                 metricSqlserverInstanceMemoryUtilizationPercent
	metricSqlserverInstancePageSplitsPerBatch                       metricSqlserverInstancePageSplitsPerBatch
	metricSqlserverInstancePreconnectProcessesCount                 metricSqlserverInstancePreconnectProcessesCount
	metricSqlserverInstanceRunnableProcessesCount                   metricSqlserverInstanceRunnableProcessesCount
	metricSqlserverInstanceRunnableTasks                            metricSqlserverInstanceRunnableTasks
	metricSqlserverInstanceRunningProcessesCount                    metricSqlserverInstanceRunningProcessesCount
	metricSqlserverInstanceSleepingProcessesCount                   metricSqlserverInstanceSleepingProcessesCount
	metricSqlserverInstanceSuspendedProcessesCount                  metricSqlserverInstanceSuspendedProcessesCount
	metricSqlserverInstanceTargetMemoryKb                           metricSqlserverInstanceTargetMemoryKb
	metricSqlserverInstanceTransactionsPerSec                       metricSqlserverInstanceTransactionsPerSec
	metricSqlserverLockModeBulkUpdate                               metricSqlserverLockModeBulkUpdate
	metricSqlserverLockModeExclusive                                metricSqlserverLockModeExclusive
	metricSqlserverLockModeIntent                                   metricSqlserverLockModeIntent
	metricSqlserverLockModeSchema                                   metricSqlserverLockModeSchema
	metricSqlserverLockModeShared                                   metricSqlserverLockModeShared
	metricSqlserverLockModeSharedIntentExclusive                    metricSqlserverLockModeSharedIntentExclusive
	metricSqlserverLockModeTotal                                    metricSqlserverLockModeTotal
	metricSqlserverLockModeUpdate                                   metricSqlserverLockModeUpdate
	metricSqlserverLockResourceAllocationUnit                       metricSqlserverLockResourceAllocationUnit
	metricSqlserverLockResourceApplication                          metricSqlserverLockResourceApplication
	metricSqlserverLockResourceDatabaseLevel                        metricSqlserverLockResourceDatabaseLevel
	metricSqlserverLockResourceExtent                               metricSqlserverLockResourceExtent
	metricSqlserverLockResourceFile                                 metricSqlserverLockResourceFile
	metricSqlserverLockResourceHobt                                 metricSqlserverLockResourceHobt
	metricSqlserverLockResourceKey                                  metricSqlserverLockResourceKey
	metricSqlserverLockResourceMetadata                             metricSqlserverLockResourceMetadata
	metricSqlserverLockResourcePage                                 metricSqlserverLockResourcePage
	metricSqlserverLockResourceRow                                  metricSqlserverLockResourceRow
	metricSqlserverLockResourceTable                                metricSqlserverLockResourceTable
	metricSqlserverLockResourceTotal                                metricSqlserverLockResourceTotal
	metricSqlserverLockedObject                                     metricSqlserverLockedObject
	metricSqlserverMemoryTarget                                     metricSqlserverMemoryTarget
	metricSqlserverMemoryTotal                                      metricSqlserverMemoryTotal
	metricSqlserverPlanAvgElapsedTimeMs                             metricSqlserverPlanAvgElapsedTimeMs
	metricSqlserverSecurityServerPrincipalsCount                    metricSqlserverSecurityServerPrincipalsCount
	metricSqlserverSecurityServerRoleMembersCount                   metricSqlserverSecurityServerRoleMembersCount
	metricSqlserverSlowqueryAvgElapsedTimeMs                        metricSqlserverSlowqueryAvgElapsedTimeMs
	metricSqlserverSlowqueryHistoricalExecutionCount                metricSqlserverSlowqueryHistoricalExecutionCount
	metricSqlserverSlowqueryHistoricalLogicalReads                  metricSqlserverSlowqueryHistoricalLogicalReads
	metricSqlserverSlowqueryHistoricalPhysicalReads                 metricSqlserverSlowqueryHistoricalPhysicalReads
	metricSqlserverSlowqueryHistoricalRows                          metricSqlserverSlowqueryHistoricalRows
	metricSqlserverSlowqueryHistoricalWaitTimeMs                    metricSqlserverSlowqueryHistoricalWaitTimeMs
	metricSqlserverSlowqueryHistoricalWorkerTimeMs                  metricSqlserverSlowqueryHistoricalWorkerTimeMs
	metricSqlserverSlowqueryIntervalAvgElapsedTimeMs                metricSqlserverSlowqueryIntervalAvgElapsedTimeMs
	metricSqlserverSlowqueryIntervalAvgLogicalReads                 metricSqlserverSlowqueryIntervalAvgLogicalReads
	metricSqlserverSlowqueryIntervalAvgPhysicalReads                metricSqlserverSlowqueryIntervalAvgPhysicalReads
	metricSqlserverSlowqueryIntervalAvgRows                         metricSqlserverSlowqueryIntervalAvgRows
	metricSqlserverSlowqueryIntervalAvgWaitTimeMs                   metricSqlserverSlowqueryIntervalAvgWaitTimeMs
	metricSqlserverSlowqueryIntervalAvgWorkerTimeMs                 metricSqlserverSlowqueryIntervalAvgWorkerTimeMs
	metricSqlserverSlowqueryIntervalElapsedTimeMs                   metricSqlserverSlowqueryIntervalElapsedTimeMs
	metricSqlserverSlowqueryIntervalExecutionCount                  metricSqlserverSlowqueryIntervalExecutionCount
	metricSqlserverSlowqueryIntervalLogicalReads                    metricSqlserverSlowqueryIntervalLogicalReads
	metricSqlserverSlowqueryIntervalPhysicalReads                   metricSqlserverSlowqueryIntervalPhysicalReads
	metricSqlserverSlowqueryIntervalRows                            metricSqlserverSlowqueryIntervalRows
	metricSqlserverSlowqueryIntervalWaitTimeMs                      metricSqlserverSlowqueryIntervalWaitTimeMs
	metricSqlserverSlowqueryIntervalWorkerTimeMs                    metricSqlserverSlowqueryIntervalWorkerTimeMs
	metricSqlserverSlowqueryQueryDetails                            metricSqlserverSlowqueryQueryDetails
	metricSqlserverStatsConnections                                 metricSqlserverStatsConnections
	metricSqlserverStatsDeadlocksPerSec                             metricSqlserverStatsDeadlocksPerSec
	metricSqlserverStatsKillConnectionErrorsPerSec                  metricSqlserverStatsKillConnectionErrorsPerSec
	metricSqlserverStatsLockWaitsPerSec                             metricSqlserverStatsLockWaitsPerSec
	metricSqlserverStatsSQLCompilationsPerSec                       metricSqlserverStatsSQLCompilationsPerSec
	metricSqlserverStatsSQLRecompilationsPerSec                     metricSqlserverStatsSQLRecompilationsPerSec
	metricSqlserverStatsUserErrorsPerSec                            metricSqlserverStatsUserErrorsPerSec
	metricSqlserverTempdbAllocationWaitsMs                          metricSqlserverTempdbAllocationWaitsMs
	metricSqlserverTempdbCurrentWaiters                             metricSqlserverTempdbCurrentWaiters
	metricSqlserverTempdbDataFileCount                              metricSqlserverTempdbDataFileCount
	metricSqlserverTempdbPagelatchWaitsMs                           metricSqlserverTempdbPagelatchWaitsMs
	metricSqlserverTempdbTotalSizeMb                                metricSqlserverTempdbTotalSizeMb
	metricSqlserverThreadpoolCurrentTasks                           metricSqlserverThreadpoolCurrentTasks
	metricSqlserverThreadpoolMaxWorkers                             metricSqlserverThreadpoolMaxWorkers
	metricSqlserverThreadpoolRunnableTasks                          metricSqlserverThreadpoolRunnableTasks
	metricSqlserverThreadpoolRunningWorkers                         metricSqlserverThreadpoolRunningWorkers
	metricSqlserverThreadpoolUtilizationPercent                     metricSqlserverThreadpoolUtilizationPercent
	metricSqlserverThreadpoolWaitingTasks                           metricSqlserverThreadpoolWaitingTasks
	metricSqlserverThreadpoolWorkQueueCount                         metricSqlserverThreadpoolWorkQueueCount
	metricSqlserverUserConnectionsAuthenticationChurnRate           metricSqlserverUserConnectionsAuthenticationChurnRate
	metricSqlserverUserConnectionsAuthenticationLoginsPerSec        metricSqlserverUserConnectionsAuthenticationLoginsPerSec
	metricSqlserverUserConnectionsAuthenticationRecentFailedLogins  metricSqlserverUserConnectionsAuthenticationRecentFailedLogins
	metricSqlserverUserConnectionsAuthenticationTotalFailedLogins   metricSqlserverUserConnectionsAuthenticationTotalFailedLogins
	metricSqlserverUserConnectionsAuthenticationUniqueFailedSources metricSqlserverUserConnectionsAuthenticationUniqueFailedSources
	metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers   metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers
	metricSqlserverUserConnectionsClientCount                       metricSqlserverUserConnectionsClientCount
	metricSqlserverUserConnectionsClientUniqueHosts                 metricSqlserverUserConnectionsClientUniqueHosts
	metricSqlserverUserConnectionsClientUniquePrograms              metricSqlserverUserConnectionsClientUniquePrograms
	metricSqlserverUserConnectionsRunnable                          metricSqlserverUserConnectionsRunnable
	metricSqlserverUserConnectionsRunning                           metricSqlserverUserConnectionsRunning
	metricSqlserverUserConnectionsSleeping                          metricSqlserverUserConnectionsSleeping
	metricSqlserverUserConnectionsSuspended                         metricSqlserverUserConnectionsSuspended
	metricSqlserverUserConnectionsTotal                             metricSqlserverUserConnectionsTotal
	metricSqlserverUserConnectionsUtilizationActiveRatio            metricSqlserverUserConnectionsUtilizationActiveRatio
	metricSqlserverUserConnectionsUtilizationIdleRatio              metricSqlserverUserConnectionsUtilizationIdleRatio
	metricSqlserverWaitStatsLatchWaitTimeMs                         metricSqlserverWaitStatsLatchWaitTimeMs
	metricSqlserverWaitStatsLatchWaitingTasksCount                  metricSqlserverWaitStatsLatchWaitingTasksCount
	metricSqlserverWaitStatsWaitTimeMs                              metricSqlserverWaitStatsWaitTimeMs
	metricSqlserverWaitStatsWaitingTasksCount                       metricSqlserverWaitStatsWaitingTasksCount
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}
func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:                                mbc,
		startTime:                             pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                         pmetric.NewMetrics(),
		buildInfo:                             settings.BuildInfo,
		metricSqlserverAccessPageSplitsPerSec: newMetricSqlserverAccessPageSplitsPerSec(mbc.Metrics.SqlserverAccessPageSplitsPerSec),
		metricSqlserverActivequeryWaitTimeSeconds:                       newMetricSqlserverActivequeryWaitTimeSeconds(mbc.Metrics.SqlserverActivequeryWaitTimeSeconds),
		metricSqlserverBlockingQueryDetails:                             newMetricSqlserverBlockingQueryDetails(mbc.Metrics.SqlserverBlockingQueryDetails),
		metricSqlserverBufferCacheHitRatio:                              newMetricSqlserverBufferCacheHitRatio(mbc.Metrics.SqlserverBufferCacheHitRatio),
		metricSqlserverBufferCheckpointPagesPerSec:                      newMetricSqlserverBufferCheckpointPagesPerSec(mbc.Metrics.SqlserverBufferCheckpointPagesPerSec),
		metricSqlserverBufferPageLifeExpectancy:                         newMetricSqlserverBufferPageLifeExpectancy(mbc.Metrics.SqlserverBufferPageLifeExpectancy),
		metricSqlserverBufferpoolBatchRequestsPerSec:                    newMetricSqlserverBufferpoolBatchRequestsPerSec(mbc.Metrics.SqlserverBufferpoolBatchRequestsPerSec),
		metricSqlserverBufferpoolPageLifeExpectancyMs:                   newMetricSqlserverBufferpoolPageLifeExpectancyMs(mbc.Metrics.SqlserverBufferpoolPageLifeExpectancyMs),
		metricSqlserverConnectionsUser:                                  newMetricSqlserverConnectionsUser(mbc.Metrics.SqlserverConnectionsUser),
		metricSqlserverDatabaseBufferpoolSizePerDatabaseBytes:           newMetricSqlserverDatabaseBufferpoolSizePerDatabaseBytes(mbc.Metrics.SqlserverDatabaseBufferpoolSizePerDatabaseBytes),
		metricSqlserverDatabaseIoStallMs:                                newMetricSqlserverDatabaseIoStallMs(mbc.Metrics.SqlserverDatabaseIoStallMs),
		metricSqlserverDatabaseLogBytesFlushedPerSec:                    newMetricSqlserverDatabaseLogBytesFlushedPerSec(mbc.Metrics.SqlserverDatabaseLogBytesFlushedPerSec),
		metricSqlserverDatabaseLogFlushWaitsPerSec:                      newMetricSqlserverDatabaseLogFlushWaitsPerSec(mbc.Metrics.SqlserverDatabaseLogFlushWaitsPerSec),
		metricSqlserverDatabaseLogFlushesPerSec:                         newMetricSqlserverDatabaseLogFlushesPerSec(mbc.Metrics.SqlserverDatabaseLogFlushesPerSec),
		metricSqlserverDatabaseLogTransactionGrowth:                     newMetricSqlserverDatabaseLogTransactionGrowth(mbc.Metrics.SqlserverDatabaseLogTransactionGrowth),
		metricSqlserverDatabaseLogUsedSpaceMb:                           newMetricSqlserverDatabaseLogUsedSpaceMb(mbc.Metrics.SqlserverDatabaseLogUsedSpaceMb),
		metricSqlserverDatabaseMaxDiskSizeBytes:                         newMetricSqlserverDatabaseMaxDiskSizeBytes(mbc.Metrics.SqlserverDatabaseMaxDiskSizeBytes),
		metricSqlserverDatabasePageFileAvailableBytes:                   newMetricSqlserverDatabasePageFileAvailableBytes(mbc.Metrics.SqlserverDatabasePageFileAvailableBytes),
		metricSqlserverDatabasePageFileTotalBytes:                       newMetricSqlserverDatabasePageFileTotalBytes(mbc.Metrics.SqlserverDatabasePageFileTotalBytes),
		metricSqlserverDatabasePrincipalsApplicationRoles:               newMetricSqlserverDatabasePrincipalsApplicationRoles(mbc.Metrics.SqlserverDatabasePrincipalsApplicationRoles),
		metricSqlserverDatabasePrincipalsOld:                            newMetricSqlserverDatabasePrincipalsOld(mbc.Metrics.SqlserverDatabasePrincipalsOld),
		metricSqlserverDatabasePrincipalsOrphanedUsers:                  newMetricSqlserverDatabasePrincipalsOrphanedUsers(mbc.Metrics.SqlserverDatabasePrincipalsOrphanedUsers),
		metricSqlserverDatabasePrincipalsRecentlyCreated:                newMetricSqlserverDatabasePrincipalsRecentlyCreated(mbc.Metrics.SqlserverDatabasePrincipalsRecentlyCreated),
		metricSqlserverDatabasePrincipalsRoles:                          newMetricSqlserverDatabasePrincipalsRoles(mbc.Metrics.SqlserverDatabasePrincipalsRoles),
		metricSqlserverDatabasePrincipalsSQLUsers:                       newMetricSqlserverDatabasePrincipalsSQLUsers(mbc.Metrics.SqlserverDatabasePrincipalsSQLUsers),
		metricSqlserverDatabasePrincipalsTotal:                          newMetricSqlserverDatabasePrincipalsTotal(mbc.Metrics.SqlserverDatabasePrincipalsTotal),
		metricSqlserverDatabasePrincipalsUsers:                          newMetricSqlserverDatabasePrincipalsUsers(mbc.Metrics.SqlserverDatabasePrincipalsUsers),
		metricSqlserverDatabasePrincipalsWindowsUsers:                   newMetricSqlserverDatabasePrincipalsWindowsUsers(mbc.Metrics.SqlserverDatabasePrincipalsWindowsUsers),
		metricSqlserverDatabaseRoleMembersApplicationRoles:              newMetricSqlserverDatabaseRoleMembersApplicationRoles(mbc.Metrics.SqlserverDatabaseRoleMembersApplicationRoles),
		metricSqlserverDatabaseRoleMembersCrossRole:                     newMetricSqlserverDatabaseRoleMembersCrossRole(mbc.Metrics.SqlserverDatabaseRoleMembersCrossRole),
		metricSqlserverDatabaseRoleMembersHighPrivilege:                 newMetricSqlserverDatabaseRoleMembersHighPrivilege(mbc.Metrics.SqlserverDatabaseRoleMembersHighPrivilege),
		metricSqlserverDatabaseRoleMembersUnique:                        newMetricSqlserverDatabaseRoleMembersUnique(mbc.Metrics.SqlserverDatabaseRoleMembersUnique),
		metricSqlserverDatabaseRoleMembershipsActive:                    newMetricSqlserverDatabaseRoleMembershipsActive(mbc.Metrics.SqlserverDatabaseRoleMembershipsActive),
		metricSqlserverDatabaseRoleMembershipsCustom:                    newMetricSqlserverDatabaseRoleMembershipsCustom(mbc.Metrics.SqlserverDatabaseRoleMembershipsCustom),
		metricSqlserverDatabaseRoleMembershipsNested:                    newMetricSqlserverDatabaseRoleMembershipsNested(mbc.Metrics.SqlserverDatabaseRoleMembershipsNested),
		metricSqlserverDatabaseRoleMembershipsTotal:                     newMetricSqlserverDatabaseRoleMembershipsTotal(mbc.Metrics.SqlserverDatabaseRoleMembershipsTotal),
		metricSqlserverDatabaseRoleMembershipsUsers:                     newMetricSqlserverDatabaseRoleMembershipsUsers(mbc.Metrics.SqlserverDatabaseRoleMembershipsUsers),
		metricSqlserverDatabaseRolePermissionMemberCount:                newMetricSqlserverDatabaseRolePermissionMemberCount(mbc.Metrics.SqlserverDatabaseRolePermissionMemberCount),
		metricSqlserverDatabaseRolePermissionRiskLevel:                  newMetricSqlserverDatabaseRolePermissionRiskLevel(mbc.Metrics.SqlserverDatabaseRolePermissionRiskLevel),
		metricSqlserverDatabaseRoleRolesEmpty:                           newMetricSqlserverDatabaseRoleRolesEmpty(mbc.Metrics.SqlserverDatabaseRoleRolesEmpty),
		metricSqlserverDatabaseRoleRolesWithMembers:                     newMetricSqlserverDatabaseRoleRolesWithMembers(mbc.Metrics.SqlserverDatabaseRoleRolesWithMembers),
		metricSqlserverDatabaseSizeDataMb:                               newMetricSqlserverDatabaseSizeDataMb(mbc.Metrics.SqlserverDatabaseSizeDataMb),
		metricSqlserverDatabaseSizeTotalMb:                              newMetricSqlserverDatabaseSizeTotalMb(mbc.Metrics.SqlserverDatabaseSizeTotalMb),
		metricSqlserverDatabaseTransactionsActive:                       newMetricSqlserverDatabaseTransactionsActive(mbc.Metrics.SqlserverDatabaseTransactionsActive),
		metricSqlserverExecutionPlan:                                    newMetricSqlserverExecutionPlan(mbc.Metrics.SqlserverExecutionPlan),
		metricSqlserverFailoverClusterAgClusterType:                     newMetricSqlserverFailoverClusterAgClusterType(mbc.Metrics.SqlserverFailoverClusterAgClusterType),
		metricSqlserverFailoverClusterAgFailureConditionLevel:           newMetricSqlserverFailoverClusterAgFailureConditionLevel(mbc.Metrics.SqlserverFailoverClusterAgFailureConditionLevel),
		metricSqlserverFailoverClusterAgHealthCheckTimeout:              newMetricSqlserverFailoverClusterAgHealthCheckTimeout(mbc.Metrics.SqlserverFailoverClusterAgHealthCheckTimeout),
		metricSqlserverFailoverClusterAgReplicaRole:                     newMetricSqlserverFailoverClusterAgReplicaRole(mbc.Metrics.SqlserverFailoverClusterAgReplicaRole),
		metricSqlserverFailoverClusterAgRequiredSyncSecondaries:         newMetricSqlserverFailoverClusterAgRequiredSyncSecondaries(mbc.Metrics.SqlserverFailoverClusterAgRequiredSyncSecondaries),
		metricSqlserverFailoverClusterAgSynchronizationHealth:           newMetricSqlserverFailoverClusterAgSynchronizationHealth(mbc.Metrics.SqlserverFailoverClusterAgSynchronizationHealth),
		metricSqlserverFailoverClusterFlowControlTimeMs:                 newMetricSqlserverFailoverClusterFlowControlTimeMs(mbc.Metrics.SqlserverFailoverClusterFlowControlTimeMs),
		metricSqlserverFailoverClusterLogBytesReceivedPerSec:            newMetricSqlserverFailoverClusterLogBytesReceivedPerSec(mbc.Metrics.SqlserverFailoverClusterLogBytesReceivedPerSec),
		metricSqlserverFailoverClusterLogSendQueueKb:                    newMetricSqlserverFailoverClusterLogSendQueueKb(mbc.Metrics.SqlserverFailoverClusterLogSendQueueKb),
		metricSqlserverFailoverClusterRedoQueueKb:                       newMetricSqlserverFailoverClusterRedoQueueKb(mbc.Metrics.SqlserverFailoverClusterRedoQueueKb),
		metricSqlserverFailoverClusterRedoRateKbSec:                     newMetricSqlserverFailoverClusterRedoRateKbSec(mbc.Metrics.SqlserverFailoverClusterRedoRateKbSec),
		metricSqlserverFailoverClusterTransactionDelayMs:                newMetricSqlserverFailoverClusterTransactionDelayMs(mbc.Metrics.SqlserverFailoverClusterTransactionDelayMs),
		metricSqlserverIndividualQueryTotalCPUMs:                        newMetricSqlserverIndividualQueryTotalCPUMs(mbc.Metrics.SqlserverIndividualQueryTotalCPUMs),
		metricSqlserverIndividualQueryTotalElapsedMs:                    newMetricSqlserverIndividualQueryTotalElapsedMs(mbc.Metrics.SqlserverIndividualQueryTotalElapsedMs),
		metricSqlserverInstanceBackgroundProcessesCount:                 newMetricSqlserverInstanceBackgroundProcessesCount(mbc.Metrics.SqlserverInstanceBackgroundProcessesCount),
		metricSqlserverInstanceBlockedProcessesCount:                    newMetricSqlserverInstanceBlockedProcessesCount(mbc.Metrics.SqlserverInstanceBlockedProcessesCount),
		metricSqlserverInstanceBufferPoolHitPercent:                     newMetricSqlserverInstanceBufferPoolHitPercent(mbc.Metrics.SqlserverInstanceBufferPoolHitPercent),
		metricSqlserverInstanceBufferPoolSize:                           newMetricSqlserverInstanceBufferPoolSize(mbc.Metrics.SqlserverInstanceBufferPoolSize),
		metricSqlserverInstanceCompilationsPerBatch:                     newMetricSqlserverInstanceCompilationsPerBatch(mbc.Metrics.SqlserverInstanceCompilationsPerBatch),
		metricSqlserverInstanceConnectionsActive:                        newMetricSqlserverInstanceConnectionsActive(mbc.Metrics.SqlserverInstanceConnectionsActive),
		metricSqlserverInstanceDiskInBytes:                              newMetricSqlserverInstanceDiskInBytes(mbc.Metrics.SqlserverInstanceDiskInBytes),
		metricSqlserverInstanceDormantProcessesCount:                    newMetricSqlserverInstanceDormantProcessesCount(mbc.Metrics.SqlserverInstanceDormantProcessesCount),
		metricSqlserverInstanceForcedParameterizationsPerSec:            newMetricSqlserverInstanceForcedParameterizationsPerSec(mbc.Metrics.SqlserverInstanceForcedParameterizationsPerSec),
		metricSqlserverInstanceFullScansRate:                            newMetricSqlserverInstanceFullScansRate(mbc.Metrics.SqlserverInstanceFullScansRate),
		metricSqlserverInstanceLockTimeoutsRate:                         newMetricSqlserverInstanceLockTimeoutsRate(mbc.Metrics.SqlserverInstanceLockTimeoutsRate),
		metricSqlserverInstanceMemoryAvailable:                          newMetricSqlserverInstanceMemoryAvailable(mbc.Metrics.SqlserverInstanceMemoryAvailable),
		metricSqlserverInstanceMemoryTotal:                              newMetricSqlserverInstanceMemoryTotal(mbc.Metrics.SqlserverInstanceMemoryTotal),
		metricSqlserverInstanceMemoryUtilizationPercent:                 newMetricSqlserverInstanceMemoryUtilizationPercent(mbc.Metrics.SqlserverInstanceMemoryUtilizationPercent),
		metricSqlserverInstancePageSplitsPerBatch:                       newMetricSqlserverInstancePageSplitsPerBatch(mbc.Metrics.SqlserverInstancePageSplitsPerBatch),
		metricSqlserverInstancePreconnectProcessesCount:                 newMetricSqlserverInstancePreconnectProcessesCount(mbc.Metrics.SqlserverInstancePreconnectProcessesCount),
		metricSqlserverInstanceRunnableProcessesCount:                   newMetricSqlserverInstanceRunnableProcessesCount(mbc.Metrics.SqlserverInstanceRunnableProcessesCount),
		metricSqlserverInstanceRunnableTasks:                            newMetricSqlserverInstanceRunnableTasks(mbc.Metrics.SqlserverInstanceRunnableTasks),
		metricSqlserverInstanceRunningProcessesCount:                    newMetricSqlserverInstanceRunningProcessesCount(mbc.Metrics.SqlserverInstanceRunningProcessesCount),
		metricSqlserverInstanceSleepingProcessesCount:                   newMetricSqlserverInstanceSleepingProcessesCount(mbc.Metrics.SqlserverInstanceSleepingProcessesCount),
		metricSqlserverInstanceSuspendedProcessesCount:                  newMetricSqlserverInstanceSuspendedProcessesCount(mbc.Metrics.SqlserverInstanceSuspendedProcessesCount),
		metricSqlserverInstanceTargetMemoryKb:                           newMetricSqlserverInstanceTargetMemoryKb(mbc.Metrics.SqlserverInstanceTargetMemoryKb),
		metricSqlserverInstanceTransactionsPerSec:                       newMetricSqlserverInstanceTransactionsPerSec(mbc.Metrics.SqlserverInstanceTransactionsPerSec),
		metricSqlserverLockModeBulkUpdate:                               newMetricSqlserverLockModeBulkUpdate(mbc.Metrics.SqlserverLockModeBulkUpdate),
		metricSqlserverLockModeExclusive:                                newMetricSqlserverLockModeExclusive(mbc.Metrics.SqlserverLockModeExclusive),
		metricSqlserverLockModeIntent:                                   newMetricSqlserverLockModeIntent(mbc.Metrics.SqlserverLockModeIntent),
		metricSqlserverLockModeSchema:                                   newMetricSqlserverLockModeSchema(mbc.Metrics.SqlserverLockModeSchema),
		metricSqlserverLockModeShared:                                   newMetricSqlserverLockModeShared(mbc.Metrics.SqlserverLockModeShared),
		metricSqlserverLockModeSharedIntentExclusive:                    newMetricSqlserverLockModeSharedIntentExclusive(mbc.Metrics.SqlserverLockModeSharedIntentExclusive),
		metricSqlserverLockModeTotal:                                    newMetricSqlserverLockModeTotal(mbc.Metrics.SqlserverLockModeTotal),
		metricSqlserverLockModeUpdate:                                   newMetricSqlserverLockModeUpdate(mbc.Metrics.SqlserverLockModeUpdate),
		metricSqlserverLockResourceAllocationUnit:                       newMetricSqlserverLockResourceAllocationUnit(mbc.Metrics.SqlserverLockResourceAllocationUnit),
		metricSqlserverLockResourceApplication:                          newMetricSqlserverLockResourceApplication(mbc.Metrics.SqlserverLockResourceApplication),
		metricSqlserverLockResourceDatabaseLevel:                        newMetricSqlserverLockResourceDatabaseLevel(mbc.Metrics.SqlserverLockResourceDatabaseLevel),
		metricSqlserverLockResourceExtent:                               newMetricSqlserverLockResourceExtent(mbc.Metrics.SqlserverLockResourceExtent),
		metricSqlserverLockResourceFile:                                 newMetricSqlserverLockResourceFile(mbc.Metrics.SqlserverLockResourceFile),
		metricSqlserverLockResourceHobt:                                 newMetricSqlserverLockResourceHobt(mbc.Metrics.SqlserverLockResourceHobt),
		metricSqlserverLockResourceKey:                                  newMetricSqlserverLockResourceKey(mbc.Metrics.SqlserverLockResourceKey),
		metricSqlserverLockResourceMetadata:                             newMetricSqlserverLockResourceMetadata(mbc.Metrics.SqlserverLockResourceMetadata),
		metricSqlserverLockResourcePage:                                 newMetricSqlserverLockResourcePage(mbc.Metrics.SqlserverLockResourcePage),
		metricSqlserverLockResourceRow:                                  newMetricSqlserverLockResourceRow(mbc.Metrics.SqlserverLockResourceRow),
		metricSqlserverLockResourceTable:                                newMetricSqlserverLockResourceTable(mbc.Metrics.SqlserverLockResourceTable),
		metricSqlserverLockResourceTotal:                                newMetricSqlserverLockResourceTotal(mbc.Metrics.SqlserverLockResourceTotal),
		metricSqlserverLockedObject:                                     newMetricSqlserverLockedObject(mbc.Metrics.SqlserverLockedObject),
		metricSqlserverMemoryTarget:                                     newMetricSqlserverMemoryTarget(mbc.Metrics.SqlserverMemoryTarget),
		metricSqlserverMemoryTotal:                                      newMetricSqlserverMemoryTotal(mbc.Metrics.SqlserverMemoryTotal),
		metricSqlserverPlanAvgElapsedTimeMs:                             newMetricSqlserverPlanAvgElapsedTimeMs(mbc.Metrics.SqlserverPlanAvgElapsedTimeMs),
		metricSqlserverSecurityServerPrincipalsCount:                    newMetricSqlserverSecurityServerPrincipalsCount(mbc.Metrics.SqlserverSecurityServerPrincipalsCount),
		metricSqlserverSecurityServerRoleMembersCount:                   newMetricSqlserverSecurityServerRoleMembersCount(mbc.Metrics.SqlserverSecurityServerRoleMembersCount),
		metricSqlserverSlowqueryAvgElapsedTimeMs:                        newMetricSqlserverSlowqueryAvgElapsedTimeMs(mbc.Metrics.SqlserverSlowqueryAvgElapsedTimeMs),
		metricSqlserverSlowqueryHistoricalExecutionCount:                newMetricSqlserverSlowqueryHistoricalExecutionCount(mbc.Metrics.SqlserverSlowqueryHistoricalExecutionCount),
		metricSqlserverSlowqueryHistoricalLogicalReads:                  newMetricSqlserverSlowqueryHistoricalLogicalReads(mbc.Metrics.SqlserverSlowqueryHistoricalLogicalReads),
		metricSqlserverSlowqueryHistoricalPhysicalReads:                 newMetricSqlserverSlowqueryHistoricalPhysicalReads(mbc.Metrics.SqlserverSlowqueryHistoricalPhysicalReads),
		metricSqlserverSlowqueryHistoricalRows:                          newMetricSqlserverSlowqueryHistoricalRows(mbc.Metrics.SqlserverSlowqueryHistoricalRows),
		metricSqlserverSlowqueryHistoricalWaitTimeMs:                    newMetricSqlserverSlowqueryHistoricalWaitTimeMs(mbc.Metrics.SqlserverSlowqueryHistoricalWaitTimeMs),
		metricSqlserverSlowqueryHistoricalWorkerTimeMs:                  newMetricSqlserverSlowqueryHistoricalWorkerTimeMs(mbc.Metrics.SqlserverSlowqueryHistoricalWorkerTimeMs),
		metricSqlserverSlowqueryIntervalAvgElapsedTimeMs:                newMetricSqlserverSlowqueryIntervalAvgElapsedTimeMs(mbc.Metrics.SqlserverSlowqueryIntervalAvgElapsedTimeMs),
		metricSqlserverSlowqueryIntervalAvgLogicalReads:                 newMetricSqlserverSlowqueryIntervalAvgLogicalReads(mbc.Metrics.SqlserverSlowqueryIntervalAvgLogicalReads),
		metricSqlserverSlowqueryIntervalAvgPhysicalReads:                newMetricSqlserverSlowqueryIntervalAvgPhysicalReads(mbc.Metrics.SqlserverSlowqueryIntervalAvgPhysicalReads),
		metricSqlserverSlowqueryIntervalAvgRows:                         newMetricSqlserverSlowqueryIntervalAvgRows(mbc.Metrics.SqlserverSlowqueryIntervalAvgRows),
		metricSqlserverSlowqueryIntervalAvgWaitTimeMs:                   newMetricSqlserverSlowqueryIntervalAvgWaitTimeMs(mbc.Metrics.SqlserverSlowqueryIntervalAvgWaitTimeMs),
		metricSqlserverSlowqueryIntervalAvgWorkerTimeMs:                 newMetricSqlserverSlowqueryIntervalAvgWorkerTimeMs(mbc.Metrics.SqlserverSlowqueryIntervalAvgWorkerTimeMs),
		metricSqlserverSlowqueryIntervalElapsedTimeMs:                   newMetricSqlserverSlowqueryIntervalElapsedTimeMs(mbc.Metrics.SqlserverSlowqueryIntervalElapsedTimeMs),
		metricSqlserverSlowqueryIntervalExecutionCount:                  newMetricSqlserverSlowqueryIntervalExecutionCount(mbc.Metrics.SqlserverSlowqueryIntervalExecutionCount),
		metricSqlserverSlowqueryIntervalLogicalReads:                    newMetricSqlserverSlowqueryIntervalLogicalReads(mbc.Metrics.SqlserverSlowqueryIntervalLogicalReads),
		metricSqlserverSlowqueryIntervalPhysicalReads:                   newMetricSqlserverSlowqueryIntervalPhysicalReads(mbc.Metrics.SqlserverSlowqueryIntervalPhysicalReads),
		metricSqlserverSlowqueryIntervalRows:                            newMetricSqlserverSlowqueryIntervalRows(mbc.Metrics.SqlserverSlowqueryIntervalRows),
		metricSqlserverSlowqueryIntervalWaitTimeMs:                      newMetricSqlserverSlowqueryIntervalWaitTimeMs(mbc.Metrics.SqlserverSlowqueryIntervalWaitTimeMs),
		metricSqlserverSlowqueryIntervalWorkerTimeMs:                    newMetricSqlserverSlowqueryIntervalWorkerTimeMs(mbc.Metrics.SqlserverSlowqueryIntervalWorkerTimeMs),
		metricSqlserverSlowqueryQueryDetails:                            newMetricSqlserverSlowqueryQueryDetails(mbc.Metrics.SqlserverSlowqueryQueryDetails),
		metricSqlserverStatsConnections:                                 newMetricSqlserverStatsConnections(mbc.Metrics.SqlserverStatsConnections),
		metricSqlserverStatsDeadlocksPerSec:                             newMetricSqlserverStatsDeadlocksPerSec(mbc.Metrics.SqlserverStatsDeadlocksPerSec),
		metricSqlserverStatsKillConnectionErrorsPerSec:                  newMetricSqlserverStatsKillConnectionErrorsPerSec(mbc.Metrics.SqlserverStatsKillConnectionErrorsPerSec),
		metricSqlserverStatsLockWaitsPerSec:                             newMetricSqlserverStatsLockWaitsPerSec(mbc.Metrics.SqlserverStatsLockWaitsPerSec),
		metricSqlserverStatsSQLCompilationsPerSec:                       newMetricSqlserverStatsSQLCompilationsPerSec(mbc.Metrics.SqlserverStatsSQLCompilationsPerSec),
		metricSqlserverStatsSQLRecompilationsPerSec:                     newMetricSqlserverStatsSQLRecompilationsPerSec(mbc.Metrics.SqlserverStatsSQLRecompilationsPerSec),
		metricSqlserverStatsUserErrorsPerSec:                            newMetricSqlserverStatsUserErrorsPerSec(mbc.Metrics.SqlserverStatsUserErrorsPerSec),
		metricSqlserverTempdbAllocationWaitsMs:                          newMetricSqlserverTempdbAllocationWaitsMs(mbc.Metrics.SqlserverTempdbAllocationWaitsMs),
		metricSqlserverTempdbCurrentWaiters:                             newMetricSqlserverTempdbCurrentWaiters(mbc.Metrics.SqlserverTempdbCurrentWaiters),
		metricSqlserverTempdbDataFileCount:                              newMetricSqlserverTempdbDataFileCount(mbc.Metrics.SqlserverTempdbDataFileCount),
		metricSqlserverTempdbPagelatchWaitsMs:                           newMetricSqlserverTempdbPagelatchWaitsMs(mbc.Metrics.SqlserverTempdbPagelatchWaitsMs),
		metricSqlserverTempdbTotalSizeMb:                                newMetricSqlserverTempdbTotalSizeMb(mbc.Metrics.SqlserverTempdbTotalSizeMb),
		metricSqlserverThreadpoolCurrentTasks:                           newMetricSqlserverThreadpoolCurrentTasks(mbc.Metrics.SqlserverThreadpoolCurrentTasks),
		metricSqlserverThreadpoolMaxWorkers:                             newMetricSqlserverThreadpoolMaxWorkers(mbc.Metrics.SqlserverThreadpoolMaxWorkers),
		metricSqlserverThreadpoolRunnableTasks:                          newMetricSqlserverThreadpoolRunnableTasks(mbc.Metrics.SqlserverThreadpoolRunnableTasks),
		metricSqlserverThreadpoolRunningWorkers:                         newMetricSqlserverThreadpoolRunningWorkers(mbc.Metrics.SqlserverThreadpoolRunningWorkers),
		metricSqlserverThreadpoolUtilizationPercent:                     newMetricSqlserverThreadpoolUtilizationPercent(mbc.Metrics.SqlserverThreadpoolUtilizationPercent),
		metricSqlserverThreadpoolWaitingTasks:                           newMetricSqlserverThreadpoolWaitingTasks(mbc.Metrics.SqlserverThreadpoolWaitingTasks),
		metricSqlserverThreadpoolWorkQueueCount:                         newMetricSqlserverThreadpoolWorkQueueCount(mbc.Metrics.SqlserverThreadpoolWorkQueueCount),
		metricSqlserverUserConnectionsAuthenticationChurnRate:           newMetricSqlserverUserConnectionsAuthenticationChurnRate(mbc.Metrics.SqlserverUserConnectionsAuthenticationChurnRate),
		metricSqlserverUserConnectionsAuthenticationLoginsPerSec:        newMetricSqlserverUserConnectionsAuthenticationLoginsPerSec(mbc.Metrics.SqlserverUserConnectionsAuthenticationLoginsPerSec),
		metricSqlserverUserConnectionsAuthenticationRecentFailedLogins:  newMetricSqlserverUserConnectionsAuthenticationRecentFailedLogins(mbc.Metrics.SqlserverUserConnectionsAuthenticationRecentFailedLogins),
		metricSqlserverUserConnectionsAuthenticationTotalFailedLogins:   newMetricSqlserverUserConnectionsAuthenticationTotalFailedLogins(mbc.Metrics.SqlserverUserConnectionsAuthenticationTotalFailedLogins),
		metricSqlserverUserConnectionsAuthenticationUniqueFailedSources: newMetricSqlserverUserConnectionsAuthenticationUniqueFailedSources(mbc.Metrics.SqlserverUserConnectionsAuthenticationUniqueFailedSources),
		metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers:   newMetricSqlserverUserConnectionsAuthenticationUniqueFailedUsers(mbc.Metrics.SqlserverUserConnectionsAuthenticationUniqueFailedUsers),
		metricSqlserverUserConnectionsClientCount:                       newMetricSqlserverUserConnectionsClientCount(mbc.Metrics.SqlserverUserConnectionsClientCount),
		metricSqlserverUserConnectionsClientUniqueHosts:                 newMetricSqlserverUserConnectionsClientUniqueHosts(mbc.Metrics.SqlserverUserConnectionsClientUniqueHosts),
		metricSqlserverUserConnectionsClientUniquePrograms:              newMetricSqlserverUserConnectionsClientUniquePrograms(mbc.Metrics.SqlserverUserConnectionsClientUniquePrograms),
		metricSqlserverUserConnectionsRunnable:                          newMetricSqlserverUserConnectionsRunnable(mbc.Metrics.SqlserverUserConnectionsRunnable),
		metricSqlserverUserConnectionsRunning:                           newMetricSqlserverUserConnectionsRunning(mbc.Metrics.SqlserverUserConnectionsRunning),
		metricSqlserverUserConnectionsSleeping:                          newMetricSqlserverUserConnectionsSleeping(mbc.Metrics.SqlserverUserConnectionsSleeping),
		metricSqlserverUserConnectionsSuspended:                         newMetricSqlserverUserConnectionsSuspended(mbc.Metrics.SqlserverUserConnectionsSuspended),
		metricSqlserverUserConnectionsTotal:                             newMetricSqlserverUserConnectionsTotal(mbc.Metrics.SqlserverUserConnectionsTotal),
		metricSqlserverUserConnectionsUtilizationActiveRatio:            newMetricSqlserverUserConnectionsUtilizationActiveRatio(mbc.Metrics.SqlserverUserConnectionsUtilizationActiveRatio),
		metricSqlserverUserConnectionsUtilizationIdleRatio:              newMetricSqlserverUserConnectionsUtilizationIdleRatio(mbc.Metrics.SqlserverUserConnectionsUtilizationIdleRatio),
		metricSqlserverWaitStatsLatchWaitTimeMs:                         newMetricSqlserverWaitStatsLatchWaitTimeMs(mbc.Metrics.SqlserverWaitStatsLatchWaitTimeMs),
		metricSqlserverWaitStatsLatchWaitingTasksCount:                  newMetricSqlserverWaitStatsLatchWaitingTasksCount(mbc.Metrics.SqlserverWaitStatsLatchWaitingTasksCount),
		metricSqlserverWaitStatsWaitTimeMs:                              newMetricSqlserverWaitStatsWaitTimeMs(mbc.Metrics.SqlserverWaitStatsWaitTimeMs),
		metricSqlserverWaitStatsWaitingTasksCount:                       newMetricSqlserverWaitStatsWaitingTasksCount(mbc.Metrics.SqlserverWaitStatsWaitingTasksCount),
		resourceAttributeIncludeFilter:                                  make(map[string]filter.Filter),
		resourceAttributeExcludeFilter:                                  make(map[string]filter.Filter),
	}
	if mbc.ResourceAttributes.DatabaseName.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["database_name"] = filter.CreateFilter(mbc.ResourceAttributes.DatabaseName.MetricsInclude)
	}
	if mbc.ResourceAttributes.DatabaseName.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["database_name"] = filter.CreateFilter(mbc.ResourceAttributes.DatabaseName.MetricsExclude)
	}
	if mbc.ResourceAttributes.DbSystem.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["db.system"] = filter.CreateFilter(mbc.ResourceAttributes.DbSystem.MetricsInclude)
	}
	if mbc.ResourceAttributes.DbSystem.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["db.system"] = filter.CreateFilter(mbc.ResourceAttributes.DbSystem.MetricsExclude)
	}
	if mbc.ResourceAttributes.EngineEdition.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["engine_edition"] = filter.CreateFilter(mbc.ResourceAttributes.EngineEdition.MetricsInclude)
	}
	if mbc.ResourceAttributes.EngineEdition.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["engine_edition"] = filter.CreateFilter(mbc.ResourceAttributes.EngineEdition.MetricsExclude)
	}
	if mbc.ResourceAttributes.ServerAddress.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["server.address"] = filter.CreateFilter(mbc.ResourceAttributes.ServerAddress.MetricsInclude)
	}
	if mbc.ResourceAttributes.ServerAddress.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["server.address"] = filter.CreateFilter(mbc.ResourceAttributes.ServerAddress.MetricsExclude)
	}
	if mbc.ResourceAttributes.ServerPort.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["server.port"] = filter.CreateFilter(mbc.ResourceAttributes.ServerPort.MetricsInclude)
	}
	if mbc.ResourceAttributes.ServerPort.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["server.port"] = filter.CreateFilter(mbc.ResourceAttributes.ServerPort.MetricsExclude)
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricSqlserverAccessPageSplitsPerSec.emit(ils.Metrics())
	mb.metricSqlserverActivequeryWaitTimeSeconds.emit(ils.Metrics())
	mb.metricSqlserverBlockingQueryDetails.emit(ils.Metrics())
	mb.metricSqlserverBufferCacheHitRatio.emit(ils.Metrics())
	mb.metricSqlserverBufferCheckpointPagesPerSec.emit(ils.Metrics())
	mb.metricSqlserverBufferPageLifeExpectancy.emit(ils.Metrics())
	mb.metricSqlserverBufferpoolBatchRequestsPerSec.emit(ils.Metrics())
	mb.metricSqlserverBufferpoolPageLifeExpectancyMs.emit(ils.Metrics())
	mb.metricSqlserverConnectionsUser.emit(ils.Metrics())
	mb.metricSqlserverDatabaseBufferpoolSizePerDatabaseBytes.emit(ils.Metrics())
	mb.metricSqlserverDatabaseIoStallMs.emit(ils.Metrics())
	mb.metricSqlserverDatabaseLogBytesFlushedPerSec.emit(ils.Metrics())
	mb.metricSqlserverDatabaseLogFlushWaitsPerSec.emit(ils.Metrics())
	mb.metricSqlserverDatabaseLogFlushesPerSec.emit(ils.Metrics())
	mb.metricSqlserverDatabaseLogTransactionGrowth.emit(ils.Metrics())
	mb.metricSqlserverDatabaseLogUsedSpaceMb.emit(ils.Metrics())
	mb.metricSqlserverDatabaseMaxDiskSizeBytes.emit(ils.Metrics())
	mb.metricSqlserverDatabasePageFileAvailableBytes.emit(ils.Metrics())
	mb.metricSqlserverDatabasePageFileTotalBytes.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsApplicationRoles.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsOld.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsOrphanedUsers.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsRecentlyCreated.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsRoles.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsSQLUsers.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsTotal.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsUsers.emit(ils.Metrics())
	mb.metricSqlserverDatabasePrincipalsWindowsUsers.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembersApplicationRoles.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembersCrossRole.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembersHighPrivilege.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembersUnique.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembershipsActive.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembershipsCustom.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembershipsNested.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembershipsTotal.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleMembershipsUsers.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRolePermissionMemberCount.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRolePermissionRiskLevel.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleRolesEmpty.emit(ils.Metrics())
	mb.metricSqlserverDatabaseRoleRolesWithMembers.emit(ils.Metrics())
	mb.metricSqlserverDatabaseSizeDataMb.emit(ils.Metrics())
	mb.metricSqlserverDatabaseSizeTotalMb.emit(ils.Metrics())
	mb.metricSqlserverDatabaseTransactionsActive.emit(ils.Metrics())
	mb.metricSqlserverExecutionPlan.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterAgClusterType.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterAgFailureConditionLevel.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterAgHealthCheckTimeout.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterAgReplicaRole.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterAgRequiredSyncSecondaries.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterAgSynchronizationHealth.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterFlowControlTimeMs.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterLogBytesReceivedPerSec.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterLogSendQueueKb.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterRedoQueueKb.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterRedoRateKbSec.emit(ils.Metrics())
	mb.metricSqlserverFailoverClusterTransactionDelayMs.emit(ils.Metrics())
	mb.metricSqlserverIndividualQueryTotalCPUMs.emit(ils.Metrics())
	mb.metricSqlserverIndividualQueryTotalElapsedMs.emit(ils.Metrics())
	mb.metricSqlserverInstanceBackgroundProcessesCount.emit(ils.Metrics())
	mb.metricSqlserverInstanceBlockedProcessesCount.emit(ils.Metrics())
	mb.metricSqlserverInstanceBufferPoolHitPercent.emit(ils.Metrics())
	mb.metricSqlserverInstanceBufferPoolSize.emit(ils.Metrics())
	mb.metricSqlserverInstanceCompilationsPerBatch.emit(ils.Metrics())
	mb.metricSqlserverInstanceConnectionsActive.emit(ils.Metrics())
	mb.metricSqlserverInstanceDiskInBytes.emit(ils.Metrics())
	mb.metricSqlserverInstanceDormantProcessesCount.emit(ils.Metrics())
	mb.metricSqlserverInstanceForcedParameterizationsPerSec.emit(ils.Metrics())
	mb.metricSqlserverInstanceFullScansRate.emit(ils.Metrics())
	mb.metricSqlserverInstanceLockTimeoutsRate.emit(ils.Metrics())
	mb.metricSqlserverInstanceMemoryAvailable.emit(ils.Metrics())
	mb.metricSqlserverInstanceMemoryTotal.emit(ils.Metrics())
	mb.metricSqlserverInstanceMemoryUtilizationPercent.emit(ils.Metrics())
	mb.metricSqlserverInstancePageSplitsPerBatch.emit(ils.Metrics())
	mb.metricSqlserverInstancePreconnectProcessesCount.emit(ils.Metrics())
	mb.metricSqlserverInstanceRunnableProcessesCount.emit(ils.Metrics())
	mb.metricSqlserverInstanceRunnableTasks.emit(ils.Metrics())
	mb.metricSqlserverInstanceRunningProcessesCount.emit(ils.Metrics())
	mb.metricSqlserverInstanceSleepingProcessesCount.emit(ils.Metrics())
	mb.metricSqlserverInstanceSuspendedProcessesCount.emit(ils.Metrics())
	mb.metricSqlserverInstanceTargetMemoryKb.emit(ils.Metrics())
	mb.metricSqlserverInstanceTransactionsPerSec.emit(ils.Metrics())
	mb.metricSqlserverLockModeBulkUpdate.emit(ils.Metrics())
	mb.metricSqlserverLockModeExclusive.emit(ils.Metrics())
	mb.metricSqlserverLockModeIntent.emit(ils.Metrics())
	mb.metricSqlserverLockModeSchema.emit(ils.Metrics())
	mb.metricSqlserverLockModeShared.emit(ils.Metrics())
	mb.metricSqlserverLockModeSharedIntentExclusive.emit(ils.Metrics())
	mb.metricSqlserverLockModeTotal.emit(ils.Metrics())
	mb.metricSqlserverLockModeUpdate.emit(ils.Metrics())
	mb.metricSqlserverLockResourceAllocationUnit.emit(ils.Metrics())
	mb.metricSqlserverLockResourceApplication.emit(ils.Metrics())
	mb.metricSqlserverLockResourceDatabaseLevel.emit(ils.Metrics())
	mb.metricSqlserverLockResourceExtent.emit(ils.Metrics())
	mb.metricSqlserverLockResourceFile.emit(ils.Metrics())
	mb.metricSqlserverLockResourceHobt.emit(ils.Metrics())
	mb.metricSqlserverLockResourceKey.emit(ils.Metrics())
	mb.metricSqlserverLockResourceMetadata.emit(ils.Metrics())
	mb.metricSqlserverLockResourcePage.emit(ils.Metrics())
	mb.metricSqlserverLockResourceRow.emit(ils.Metrics())
	mb.metricSqlserverLockResourceTable.emit(ils.Metrics())
	mb.metricSqlserverLockResourceTotal.emit(ils.Metrics())
	mb.metricSqlserverLockedObject.emit(ils.Metrics())
	mb.metricSqlserverMemoryTarget.emit(ils.Metrics())
	mb.metricSqlserverMemoryTotal.emit(ils.Metrics())
	mb.metricSqlserverPlanAvgElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSecurityServerPrincipalsCount.emit(ils.Metrics())
	mb.metricSqlserverSecurityServerRoleMembersCount.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryAvgElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryHistoricalExecutionCount.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryHistoricalLogicalReads.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryHistoricalPhysicalReads.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryHistoricalRows.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryHistoricalWaitTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryHistoricalWorkerTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalAvgElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalAvgLogicalReads.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalAvgPhysicalReads.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalAvgRows.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalAvgWaitTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalAvgWorkerTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalElapsedTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalExecutionCount.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalLogicalReads.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalPhysicalReads.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalRows.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalWaitTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryIntervalWorkerTimeMs.emit(ils.Metrics())
	mb.metricSqlserverSlowqueryQueryDetails.emit(ils.Metrics())
	mb.metricSqlserverStatsConnections.emit(ils.Metrics())
	mb.metricSqlserverStatsDeadlocksPerSec.emit(ils.Metrics())
	mb.metricSqlserverStatsKillConnectionErrorsPerSec.emit(ils.Metrics())
	mb.metricSqlserverStatsLockWaitsPerSec.emit(ils.Metrics())
	mb.metricSqlserverStatsSQLCompilationsPerSec.emit(ils.Metrics())
	mb.metricSqlserverStatsSQLRecompilationsPerSec.emit(ils.Metrics())
	mb.metricSqlserverStatsUserErrorsPerSec.emit(ils.Metrics())
	mb.metricSqlserverTempdbAllocationWaitsMs.emit(ils.Metrics())
	mb.metricSqlserverTempdbCurrentWaiters.emit(ils.Metrics())
	mb.metricSqlserverTempdbDataFileCount.emit(ils.Metrics())
	mb.metricSqlserverTempdbPagelatchWaitsMs.emit(ils.Metrics())
	mb.metricSqlserverTempdbTotalSizeMb.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolCurrentTasks.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolMaxWorkers.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolRunnableTasks.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolRunningWorkers.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolUtilizationPercent.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolWaitingTasks.emit(ils.Metrics())
	mb.metricSqlserverThreadpoolWorkQueueCount.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationChurnRate.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationLoginsPerSec.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationRecentFailedLogins.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationTotalFailedLogins.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationUniqueFailedSources.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsClientCount.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsClientUniqueHosts.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsClientUniquePrograms.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsRunnable.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsRunning.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsSleeping.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsSuspended.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsTotal.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsUtilizationActiveRatio.emit(ils.Metrics())
	mb.metricSqlserverUserConnectionsUtilizationIdleRatio.emit(ils.Metrics())
	mb.metricSqlserverWaitStatsLatchWaitTimeMs.emit(ils.Metrics())
	mb.metricSqlserverWaitStatsLatchWaitingTasksCount.emit(ils.Metrics())
	mb.metricSqlserverWaitStatsWaitTimeMs.emit(ils.Metrics())
	mb.metricSqlserverWaitStatsWaitingTasksCount.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}
	for attr, filter := range mb.resourceAttributeIncludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && !filter.Matches(val.AsString()) {
			return
		}
	}
	for attr, filter := range mb.resourceAttributeExcludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && filter.Matches(val.AsString()) {
			return
		}
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordSqlserverAccessPageSplitsPerSecDataPoint adds a data point to sqlserver.access.page_splits_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverAccessPageSplitsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverAccessPageSplitsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverActivequeryWaitTimeSecondsDataPoint adds a data point to sqlserver.activequery.wait_time_seconds metric.
func (mb *MetricsBuilder) RecordSqlserverActivequeryWaitTimeSecondsDataPoint(ts pcommon.Timestamp, val float64, sessionIDAttributeValue int64, requestIDAttributeValue int64, databaseNameAttributeValue string, loginNameAttributeValue string, hostNameAttributeValue string, queryIDAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string, waitTypeAttributeValue string, waitTypeDescriptionAttributeValue string, waitTypeCategoryAttributeValue string, waitResourceAttributeValue string, waitResourceTypeAttributeValue string, waitResourceObjectNameAttributeValue string, lastWaitTypeAttributeValue string, lastWaitTypeDescriptionAttributeValue string, requestStartTimeAttributeValue string, collectionTimestampAttributeValue string, transactionIDAttributeValue int64, openTransactionCountAttributeValue int64, planHandleAttributeValue string, blockingSessionIDAttributeValue int64, blockingLoginNameAttributeValue string, blockingQueryHashAttributeValue string, blockingNrServiceGUIDAttributeValue string, blockingNormalisedSQLHashAttributeValue string) {
	mb.metricSqlserverActivequeryWaitTimeSeconds.recordDataPoint(mb.startTime, ts, val, sessionIDAttributeValue, requestIDAttributeValue, databaseNameAttributeValue, loginNameAttributeValue, hostNameAttributeValue, queryIDAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue, waitTypeAttributeValue, waitTypeDescriptionAttributeValue, waitTypeCategoryAttributeValue, waitResourceAttributeValue, waitResourceTypeAttributeValue, waitResourceObjectNameAttributeValue, lastWaitTypeAttributeValue, lastWaitTypeDescriptionAttributeValue, requestStartTimeAttributeValue, collectionTimestampAttributeValue, transactionIDAttributeValue, openTransactionCountAttributeValue, planHandleAttributeValue, blockingSessionIDAttributeValue, blockingLoginNameAttributeValue, blockingQueryHashAttributeValue, blockingNrServiceGUIDAttributeValue, blockingNormalisedSQLHashAttributeValue)
}

// RecordSqlserverBlockingQueryDetailsDataPoint adds a data point to sqlserver.blocking_query.details metric.
func (mb *MetricsBuilder) RecordSqlserverBlockingQueryDetailsDataPoint(ts pcommon.Timestamp, val int64, sessionIDAttributeValue int64, requestIDAttributeValue int64, requestStartTimeAttributeValue string, blockingSessionIDAttributeValue int64, blockingQueryTextAttributeValue string, blockingNrServiceGUIDAttributeValue string, blockingNormalisedSQLHashAttributeValue string, newrelicEventTypeAttributeValue string) {
	mb.metricSqlserverBlockingQueryDetails.recordDataPoint(mb.startTime, ts, val, sessionIDAttributeValue, requestIDAttributeValue, requestStartTimeAttributeValue, blockingSessionIDAttributeValue, blockingQueryTextAttributeValue, blockingNrServiceGUIDAttributeValue, blockingNormalisedSQLHashAttributeValue, newrelicEventTypeAttributeValue)
}

// RecordSqlserverBufferCacheHitRatioDataPoint adds a data point to sqlserver.buffer.cache_hit_ratio metric.
func (mb *MetricsBuilder) RecordSqlserverBufferCacheHitRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverBufferCacheHitRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverBufferCheckpointPagesPerSecDataPoint adds a data point to sqlserver.buffer.checkpoint_pages_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverBufferCheckpointPagesPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverBufferCheckpointPagesPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverBufferPageLifeExpectancyDataPoint adds a data point to sqlserver.buffer.page_life_expectancy metric.
func (mb *MetricsBuilder) RecordSqlserverBufferPageLifeExpectancyDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverBufferPageLifeExpectancy.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverBufferpoolBatchRequestsPerSecDataPoint adds a data point to sqlserver.bufferpool.batch_requests_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverBufferpoolBatchRequestsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverBufferpoolBatchRequestsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverBufferpoolPageLifeExpectancyMsDataPoint adds a data point to sqlserver.bufferpool.page_life_expectancy_ms metric.
func (mb *MetricsBuilder) RecordSqlserverBufferpoolPageLifeExpectancyMsDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverBufferpoolPageLifeExpectancyMs.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverConnectionsUserDataPoint adds a data point to sqlserver.connections.user metric.
func (mb *MetricsBuilder) RecordSqlserverConnectionsUserDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverConnectionsUser.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverDatabaseBufferpoolSizePerDatabaseBytesDataPoint adds a data point to sqlserver.database.bufferpool.size_per_database_bytes metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseBufferpoolSizePerDatabaseBytesDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseBufferpoolSizePerDatabaseBytes.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseIoStallMsDataPoint adds a data point to sqlserver.database.io.stall_ms metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseIoStallMsDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseIoStallMs.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseLogBytesFlushedPerSecDataPoint adds a data point to sqlserver.database.log.bytes_flushed_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseLogBytesFlushedPerSecDataPoint(ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseLogBytesFlushedPerSec.recordDataPoint(mb.startTime, ts, val, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseLogFlushWaitsPerSecDataPoint adds a data point to sqlserver.database.log.flush_waits_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseLogFlushWaitsPerSecDataPoint(ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseLogFlushWaitsPerSec.recordDataPoint(mb.startTime, ts, val, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseLogFlushesPerSecDataPoint adds a data point to sqlserver.database.log.flushes_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseLogFlushesPerSecDataPoint(ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseLogFlushesPerSec.recordDataPoint(mb.startTime, ts, val, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseLogTransactionGrowthDataPoint adds a data point to sqlserver.database.log.transaction_growth metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseLogTransactionGrowthDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseLogTransactionGrowth.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseLogUsedSpaceMbDataPoint adds a data point to sqlserver.database.log.used_space_mb metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseLogUsedSpaceMbDataPoint(ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseLogUsedSpaceMb.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseMaxDiskSizeBytesDataPoint adds a data point to sqlserver.database.max_disk_size_bytes metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseMaxDiskSizeBytesDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseMaxDiskSizeBytes.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabasePageFileAvailableBytesDataPoint adds a data point to sqlserver.database.page_file_available_bytes metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePageFileAvailableBytesDataPoint(ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabasePageFileAvailableBytes.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabasePageFileTotalBytesDataPoint adds a data point to sqlserver.database.page_file_total_bytes metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePageFileTotalBytesDataPoint(ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabasePageFileTotalBytes.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabasePrincipalsApplicationRolesDataPoint adds a data point to sqlserver.database.principals.applicationRoles metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsApplicationRolesDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsApplicationRoles.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsOldDataPoint adds a data point to sqlserver.database.principals.old metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsOldDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsOld.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsOrphanedUsersDataPoint adds a data point to sqlserver.database.principals.orphanedUsers metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsOrphanedUsersDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsOrphanedUsers.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsRecentlyCreatedDataPoint adds a data point to sqlserver.database.principals.recentlyCreated metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsRecentlyCreatedDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsRecentlyCreated.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsRolesDataPoint adds a data point to sqlserver.database.principals.roles metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsRolesDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsRoles.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsSQLUsersDataPoint adds a data point to sqlserver.database.principals.sqlUsers metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsSQLUsersDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsSQLUsers.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsTotalDataPoint adds a data point to sqlserver.database.principals.total metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsTotalDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsTotal.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsUsersDataPoint adds a data point to sqlserver.database.principals.users metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsUsersDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsUsers.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabasePrincipalsWindowsUsersDataPoint adds a data point to sqlserver.database.principals.windowsUsers metric.
func (mb *MetricsBuilder) RecordSqlserverDatabasePrincipalsWindowsUsersDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabasePrincipalsWindowsUsers.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembersApplicationRolesDataPoint adds a data point to sqlserver.database.role.members.applicationRoles metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembersApplicationRolesDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembersApplicationRoles.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembersCrossRoleDataPoint adds a data point to sqlserver.database.role.members.crossRole metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembersCrossRoleDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembersCrossRole.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembersHighPrivilegeDataPoint adds a data point to sqlserver.database.role.members.highPrivilege metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembersHighPrivilegeDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembersHighPrivilege.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembersUniqueDataPoint adds a data point to sqlserver.database.role.members.unique metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembersUniqueDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembersUnique.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembershipsActiveDataPoint adds a data point to sqlserver.database.role.memberships.active metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembershipsActiveDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembershipsActive.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembershipsCustomDataPoint adds a data point to sqlserver.database.role.memberships.custom metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembershipsCustomDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembershipsCustom.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembershipsNestedDataPoint adds a data point to sqlserver.database.role.memberships.nested metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembershipsNestedDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembershipsNested.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembershipsTotalDataPoint adds a data point to sqlserver.database.role.memberships.total metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembershipsTotalDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembershipsTotal.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleMembershipsUsersDataPoint adds a data point to sqlserver.database.role.memberships.users metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleMembershipsUsersDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleMembershipsUsers.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRolePermissionMemberCountDataPoint adds a data point to sqlserver.database.role.permission.memberCount metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRolePermissionMemberCountDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, roleNameAttributeValue string, permissionScopeAttributeValue string) {
	mb.metricSqlserverDatabaseRolePermissionMemberCount.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, roleNameAttributeValue, permissionScopeAttributeValue)
}

// RecordSqlserverDatabaseRolePermissionRiskLevelDataPoint adds a data point to sqlserver.database.role.permission.riskLevel metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRolePermissionRiskLevelDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string, roleNameAttributeValue string, permissionScopeAttributeValue string) {
	mb.metricSqlserverDatabaseRolePermissionRiskLevel.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, roleNameAttributeValue, permissionScopeAttributeValue)
}

// RecordSqlserverDatabaseRoleRolesEmptyDataPoint adds a data point to sqlserver.database.role.roles.empty metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleRolesEmptyDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleRolesEmpty.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseRoleRolesWithMembersDataPoint adds a data point to sqlserver.database.role.roles.withMembers metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseRoleRolesWithMembersDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverDatabaseRoleRolesWithMembers.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverDatabaseSizeDataMbDataPoint adds a data point to sqlserver.database.size.data_mb metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseSizeDataMbDataPoint(ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseSizeDataMb.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseSizeTotalMbDataPoint adds a data point to sqlserver.database.size.total_mb metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseSizeTotalMbDataPoint(ts pcommon.Timestamp, val float64, databaseNameAttributeValue string, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseSizeTotalMb.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverDatabaseTransactionsActiveDataPoint adds a data point to sqlserver.database.transactions.active metric.
func (mb *MetricsBuilder) RecordSqlserverDatabaseTransactionsActiveDataPoint(ts pcommon.Timestamp, val int64, metricSourceAttributeValue string, engineEditionAttributeValue string, engineEditionIDAttributeValue int64) {
	mb.metricSqlserverDatabaseTransactionsActive.recordDataPoint(mb.startTime, ts, val, metricSourceAttributeValue, engineEditionAttributeValue, engineEditionIDAttributeValue)
}

// RecordSqlserverExecutionPlanDataPoint adds a data point to sqlserver.execution.plan metric.
func (mb *MetricsBuilder) RecordSqlserverExecutionPlanDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, planHandleAttributeValue string, nodeIDAttributeValue int64, parentNodeIDAttributeValue int64, physicalOpAttributeValue string, logicalOpAttributeValue string, inputTypeAttributeValue string, schemaNameAttributeValue string, tableNameAttributeValue string, indexNameAttributeValue string, referencedColumnsAttributeValue string, estimateRowsAttributeValue float64, estimateIoAttributeValue float64, estimateCPUAttributeValue float64, avgRowSizeAttributeValue float64, totalSubtreeCostAttributeValue float64, estimatedOperatorCostAttributeValue float64, estimatedExecutionModeAttributeValue string, grantedMemoryKbAttributeValue int64, spillOccurredAttributeValue bool, noJoinPredicateAttributeValue bool, totalWorkerTimeAttributeValue float64, totalElapsedTimeAttributeValue float64, totalLogicalReadsAttributeValue int64, executionCountAttributeValue int64, requestStartTimeAttributeValue string, lastExecutionTimeAttributeValue string, newrelicEventTypeAttributeValue string) {
	mb.metricSqlserverExecutionPlan.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, nodeIDAttributeValue, parentNodeIDAttributeValue, physicalOpAttributeValue, logicalOpAttributeValue, inputTypeAttributeValue, schemaNameAttributeValue, tableNameAttributeValue, indexNameAttributeValue, referencedColumnsAttributeValue, estimateRowsAttributeValue, estimateIoAttributeValue, estimateCPUAttributeValue, avgRowSizeAttributeValue, totalSubtreeCostAttributeValue, estimatedOperatorCostAttributeValue, estimatedExecutionModeAttributeValue, grantedMemoryKbAttributeValue, spillOccurredAttributeValue, noJoinPredicateAttributeValue, totalWorkerTimeAttributeValue, totalElapsedTimeAttributeValue, totalLogicalReadsAttributeValue, executionCountAttributeValue, requestStartTimeAttributeValue, lastExecutionTimeAttributeValue, newrelicEventTypeAttributeValue)
}

// RecordSqlserverFailoverClusterAgClusterTypeDataPoint adds a data point to sqlserver.failover_cluster.ag_cluster_type metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterAgClusterTypeDataPoint(ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	mb.metricSqlserverFailoverClusterAgClusterType.recordDataPoint(mb.startTime, ts, val, groupNameAttributeValue, clusterTypeDescAttributeValue)
}

// RecordSqlserverFailoverClusterAgFailureConditionLevelDataPoint adds a data point to sqlserver.failover_cluster.ag_failure_condition_level metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterAgFailureConditionLevelDataPoint(ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	mb.metricSqlserverFailoverClusterAgFailureConditionLevel.recordDataPoint(mb.startTime, ts, val, groupNameAttributeValue, clusterTypeDescAttributeValue)
}

// RecordSqlserverFailoverClusterAgHealthCheckTimeoutDataPoint adds a data point to sqlserver.failover_cluster.ag_health_check_timeout metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterAgHealthCheckTimeoutDataPoint(ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	mb.metricSqlserverFailoverClusterAgHealthCheckTimeout.recordDataPoint(mb.startTime, ts, val, groupNameAttributeValue, clusterTypeDescAttributeValue)
}

// RecordSqlserverFailoverClusterAgReplicaRoleDataPoint adds a data point to sqlserver.failover_cluster.ag_replica_role metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterAgReplicaRoleDataPoint(ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, roleDescAttributeValue string, synchronizationHealthDescAttributeValue string) {
	mb.metricSqlserverFailoverClusterAgReplicaRole.recordDataPoint(mb.startTime, ts, val, replicaServerNameAttributeValue, roleDescAttributeValue, synchronizationHealthDescAttributeValue)
}

// RecordSqlserverFailoverClusterAgRequiredSyncSecondariesDataPoint adds a data point to sqlserver.failover_cluster.ag_required_sync_secondaries metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterAgRequiredSyncSecondariesDataPoint(ts pcommon.Timestamp, val int64, groupNameAttributeValue string, clusterTypeDescAttributeValue string) {
	mb.metricSqlserverFailoverClusterAgRequiredSyncSecondaries.recordDataPoint(mb.startTime, ts, val, groupNameAttributeValue, clusterTypeDescAttributeValue)
}

// RecordSqlserverFailoverClusterAgSynchronizationHealthDataPoint adds a data point to sqlserver.failover_cluster.ag_synchronization_health metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterAgSynchronizationHealthDataPoint(ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, roleDescAttributeValue string, synchronizationHealthDescAttributeValue string) {
	mb.metricSqlserverFailoverClusterAgSynchronizationHealth.recordDataPoint(mb.startTime, ts, val, replicaServerNameAttributeValue, roleDescAttributeValue, synchronizationHealthDescAttributeValue)
}

// RecordSqlserverFailoverClusterFlowControlTimeMsDataPoint adds a data point to sqlserver.failover_cluster.flow_control_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterFlowControlTimeMsDataPoint(ts pcommon.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricSqlserverFailoverClusterFlowControlTimeMs.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordSqlserverFailoverClusterLogBytesReceivedPerSecDataPoint adds a data point to sqlserver.failover_cluster.log_bytes_received_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterLogBytesReceivedPerSecDataPoint(ts pcommon.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricSqlserverFailoverClusterLogBytesReceivedPerSec.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordSqlserverFailoverClusterLogSendQueueKbDataPoint adds a data point to sqlserver.failover_cluster.log_send_queue_kb metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterLogSendQueueKbDataPoint(ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, databaseNameAttributeValue string) {
	mb.metricSqlserverFailoverClusterLogSendQueueKb.recordDataPoint(mb.startTime, ts, val, replicaServerNameAttributeValue, databaseNameAttributeValue)
}

// RecordSqlserverFailoverClusterRedoQueueKbDataPoint adds a data point to sqlserver.failover_cluster.redo_queue_kb metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterRedoQueueKbDataPoint(ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, databaseNameAttributeValue string) {
	mb.metricSqlserverFailoverClusterRedoQueueKb.recordDataPoint(mb.startTime, ts, val, replicaServerNameAttributeValue, databaseNameAttributeValue)
}

// RecordSqlserverFailoverClusterRedoRateKbSecDataPoint adds a data point to sqlserver.failover_cluster.redo_rate_kb_sec metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterRedoRateKbSecDataPoint(ts pcommon.Timestamp, val int64, replicaServerNameAttributeValue string, databaseNameAttributeValue string) {
	mb.metricSqlserverFailoverClusterRedoRateKbSec.recordDataPoint(mb.startTime, ts, val, replicaServerNameAttributeValue, databaseNameAttributeValue)
}

// RecordSqlserverFailoverClusterTransactionDelayMsDataPoint adds a data point to sqlserver.failover_cluster.transaction_delay_ms metric.
func (mb *MetricsBuilder) RecordSqlserverFailoverClusterTransactionDelayMsDataPoint(ts pcommon.Timestamp, val int64, instanceNameAttributeValue string) {
	mb.metricSqlserverFailoverClusterTransactionDelayMs.recordDataPoint(mb.startTime, ts, val, instanceNameAttributeValue)
}

// RecordSqlserverIndividualQueryTotalCPUMsDataPoint adds a data point to sqlserver.individual_query.total_cpu_ms metric.
func (mb *MetricsBuilder) RecordSqlserverIndividualQueryTotalCPUMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanIDAttributeValue string, queryTextAttributeValue string, creationTimeAttributeValue string, lastExecutionTimeAttributeValue string) {
	mb.metricSqlserverIndividualQueryTotalCPUMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanIDAttributeValue, queryTextAttributeValue, creationTimeAttributeValue, lastExecutionTimeAttributeValue)
}

// RecordSqlserverIndividualQueryTotalElapsedMsDataPoint adds a data point to sqlserver.individual_query.total_elapsed_ms metric.
func (mb *MetricsBuilder) RecordSqlserverIndividualQueryTotalElapsedMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, queryPlanIDAttributeValue string, queryTextAttributeValue string, creationTimeAttributeValue string, lastExecutionTimeAttributeValue string) {
	mb.metricSqlserverIndividualQueryTotalElapsedMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, queryPlanIDAttributeValue, queryTextAttributeValue, creationTimeAttributeValue, lastExecutionTimeAttributeValue)
}

// RecordSqlserverInstanceBackgroundProcessesCountDataPoint adds a data point to sqlserver.instance.background_processes_count metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceBackgroundProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceBackgroundProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceBlockedProcessesCountDataPoint adds a data point to sqlserver.instance.blocked_processes_count metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceBlockedProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceBlockedProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceBufferPoolHitPercentDataPoint adds a data point to sqlserver.instance.buffer_pool_hit_percent metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceBufferPoolHitPercentDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceBufferPoolHitPercent.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceBufferPoolSizeDataPoint adds a data point to sqlserver.instance.buffer_pool_size metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceBufferPoolSizeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceBufferPoolSize.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceCompilationsPerBatchDataPoint adds a data point to sqlserver.instance.compilations_per_batch metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceCompilationsPerBatchDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceCompilationsPerBatch.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceConnectionsActiveDataPoint adds a data point to sqlserver.instance.connections_active metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceConnectionsActiveDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceConnectionsActive.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceDiskInBytesDataPoint adds a data point to sqlserver.instance.disk_in_bytes metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceDiskInBytesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceDiskInBytes.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceDormantProcessesCountDataPoint adds a data point to sqlserver.instance.dormant_processes_count metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceDormantProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceDormantProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceForcedParameterizationsPerSecDataPoint adds a data point to sqlserver.instance.forced_parameterizations_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceForcedParameterizationsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceForcedParameterizationsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceFullScansRateDataPoint adds a data point to sqlserver.instance.full_scans_rate metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceFullScansRateDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceFullScansRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceLockTimeoutsRateDataPoint adds a data point to sqlserver.instance.lock_timeouts_rate metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceLockTimeoutsRateDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceLockTimeoutsRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceMemoryAvailableDataPoint adds a data point to sqlserver.instance.memory_available metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceMemoryAvailableDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceMemoryTotalDataPoint adds a data point to sqlserver.instance.memory_total metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceMemoryTotalDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceMemoryTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceMemoryUtilizationPercentDataPoint adds a data point to sqlserver.instance.memory_utilization_percent metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceMemoryUtilizationPercentDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceMemoryUtilizationPercent.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstancePageSplitsPerBatchDataPoint adds a data point to sqlserver.instance.page_splits_per_batch metric.
func (mb *MetricsBuilder) RecordSqlserverInstancePageSplitsPerBatchDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstancePageSplitsPerBatch.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstancePreconnectProcessesCountDataPoint adds a data point to sqlserver.instance.preconnect_processes_count metric.
func (mb *MetricsBuilder) RecordSqlserverInstancePreconnectProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstancePreconnectProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceRunnableProcessesCountDataPoint adds a data point to sqlserver.instance.runnable_processes_count metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceRunnableProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceRunnableProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceRunnableTasksDataPoint adds a data point to sqlserver.instance.runnable_tasks metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceRunnableTasksDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceRunnableTasks.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceRunningProcessesCountDataPoint adds a data point to sqlserver.instance.running_processes_count metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceRunningProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceRunningProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceSleepingProcessesCountDataPoint adds a data point to sqlserver.instance.sleeping_processes_count metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceSleepingProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceSleepingProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceSuspendedProcessesCountDataPoint adds a data point to sqlserver.instance.suspended_processes_count metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceSuspendedProcessesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceSuspendedProcessesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceTargetMemoryKbDataPoint adds a data point to sqlserver.instance.target_memory_kb metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceTargetMemoryKbDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverInstanceTargetMemoryKb.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverInstanceTransactionsPerSecDataPoint adds a data point to sqlserver.instance.transactions_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverInstanceTransactionsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverInstanceTransactionsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverLockModeBulkUpdateDataPoint adds a data point to sqlserver.lock.mode.bulk_update metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeBulkUpdateDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeBulkUpdate.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeExclusiveDataPoint adds a data point to sqlserver.lock.mode.exclusive metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeExclusiveDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeExclusive.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeIntentDataPoint adds a data point to sqlserver.lock.mode.intent metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeIntentDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeIntent.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeSchemaDataPoint adds a data point to sqlserver.lock.mode.schema metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeSchemaDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeSchema.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeSharedDataPoint adds a data point to sqlserver.lock.mode.shared metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeSharedDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeShared.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeSharedIntentExclusiveDataPoint adds a data point to sqlserver.lock.mode.shared_intent_exclusive metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeSharedIntentExclusiveDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeSharedIntentExclusive.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeTotalDataPoint adds a data point to sqlserver.lock.mode.total metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeTotalDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeTotal.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockModeUpdateDataPoint adds a data point to sqlserver.lock.mode.update metric.
func (mb *MetricsBuilder) RecordSqlserverLockModeUpdateDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockModeUpdate.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceAllocationUnitDataPoint adds a data point to sqlserver.lock.resource.allocation_unit metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceAllocationUnitDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceAllocationUnit.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceApplicationDataPoint adds a data point to sqlserver.lock.resource.application metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceApplicationDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceApplication.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceDatabaseLevelDataPoint adds a data point to sqlserver.lock.resource.database_level metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceDatabaseLevelDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceDatabaseLevel.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceExtentDataPoint adds a data point to sqlserver.lock.resource.extent metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceExtentDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceExtent.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceFileDataPoint adds a data point to sqlserver.lock.resource.file metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceFileDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceFile.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceHobtDataPoint adds a data point to sqlserver.lock.resource.hobt metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceHobtDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceHobt.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceKeyDataPoint adds a data point to sqlserver.lock.resource.key metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceKeyDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceKey.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceMetadataDataPoint adds a data point to sqlserver.lock.resource.metadata metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceMetadataDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceMetadata.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourcePageDataPoint adds a data point to sqlserver.lock.resource.page metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourcePageDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourcePage.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceRowDataPoint adds a data point to sqlserver.lock.resource.row metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceRowDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceRow.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceTableDataPoint adds a data point to sqlserver.lock.resource.table metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceTableDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceTable.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockResourceTotalDataPoint adds a data point to sqlserver.lock.resource.total metric.
func (mb *MetricsBuilder) RecordSqlserverLockResourceTotalDataPoint(ts pcommon.Timestamp, val int64, databaseNameAttributeValue string) {
	mb.metricSqlserverLockResourceTotal.recordDataPoint(mb.startTime, ts, val, databaseNameAttributeValue)
}

// RecordSqlserverLockedObjectDataPoint adds a data point to sqlserver.locked_object metric.
func (mb *MetricsBuilder) RecordSqlserverLockedObjectDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverLockedObject.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverMemoryTargetDataPoint adds a data point to sqlserver.memory.target metric.
func (mb *MetricsBuilder) RecordSqlserverMemoryTargetDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverMemoryTarget.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverMemoryTotalDataPoint adds a data point to sqlserver.memory.total metric.
func (mb *MetricsBuilder) RecordSqlserverMemoryTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverMemoryTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverPlanAvgElapsedTimeMsDataPoint adds a data point to sqlserver.plan.avg_elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverPlanAvgElapsedTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, planHandleAttributeValue string, lastExecutionTimeAttributeValue string, creationTimeAttributeValue string) {
	mb.metricSqlserverPlanAvgElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, planHandleAttributeValue, lastExecutionTimeAttributeValue, creationTimeAttributeValue)
}

// RecordSqlserverSecurityServerPrincipalsCountDataPoint adds a data point to sqlserver.security.server_principals_count metric.
func (mb *MetricsBuilder) RecordSqlserverSecurityServerPrincipalsCountDataPoint(ts pcommon.Timestamp, val int64, metricTypeAttributeValue string) {
	mb.metricSqlserverSecurityServerPrincipalsCount.recordDataPoint(mb.startTime, ts, val, metricTypeAttributeValue)
}

// RecordSqlserverSecurityServerRoleMembersCountDataPoint adds a data point to sqlserver.security.server_role_members_count metric.
func (mb *MetricsBuilder) RecordSqlserverSecurityServerRoleMembersCountDataPoint(ts pcommon.Timestamp, val int64, metricTypeAttributeValue string) {
	mb.metricSqlserverSecurityServerRoleMembersCount.recordDataPoint(mb.startTime, ts, val, metricTypeAttributeValue)
}

// RecordSqlserverSlowqueryAvgElapsedTimeMsDataPoint adds a data point to sqlserver.slowquery.avg_elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryAvgElapsedTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryAvgElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryHistoricalExecutionCountDataPoint adds a data point to sqlserver.slowquery.historical_execution_count metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryHistoricalExecutionCountDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryHistoricalExecutionCount.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryHistoricalLogicalReadsDataPoint adds a data point to sqlserver.slowquery.historical_logical_reads metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryHistoricalLogicalReadsDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryHistoricalLogicalReads.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryHistoricalPhysicalReadsDataPoint adds a data point to sqlserver.slowquery.historical_physical_reads metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryHistoricalPhysicalReadsDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryHistoricalPhysicalReads.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryHistoricalRowsDataPoint adds a data point to sqlserver.slowquery.historical_rows metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryHistoricalRowsDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryHistoricalRows.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryHistoricalWaitTimeMsDataPoint adds a data point to sqlserver.slowquery.historical_wait_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryHistoricalWaitTimeMsDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryHistoricalWaitTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryHistoricalWorkerTimeMsDataPoint adds a data point to sqlserver.slowquery.historical_worker_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryHistoricalWorkerTimeMsDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryHistoricalWorkerTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryIntervalAvgElapsedTimeMsDataPoint adds a data point to sqlserver.slowquery.interval_avg_elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalAvgElapsedTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalAvgElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryIntervalAvgLogicalReadsDataPoint adds a data point to sqlserver.slowquery.interval_avg_logical_reads metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalAvgLogicalReadsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalAvgLogicalReads.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryIntervalAvgPhysicalReadsDataPoint adds a data point to sqlserver.slowquery.interval_avg_physical_reads metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalAvgPhysicalReadsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalAvgPhysicalReads.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryIntervalAvgRowsDataPoint adds a data point to sqlserver.slowquery.interval_avg_rows metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalAvgRowsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalAvgRows.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryIntervalAvgWaitTimeMsDataPoint adds a data point to sqlserver.slowquery.interval_avg_wait_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalAvgWaitTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalAvgWaitTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryIntervalAvgWorkerTimeMsDataPoint adds a data point to sqlserver.slowquery.interval_avg_worker_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalAvgWorkerTimeMsDataPoint(ts pcommon.Timestamp, val float64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalAvgWorkerTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryIntervalElapsedTimeMsDataPoint adds a data point to sqlserver.slowquery.interval_elapsed_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalElapsedTimeMsDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalElapsedTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryIntervalExecutionCountDataPoint adds a data point to sqlserver.slowquery.interval_execution_count metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalExecutionCountDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalExecutionCount.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryIntervalLogicalReadsDataPoint adds a data point to sqlserver.slowquery.interval_logical_reads metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalLogicalReadsDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalLogicalReads.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryIntervalPhysicalReadsDataPoint adds a data point to sqlserver.slowquery.interval_physical_reads metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalPhysicalReadsDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalPhysicalReads.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryIntervalRowsDataPoint adds a data point to sqlserver.slowquery.interval_rows metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalRowsDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalRows.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryIntervalWaitTimeMsDataPoint adds a data point to sqlserver.slowquery.interval_wait_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalWaitTimeMsDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalWaitTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryIntervalWorkerTimeMsDataPoint adds a data point to sqlserver.slowquery.interval_worker_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryIntervalWorkerTimeMsDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string) {
	mb.metricSqlserverSlowqueryIntervalWorkerTimeMs.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue)
}

// RecordSqlserverSlowqueryQueryDetailsDataPoint adds a data point to sqlserver.slowquery.query_details metric.
func (mb *MetricsBuilder) RecordSqlserverSlowqueryQueryDetailsDataPoint(ts pcommon.Timestamp, val int64, queryIDAttributeValue string, databaseNameAttributeValue string, planHandleAttributeValue string, queryTextAttributeValue string, collectionTimestampAttributeValue string, lastExecutionTimestampAttributeValue string, normalisedSQLHashAttributeValue string, nrServiceGUIDAttributeValue string, newrelicEventTypeAttributeValue string) {
	mb.metricSqlserverSlowqueryQueryDetails.recordDataPoint(mb.startTime, ts, val, queryIDAttributeValue, databaseNameAttributeValue, planHandleAttributeValue, queryTextAttributeValue, collectionTimestampAttributeValue, lastExecutionTimestampAttributeValue, normalisedSQLHashAttributeValue, nrServiceGUIDAttributeValue, newrelicEventTypeAttributeValue)
}

// RecordSqlserverStatsConnectionsDataPoint adds a data point to sqlserver.stats.connections metric.
func (mb *MetricsBuilder) RecordSqlserverStatsConnectionsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsConnections.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverStatsDeadlocksPerSecDataPoint adds a data point to sqlserver.stats.deadlocks_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverStatsDeadlocksPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsDeadlocksPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverStatsKillConnectionErrorsPerSecDataPoint adds a data point to sqlserver.stats.kill_connection_errors_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverStatsKillConnectionErrorsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsKillConnectionErrorsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverStatsLockWaitsPerSecDataPoint adds a data point to sqlserver.stats.lock_waits_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverStatsLockWaitsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsLockWaitsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverStatsSQLCompilationsPerSecDataPoint adds a data point to sqlserver.stats.sql_compilations_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverStatsSQLCompilationsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsSQLCompilationsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverStatsSQLRecompilationsPerSecDataPoint adds a data point to sqlserver.stats.sql_recompilations_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverStatsSQLRecompilationsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsSQLRecompilationsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverStatsUserErrorsPerSecDataPoint adds a data point to sqlserver.stats.user_errors_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverStatsUserErrorsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverStatsUserErrorsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverTempdbAllocationWaitsMsDataPoint adds a data point to sqlserver.tempdb.allocation_waits_ms metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbAllocationWaitsMsDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverTempdbAllocationWaitsMs.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, tempdbHealthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverTempdbCurrentWaitersDataPoint adds a data point to sqlserver.tempdb.current_waiters metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbCurrentWaitersDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverTempdbCurrentWaiters.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, tempdbHealthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverTempdbDataFileCountDataPoint adds a data point to sqlserver.tempdb.data_file_count metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbDataFileCountDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverTempdbDataFileCount.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, tempdbHealthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverTempdbPagelatchWaitsMsDataPoint adds a data point to sqlserver.tempdb.pagelatch_waits_ms metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbPagelatchWaitsMsDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverTempdbPagelatchWaitsMs.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, tempdbHealthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverTempdbTotalSizeMbDataPoint adds a data point to sqlserver.tempdb.total_size_mb metric.
func (mb *MetricsBuilder) RecordSqlserverTempdbTotalSizeMbDataPoint(ts pcommon.Timestamp, val float64, sqlHostnameAttributeValue string, tempdbHealthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverTempdbTotalSizeMb.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, tempdbHealthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolCurrentTasksDataPoint adds a data point to sqlserver.threadpool.current_tasks metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolCurrentTasksDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolCurrentTasks.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolMaxWorkersDataPoint adds a data point to sqlserver.threadpool.max_workers metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolMaxWorkersDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolMaxWorkers.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolRunnableTasksDataPoint adds a data point to sqlserver.threadpool.runnable_tasks metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolRunnableTasksDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolRunnableTasks.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolRunningWorkersDataPoint adds a data point to sqlserver.threadpool.running_workers metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolRunningWorkersDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolRunningWorkers.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolUtilizationPercentDataPoint adds a data point to sqlserver.threadpool.utilization_percent metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolUtilizationPercentDataPoint(ts pcommon.Timestamp, val float64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolUtilizationPercent.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolWaitingTasksDataPoint adds a data point to sqlserver.threadpool.waiting_tasks metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolWaitingTasksDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolWaitingTasks.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverThreadpoolWorkQueueCountDataPoint adds a data point to sqlserver.threadpool.work_queue_count metric.
func (mb *MetricsBuilder) RecordSqlserverThreadpoolWorkQueueCountDataPoint(ts pcommon.Timestamp, val int64, sqlHostnameAttributeValue string, healthStatusAttributeValue string, collectionTimestampAttributeValue string) {
	mb.metricSqlserverThreadpoolWorkQueueCount.recordDataPoint(mb.startTime, ts, val, sqlHostnameAttributeValue, healthStatusAttributeValue, collectionTimestampAttributeValue)
}

// RecordSqlserverUserConnectionsAuthenticationChurnRateDataPoint adds a data point to sqlserver.user_connections.authentication.churn_rate metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationChurnRateDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverUserConnectionsAuthenticationChurnRate.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationLoginsPerSecDataPoint adds a data point to sqlserver.user_connections.authentication.logins_per_sec metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationLoginsPerSecDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsAuthenticationLoginsPerSec.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationRecentFailedLoginsDataPoint adds a data point to sqlserver.user_connections.authentication.recent_failed_logins metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationRecentFailedLoginsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsAuthenticationRecentFailedLogins.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationTotalFailedLoginsDataPoint adds a data point to sqlserver.user_connections.authentication.total_failed_logins metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationTotalFailedLoginsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsAuthenticationTotalFailedLogins.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationUniqueFailedSourcesDataPoint adds a data point to sqlserver.user_connections.authentication.unique_failed_sources metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationUniqueFailedSourcesDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsAuthenticationUniqueFailedSources.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsAuthenticationUniqueFailedUsersDataPoint adds a data point to sqlserver.user_connections.authentication.unique_failed_users metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsAuthenticationUniqueFailedUsersDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsAuthenticationUniqueFailedUsers.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsClientCountDataPoint adds a data point to sqlserver.user_connections.client.count metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsClientCountDataPoint(ts pcommon.Timestamp, val int64, hostNameAttributeValue string, programNameAttributeValue string) {
	mb.metricSqlserverUserConnectionsClientCount.recordDataPoint(mb.startTime, ts, val, hostNameAttributeValue, programNameAttributeValue)
}

// RecordSqlserverUserConnectionsClientUniqueHostsDataPoint adds a data point to sqlserver.user_connections.client.unique_hosts metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsClientUniqueHostsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsClientUniqueHosts.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsClientUniqueProgramsDataPoint adds a data point to sqlserver.user_connections.client.unique_programs metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsClientUniqueProgramsDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsClientUniquePrograms.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsRunnableDataPoint adds a data point to sqlserver.user_connections.runnable metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsRunnableDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsRunnable.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsRunningDataPoint adds a data point to sqlserver.user_connections.running metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsRunningDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsRunning.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsSleepingDataPoint adds a data point to sqlserver.user_connections.sleeping metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsSleepingDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsSleeping.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsSuspendedDataPoint adds a data point to sqlserver.user_connections.suspended metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsSuspendedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsSuspended.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsTotalDataPoint adds a data point to sqlserver.user_connections.total metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsTotalDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSqlserverUserConnectionsTotal.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsUtilizationActiveRatioDataPoint adds a data point to sqlserver.user_connections.utilization.active_ratio metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsUtilizationActiveRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverUserConnectionsUtilizationActiveRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverUserConnectionsUtilizationIdleRatioDataPoint adds a data point to sqlserver.user_connections.utilization.idle_ratio metric.
func (mb *MetricsBuilder) RecordSqlserverUserConnectionsUtilizationIdleRatioDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricSqlserverUserConnectionsUtilizationIdleRatio.recordDataPoint(mb.startTime, ts, val)
}

// RecordSqlserverWaitStatsLatchWaitTimeMsDataPoint adds a data point to sqlserver.wait_stats.latch.wait_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverWaitStatsLatchWaitTimeMsDataPoint(ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	mb.metricSqlserverWaitStatsLatchWaitTimeMs.recordDataPoint(mb.startTime, ts, val, waitTypeAttributeValue)
}

// RecordSqlserverWaitStatsLatchWaitingTasksCountDataPoint adds a data point to sqlserver.wait_stats.latch.waiting_tasks_count metric.
func (mb *MetricsBuilder) RecordSqlserverWaitStatsLatchWaitingTasksCountDataPoint(ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	mb.metricSqlserverWaitStatsLatchWaitingTasksCount.recordDataPoint(mb.startTime, ts, val, waitTypeAttributeValue)
}

// RecordSqlserverWaitStatsWaitTimeMsDataPoint adds a data point to sqlserver.wait_stats.wait_time_ms metric.
func (mb *MetricsBuilder) RecordSqlserverWaitStatsWaitTimeMsDataPoint(ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	mb.metricSqlserverWaitStatsWaitTimeMs.recordDataPoint(mb.startTime, ts, val, waitTypeAttributeValue)
}

// RecordSqlserverWaitStatsWaitingTasksCountDataPoint adds a data point to sqlserver.wait_stats.waiting_tasks_count metric.
func (mb *MetricsBuilder) RecordSqlserverWaitStatsWaitingTasksCountDataPoint(ts pcommon.Timestamp, val float64, waitTypeAttributeValue string) {
	mb.metricSqlserverWaitStatsWaitingTasksCount.recordDataPoint(mb.startTime, ts, val, waitTypeAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
